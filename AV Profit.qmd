---
title: "AV Profit"
author: "Bijesh Mishra, Ph.D."
toc: true
number-sections: true
colorlinks: true
format:
    pdf:
      toc-location: before-body
    html:
      link-external-icon: true
      link-external-newwindow: true
    ipynb: default
editor: visual
editor_options:
  chunk_output_type: inline
---

\newpage

Analysis in this file start by loading data saved after simulating tomato, strawberry, and squash AV profits. See simulation file for more details. The result tables I have here are quite big. Results are summarized in separate excel file (Results.xlsx).

# Setting Up

## Housekeeping

```{r, warning=FALSE, error=TRUE}
# #| echo: TRUE
rm(list = ls()) # Clean the environment.
options(
  warn=0, # Warnings. options(warn=-1) / options(warn=0)
  scipen=999 # No scientific notations.
  )
```

## Working directory

Codes and output are suppressed. Errors and warnings are visible. No warning and no error means code is working as it should.

```{r, echo=FALSE, results='hide', include = FALSE, error=TRUE, warning=TRUE}
path_mac = "/Users/bmishra/Library/CloudStorage/OneDrive-AuburnUniversity/Collaboration/Ngbede M/Choice-paper"
path_office = "Users\\bzm0094\\OneDrive - Auburn University\\Collaboration\\Ngbede M\\Choice-paper"
ifelse(Sys.info()[6] == "bmishra", 
       setwd(path_mac), 
       setwd(path_office))
```

## Load libraries

```{r}
library(tidyverse, warn.conflicts = FALSE, quietly = TRUE)
library(psych, warn.conflicts = FALSE, quietly = TRUE)
library(likert,  warn.conflicts = FALSE, quietly = TRUE) # Likert Items
library(mice,  warn.conflicts = FALSE, quietly = TRUE)
library(openxlsx2, warn.conflicts = FALSE, quietly = TRUE)
library(ggpubr, warn.conflicts = FALSE, quietly = TRUE) # Scatter plot
library(gmodels,  warn.conflicts = FALSE, quietly = TRUE) # Crosstab
library(reshape2, warn.conflicts = FALSE, quietly = TRUE) # Reshape data
library(pacman,  warn.conflicts = FALSE, quietly = TRUE) # Package Management
library(progress, warn.conflicts = FALSE, quietly = TRUE) #progress bar
library(arrow, warn.conflicts = FALSE, quietly = TRUE) #feather
```

```{r}
pacman::p_loaded()
```

## Progress bar

Tracking data processing progress.

```{r}
####### Progress Bar #####
pb = progress_bar$new(
  format = "Processing data at :rate. Processed :bytes in :elapsed.",
  clear = TRUE,
  total = NA, 
  width = 80)
f = function() {
  for (i in 1:100) {
    pb$tick(sample(1:100 * 1000, 1))
    Sys.sleep(2/100)
  }
  pb$tick(1e7)
  #invisible()
}
```

## Theme for plots

Setting theme for plots:

```{r}
####### Plotting Data: #####
# Map Theme:
plottheme <- ggplot() +
  theme_void() +
  # Mapping theme:
  theme(axis.title = element_blank(),
        axis.ticks = element_blank(),
        axis.text = element_blank(),
        panel.border = element_blank(),
        plot.margin = margin(t = 0, 
                             r = 0, 
                             b = 0, 
                             l = 0, 
                             unit = "cm"),
        plot.title = element_text(hjust = 0.5),
        plot.background = element_rect(fill = "white", 
                                       color = "black",
                                       linewidth = 0),
        panel.background = element_rect(fill = "white", 
                                        color = "black",
                                        linewidth = 0),
        panel.grid.major.x = element_line(color = "lightgrey",
                                          linetype = 2,
                                          linewidth = 0),
        panel.grid.minor.x = element_line(color = "lightgrey",
                                          linetype = 2,
                                          linewidth = 0),
        panel.grid.major.y = element_line(color = "grey",
                                          linetype = 2,
                                          linewidth = 0),
        panel.grid.minor.y = element_line(color = "grey",
                                          linetype = 2,
                                          linewidth = 0),
        axis.line.x.top = element_line(color = "white",
                                       linetype = 2,
                                       linewidth = 0),
        axis.line.y.right = element_line(color = "white",
                                         linetype = 2,
                                         linewidth = 0),
        axis.line.x.bottom = element_line(color = "black",
                                          linetype = 1,
                                          linewidth = 0),
        axis.line.y.left = element_line(color = "black",
                                        linetype = 1,
                                        linewidth = 0),
        # Text formatting:
        text = element_text(family = "serif", # font
                            size = 12, # font size
                            colour = "black"# font color
        ),
        legend.position = c(0.95, -0.05),
        legend.key = element_rect(color = "black", 
                                  fill = NA, 
                                  linewidth = 0.05, 
                                  linetype = 1),
        legend.justification = "right",
        legend.direction = "horizontal")
```

# Import data

Import necessary data.

## Tomato AV

sprop = proportion of solar in agrivoltaic system (0 to 1 in 0.5 increment.0

al_regs = four regions of Alabama. Northern, Central, Black Belt, Southern.

array = Solar array; Sun tracking (Tracking) and non-tracking (Fixed).

dc_kw = DC system size (kW) See [PVWatts® Calculator](https://pvwatts.nrel.gov/pvwatts.php).

panels = number of solar panels.

energy = total energy generated from solar system. See: [PVWatts® Calculator](https://pvwatts.nrel.gov/pvwatts.php).

elecprc = electricity price (1 cents to 6 cents).

height = clearance height of solar panels. 4.6 ft., 6.4 ft., and 8.2 ft.

capex = AV system capex per kW. See: [Capex Cost for AV](https://www.nrel.gov/docs/fy21osti/77811.pdf) table 1 and table 3.

ttlcost = total solar system cost in AV. See: [Capex Cost for AV](https://www.nrel.gov/docs/fy21osti/77811.pdf) table 1 and table 3.

anncost = annualized total cost.

moncost = monthly total cost.

eprofit = profit from electricity.

eannprof = annualized total profit from electricity.

emonprof = monthly total profit from electricity.

yldvar = crop yield variation (10% to 200%)

yield = crop yield variation based on yldvar.

price = crop yield price per bucket.

profit = profit from crops.

tav_profit = total profit from solar and tomato.

```{r}
tav_profit <- as.data.frame(read_feather(file = "tav_profit.feather"))
dim(tav_profit)
#str(tav_profit)
head(tav_profit); head(tav_profit)
```

## Strawberry AV

See tomato for variable descriptions.

sbav_profit = total profit from solar and strawberry.

```{r}
sbav_profit <- as.data.frame(read_feather(file = "sbav_profit.feather"))
dim(sbav_profit)
#str(sbav_profit)
head(sbav_profit); tail(sbav_profit)
```

## Squash AV

See tomato for variable descriptions.

sqav_profit = total profit from solar and squash.

```{r}
sqav_profit <- as.data.frame(read_feather(file = "sqav_profit.feather"))
dim(sqav_profit)
#str(sqav_profit)
head(sqav_profit); tail(sqav_profit)
```

# Tabulating Results

## Tomato AV

```{r}
# Define the values for each variable
sprop <- c(0, 0.25, 0.50, 0.75, 1.00)
array <- c("Fixed", "Tracking")
height <- c(4.6, 6.4, 8.2)
yldvar <- c(0.10, 0.30, 0.50, 0.70, 1.00, 1.20, 1.50, 1.80, 2.00)
al_regs <- c("Northern", "Central", "Black Belt", "Southern")
price <- c(17, 20, 23)
elcprc <- c(0.01, 0.03, 0.06)

# Define the required columns
required_columns <- c("sprop", "array", "height", 
                      "al_regs", "yldvar", "price", "elcprc")

# Check if the columns exist in tav_profit
missing_columns <- setdiff(required_columns, 
                           names(tav_profit))
if (length(missing_columns) > 0) {
  stop("Missing columns in tav_profit: ",
       paste(missing_columns, collapse = ", "))
}

# Generate column names using reversed order of expand.grid
col_names <- apply(expand.grid(height, array, sprop), 1,
                   function(x) paste0(x[3], "%_", x[2], "_", x[1]))

# Generate row names using reversed order of expand.grid
row_names <- apply(expand.grid(elcprc, 
                               price,
                               yldvar, 
                               al_regs), 1, 
                   function(x) paste0(x, collapse = "_"))

# Create an empty matrix to store the results
result_matrix <- matrix(NA, nrow = length(row_names), 
                        ncol = length(col_names))
colnames(result_matrix) <- col_names
rownames(result_matrix) <- row_names

# Create a data frame with 
# all combinations of parameters in reversed order
param_combinations <- expand.grid(elcprc = elcprc, 
                                  price = price, 
                                  yldvar = yldvar, 
                                  al_regs = al_regs,
                                  height = height, 
                                  array = array, 
                                  sprop = sprop)

# Merge with tav_profit to get tav_profit values for each combination
merged_data <- merge(param_combinations, 
                     tav_profit, 
                     by = required_columns,
                     all.x = TRUE)

# Reshape merged_data to fill result_matrix with 
# reversed column and row names
merged_data$col_name <- apply(
  merged_data[, c("sprop", "array", "height")], 1,
  function(x) paste0(x[1], "%_", x[2], "_", x[3]))

merged_data$row_name <- apply(
  merged_data[, c("al_regs", "yldvar", "price", "elcprc")], 1,
  function(x) paste0(x[4], "_",
                     x[3], "_",
                     x[2], "_", x[1]))

# Fill the matrix with tav_profit values
for (i in seq_len(nrow(result_matrix))) {
  row_condition <- rownames(result_matrix)[i]
  row_data <- merged_data[
    merged_data$row_name == row_condition, ]
  if (nrow(row_data) > 0) {
    result_matrix[i, 
                  match(row_data$col_name, 
                        colnames(result_matrix))] <- round(
                          row_data$tav_profit, 2)
  }
}
```

```{r}
write.csv(as.data.frame(result_matrix),
          row.names = TRUE,
          col.names = TRUE,
          file = "tav_chtbl.csv")
dim(as.data.frame(result_matrix))
```

-   Row naming: Electricity Price_Crop Price_Solar Proportion_Alabama Regions

-   Column naming: Solar Proportion_Array Types_Solar Panel Height.

-   Solar Proportion can be converted to total number of panels.

-   Only selected values from each variables are extracted for tabulation purpose.

-   Values displayed in the table are profit from Tomato AV system.

```{r}
# Display the result matrix
head(result_matrix)
tail(result_matrix)
```

### Heatmap

-   Result suppressed.

```{r, echo=FALSE, results='hide', warning=FALSE, error=TRUE}

```

## Strawberry AV

```{r}
# Define the values for each variable
sprop <- c(0, 0.25, 0.50, 0.75, 1.00)
array <- c("Fixed", "Tracking")
height <- c(4.6, 6.4, 8.2)
yldvar <- c(0.10, 0.30, 0.50, 0.70, 1.00, 1.20, 1.50, 1.80, 2.00)
al_regs <- c("Northern", "Central", "Black Belt", "Southern")
price <- c(3, 6, 9)
elcprc <- c(0.01, 0.03, 0.06)

# Define the required columns
required_columns <- c("sprop", "array", "height", 
                      "al_regs", "yldvar", "price", "elcprc")

# Check if the columns exist in sbav_profit
missing_columns <- setdiff(required_columns, 
                           names(sbav_profit))
if (length(missing_columns) > 0) {
  stop("Missing columns in sbav_profit: ",
       paste(missing_columns, collapse = ", "))
}

# Generate column names using reversed order of expand.grid
col_names <- apply(expand.grid(height, array, sprop), 1,
                   function(x) paste0(x[3], "%_", x[2], "_", x[1]))

# Generate row names using reversed order of expand.grid
row_names <- apply(expand.grid(elcprc, 
                               price,
                               yldvar, 
                               al_regs), 1, 
                   function(x) paste0(x, collapse = "_"))

# Create an empty matrix to store the results
result_matrix <- matrix(NA, nrow = length(row_names), 
                        ncol = length(col_names))
colnames(result_matrix) <- col_names
rownames(result_matrix) <- row_names

# Create a data frame with 
# all combinations of parameters in reversed order
param_combinations <- expand.grid(elcprc = elcprc, 
                                  price = price, 
                                  yldvar = yldvar, 
                                  al_regs = al_regs,
                                  height = height, 
                                  array = array, 
                                  sprop = sprop)

# Merge with tav_profit to get sbav_profit values for each combination
merged_data <- merge(param_combinations, 
                     sbav_profit, 
                     by = required_columns,
                     all.x = TRUE)

# Reshape merged_data to fill result_matrix with 
# reversed column and row names
merged_data$col_name <- apply(
  merged_data[, c("sprop", "array", "height")], 1,
  function(x) paste0(x[1], "%_", x[2], "_", x[3]))

merged_data$row_name <- apply(
  merged_data[, c("al_regs", "yldvar", "price", "elcprc")], 1,
  function(x) paste0(x[4], "_",
                     x[3], "_",
                     x[2], "_", x[1]))

# Fill the matrix with sbav_profit values
for (i in seq_len(nrow(result_matrix))) {
  row_condition <- rownames(result_matrix)[i]
  row_data <- merged_data[
    merged_data$row_name == row_condition, ]
  if (nrow(row_data) > 0) {
    result_matrix[i, 
                  match(row_data$col_name, 
                        colnames(result_matrix))] <- round(
                          row_data$sbav_profit, 2)
  }
}
```

```{r}
write.csv(as.data.frame(result_matrix),
          row.names = TRUE,
          col.names = TRUE,
          file = "sbav_chtbl.csv")
dim(as.data.frame(result_matrix))
```

-   Row naming: Electricity Price_Crop Price_Solar Proportion_Alabama Regions

-   Column naming: Solar Proportion_Array Types_Solar Panel Height.

-   Solar Proportion can be converted to total number of panels.

-   Only selected values from each variables are extracted for tabulation purpose.

-   Values displayed in the table are profit from Strawberry AV system.

```{r}
# Display the result matrix
head(result_matrix)
tail(result_matrix)
```

### Heatmap

-   Result suppressed.

```{r, echo=FALSE, results='hide', warning=FALSE, error=TRUE}

```

## Squash AV

```{r}
# Define the values for each variable
sprop <- c(0, 0.25, 0.50, 0.75, 1.00)
array <- c("Fixed", "Tracking")
height <- c(4.6, 6.4, 8.2)
yldvar <- c(0.10, 0.30, 0.50, 0.70, 1.00, 1.20, 1.50, 1.80, 2.00)
al_regs <- c("Northern", "Central", "Black Belt", "Southern")
price <- c(11, 14, 17)
elcprc <- c(0.01, 0.03, 0.06)

# Define the required columns
required_columns <- c("sprop", "array", "height", 
                      "al_regs", "yldvar", "price", "elcprc")

# Check if the columns exist in sqav_profit
missing_columns <- setdiff(required_columns, 
                           names(sqav_profit))
if (length(missing_columns) > 0) {
  stop("Missing columns in sqav_profit: ",
       paste(missing_columns, collapse = ", "))
}

# Generate column names using reversed order of expand.grid
col_names <- apply(expand.grid(height, array, sprop), 1,
                   function(x) paste0(x[3], "%_", x[2], "_", x[1]))

# Generate row names using reversed order of expand.grid
row_names <- apply(expand.grid(elcprc, 
                               price,
                               yldvar, 
                               al_regs), 1, 
                   function(x) paste0(x, collapse = "_"))

# Create an empty matrix to store the results
result_matrix <- matrix(NA, nrow = length(row_names), 
                        ncol = length(col_names))
colnames(result_matrix) <- col_names
rownames(result_matrix) <- row_names

# Create a data frame with 
# all combinations of parameters in reversed order
param_combinations <- expand.grid(elcprc = elcprc, 
                                  price = price, 
                                  yldvar = yldvar, 
                                  al_regs = al_regs,
                                  height = height, 
                                  array = array, 
                                  sprop = sprop)

# Merge with tav_profit to get sqav_profit values for each combination
merged_data <- merge(param_combinations, 
                     sqav_profit, 
                     by = required_columns,
                     all.x = TRUE)

# Reshape merged_data to fill result_matrix with 
# reversed column and row names
merged_data$col_name <- apply(
  merged_data[, c("sprop", "array", "height")], 1,
  function(x) paste0(x[1], "%_", x[2], "_", x[3]))

merged_data$row_name <- apply(
  merged_data[, c("al_regs", "yldvar", "price", "elcprc")], 1,
  function(x) paste0(x[4], "_",
                     x[3], "_",
                     x[2], "_", x[1]))

# Fill the matrix with sqav_profit values
for (i in seq_len(nrow(result_matrix))) {
  row_condition <- rownames(result_matrix)[i]
  row_data <- merged_data[
    merged_data$row_name == row_condition, ]
  if (nrow(row_data) > 0) {
    result_matrix[i, 
                  match(row_data$col_name, 
                        colnames(result_matrix))] <- round(
                          row_data$sqav_profit, 2)
  }
}
```

```{r}
write.csv(as.data.frame(result_matrix),
          row.names = TRUE,
          file = "sqav_chtbl.csv")
dim(as.data.frame(result_matrix))
```

-   Row naming: Electricity Price_Crop Price_Solar Proportion_Alabama Regions

-   Column naming: Solar Proportion_Array Types_Solar Panel Height.

-   Solar Proportion can be converted to total number of panels.

-   Only selected values from each variables are extracted for tabulation purpose.

-   Values displayed in the table are profit from Squash AV system.

```{r}
# Display the result matrix
head(result_matrix)
tail(result_matrix)
```

### Heatmap

-   Result suppressed.

```{r, echo=FALSE, results='hide', warning=FALSE, error=TRUE}

```
