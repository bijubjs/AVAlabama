---
title: "AV Profit"
author: "Bijesh Mishra, Ph.D."
toc: true
number-sections: true
colorlinks: true
format:
    pdf:
      toc-location: before-body
    html:
      link-external-icon: true
      link-external-newwindow: true
    ipynb: default
editor: visual
editor_options:
  chunk_output_type: inline
---

\newpage

Analysis in this file start by loading data saved after simulating tomato, strawberry, and squash AV profits. See simulation file for more details. The result tables I have here are quite big. Results are summarized in separate excel file (Results.xlsx).

# Setting Up

## Housekeeping

```{r, warning=FALSE, error=TRUE}
# #| echo: TRUE
rm(list = ls()) # Clean the environment.
options(
  warn=0, # Warnings. options(warn=-1) / options(warn=0)
  scipen=999 # No scientific notations.
  )
```

## Working directory

Codes and output are suppressed. Errors and warnings are visible. No warning and no error means code is working as it should.

```{r, echo=FALSE, results='hide', error=TRUE, eval=FALSE, warning=TRUE}
path_mac = "/Users/bmishra/Library/CloudStorage/OneDrive-AuburnUniversity/Collaboration/Ngbede M/Choice-paper"
path_office = "Users\\bzm0094\\OneDrive - Auburn University\\Collaboration\\Ngbede M\\Choice-paper"
ifelse(Sys.info()[6] == "bmishra",
       setwd(path_mac),
       setwd(path_office))
```

## Load libraries

```{r}
library(tidyverse, warn.conflicts = FALSE, quietly = TRUE)
library(psych, warn.conflicts = FALSE, quietly = TRUE)
library(likert,  warn.conflicts = FALSE, quietly = TRUE) # Likert Items
library(mice,  warn.conflicts = FALSE, quietly = TRUE)
library(openxlsx2, warn.conflicts = FALSE, quietly = TRUE)
library(ggpubr, warn.conflicts = FALSE, quietly = TRUE) # Scatter plot
library(gmodels,  warn.conflicts = FALSE, quietly = TRUE) # Crosstab
library(reshape2, warn.conflicts = FALSE, quietly = TRUE) # Reshape data
library(pacman,  warn.conflicts = FALSE, quietly = TRUE) # Package Management
library(progress, warn.conflicts = FALSE, quietly = TRUE) # Progress bar
library(arrow, warn.conflicts = FALSE, quietly = TRUE) # Feather
library(plot3D, warn.conflicts = FALSE, quietly = TRUE)
library(plotly, warn.conflicts = FALSE, quietly = TRUE) # 3D plotting
library(lattice, warn.conflicts = FALSE, quietly = TRUE)
```

```{r}
#pacman::p_loaded()
```

## Theme for plots

Setting theme for plots:

```{r, error=TRUE, warning=FALSE, echo=TRUE, eval=TRUE}
####### Plotting Data: #####
# Map Theme:
plottheme <- ggplot() +
  theme_void() +
  # Mapping theme:
  theme(axis.title = element_blank(),
        axis.ticks = element_blank(),
        axis.text = element_blank(),
        panel.border = element_blank(),
        plot.margin = margin(t = 0, 
                             r = 0, 
                             b = 0, 
                             l = 0, 
                             unit = "cm"),
        plot.title = element_text(hjust = 0.5),
        plot.background = element_rect(fill = "white", 
                                       color = "black",
                                       linewidth = 0),
        panel.background = element_rect(fill = "white", 
                                        color = "black",
                                        linewidth = 0),
        panel.grid.major.x = element_line(color = "lightgrey",
                                          linetype = 2,
                                          linewidth = 0),
        panel.grid.minor.x = element_line(color = "lightgrey",
                                          linetype = 2,
                                          linewidth = 0),
        panel.grid.major.y = element_line(color = "grey",
                                          linetype = 2,
                                          linewidth = 0),
        panel.grid.minor.y = element_line(color = "grey",
                                          linetype = 2,
                                          linewidth = 0),
        axis.line.x.top = element_line(color = "white",
                                       linetype = 2,
                                       linewidth = 0),
        axis.line.y.right = element_line(color = "white",
                                         linetype = 2,
                                         linewidth = 0),
        axis.line.x.bottom = element_line(color = "black",
                                          linetype = 1,
                                          linewidth = 0),
        axis.line.y.left = element_line(color = "black",
                                        linetype = 1,
                                        linewidth = 0),
        # Text formatting:
        text = element_text(family = "serif", # font
                            size = 12, # font size
                            colour = "black"# font color
        ),
        legend.position = c(0.95, -0.05),
        legend.key = element_rect(color = "black", 
                                  fill = NA, 
                                  linewidth = 0.05, 
                                  linetype = 1),
        legend.justification = "right",
        legend.direction = "horizontal")
```

# Import data

Import necessary data.

## Tomato AV

Parameters defining agrivoltaic systems:

-   sprop = proportion of solar in agrivoltaic system (0 to 1 in 0.5 increment.) Length = 21.

-   al_regs = four regions of Alabama. Northern, Central, Black Belt, Southern. Length = 4.

-   array = Solar array; Sun tracking (Tracking) and non-tracking (Fixed). Length = 2.

-   elecprc = electricity price (1 cents to 6 cents). Length = 6.

-   height = clearance height of solar panels. 4.6 ft., 6.4 ft., and 8.2 ft. Length = 3.

-   yldvar = crop yield variation (10% to 200%) = Length 21.

-   yield = crop yield variation based on yldvar. (same as yldvar) = Length = 21.

Calculated results using above parameters:

-   dc_kw = DC system size (kW) See [PVWatts® Calculator](https://pvwatts.nrel.gov/pvwatts.php).

-   panels = number of solar panels.

-   energy = total energy generated from solar system. See: [PVWatts® Calculator](https://pvwatts.nrel.gov/pvwatts.php).

-   capex = AV system capex per kW. See: [Capex Cost for AV](https://www.nrel.gov/docs/fy21osti/77811.pdf) table 1 and table 3.

-   ttlcost = total solar system cost in AV. See: [Capex Cost for AV](https://www.nrel.gov/docs/fy21osti/77811.pdf) table 1 and table 3.

-   anncost = annualized total cost.

-   moncost = monthly total cost.

-   price = crop yield price per bucket.

-   eprofit = profit from electricity.

Result of Interests:

-   eannprof = annualized total profit from electricity.

-   emonprof = monthly total profit from electricity.

-   profit = profit from crops.

-   tav_profit = total profit from solar and tomato.

```{r}
tav_profit <- as.data.frame(read_feather(file = "tav_profit.feather"))
#str(tav_profit)
#head(tav_profit); head(tav_profit)
dim(tav_profit)
```

## Strawberry AV

See tomato for variable descriptions.

sbav_profit = total profit from solar and strawberry.

```{r}
sbav_profit <- as.data.frame(read_feather(file = "sbav_profit.feather"))
#str(sbav_profit)
#head(sbav_profit); tail(sbav_profit)
dim(sbav_profit)
```

## Squash AV

See tomato for variable descriptions.

sqav_profit = total profit from solar and squash.

```{r}
sqav_profit <- as.data.frame(read_feather(file = "sqav_profit.feather"))
#str(sqav_profit)
#head(sqav_profit); tail(sqav_profit)
dim(sqav_profit)
```

# Tabulating and Plotting Results

## Tomato AV

```{r}
# Define the values for each variable
sprop <- c(0, 0.25, 0.50, 0.75, 1.00) # Land Proportion
array <- c("Fixed", "Tracking") # Solar Array
height <- c(4.6, 6.4, 8.2) # Panel height
yldvar <- c(0.10, 0.30, 0.50, 0.70, 1.00, 1.20, 1.50, 1.80, 2.00) # Crop Yield Variation
al_regs <- c("Northern", "Central", "Black Belt", "Southern") # Regions of AL
price <- c(17, 20, 23) # Crop Price
elcprc <- c(0.02, 0.03, 0.04) # Electricity Price

# Define the required columns
required_columns <- c("sprop", "array", "height", 
                      "al_regs", "yldvar", "price", "elcprc")

# Check if the columns exist in tav_profit
missing_columns <- setdiff(required_columns, 
                           names(tav_profit))
if (length(missing_columns) > 0) {
  stop("Missing columns in tav_profit: ",
       paste(missing_columns, collapse = ", "))
}

# Generate column names using reversed order of expand.grid
col_names <- apply(expand.grid(height, array, sprop), 1,
                   function(x) paste0(x[3], "%_", x[2], "_", x[1]))

# Generate row names using reversed order of expand.grid
row_names <- apply(expand.grid(elcprc, 
                               price,
                               yldvar, 
                               al_regs), 1, 
                   function(x) paste0(x, collapse = "_"))

# Create an empty matrix to store the results
result_matrix <- matrix(NA, nrow = length(row_names), 
                        ncol = length(col_names))
colnames(result_matrix) <- col_names
rownames(result_matrix) <- row_names

# Create a data frame with 
# all combinations of parameters in reversed order
param_combinations <- expand.grid(elcprc = elcprc, 
                                  price = price, 
                                  yldvar = yldvar, 
                                  al_regs = al_regs,
                                  height = height, 
                                  array = array, 
                                  sprop = sprop)

# Merge with tav_profit to get tav_profit values for each combination
merged_data <- merge(param_combinations, 
                     tav_profit, 
                     by = required_columns,
                     all.x = TRUE)

# Reshape merged_data to fill result_matrix with 
# reversed column and row names
merged_data$col_name <- apply(
  merged_data[, c("sprop", "array", "height")], 1,
  function(x) paste0(x[1], "%_", x[2], "_", x[3]))

merged_data$row_name <- apply(
  merged_data[, c("al_regs", "yldvar", "price", "elcprc")], 1,
  function(x) paste0(x[4], "_",
                     x[3], "_",
                     x[2], "_", x[1]))

# Fill the matrix with tav_profit values
for (i in seq_len(nrow(result_matrix))) {
  row_condition <- rownames(result_matrix)[i]
  row_data <- merged_data[
    merged_data$row_name == row_condition, ]
  if (nrow(row_data) > 0) {
    result_matrix[i, 
                  match(row_data$col_name, 
                        colnames(result_matrix))] <- round(
                          row_data$tav_profit, 2)
  }
}
tav_chtbl <- as.data.frame(result_matrix) #Table in Excel.
rm(result_matrix)
```

```{r}
write.csv(as.data.frame(tav_chtbl),
          row.names = TRUE,
          #col.names = TRUE,
          file = "tav_chtbl.csv")
dim(tav_chtbl)
```

-   Row naming: Electricity Price_Crop Price_Solar Proportion_Alabama Regions

-   Column naming: Solar Proportion_Array Types_Solar Panel Height.

-   Solar Proportion can be converted to total number of panels.

-   Only selected values from each variables are extracted for tabulation purpose.

-   Values displayed in the table are profit from Tomato AV system.

```{r}
# Display the result matrix
#head(tav_chtbl)
#tail(tav_chtbl)
names(tav_profit)
```

### Plotting Tomato Profits by Solar Proportions

You can see plot breakdown based on yield variation, crop price, and electricity price. You can see variation for all solar proportion in one facet of the chart. Each facet of the chart contain av profit three heights of solar panels, four regions of AL, two array types.

```{r, echo = FALSE, eval=FALSE, results = 'hide', warning=TRUE, error=TRUE, cache=TRUE}
# Inefficient code, supressed.
lox <- c("Northern", "Central", "Black Belt", "Southern")
array_levs <- c("Single Axis Rotation", "Fixed Open Rack")
for (i in unique(tav_profit$yield)) {
  for (j in unique(tav_profit$price)) {
    for (k in unique(tav_profit$elcprc)) {
      tav_plot = tav_profit %>% 
        filter(yield == i, price == j, elcprc == k)
      tomato_plot <-ggplot(data = tav_plot,
       mapping = aes(x = sprop,
                     y = tav_profit,
                     color = factor(al_regs),
                     group = factor(al_regs))) +
  geom_line() +
  geom_point() +
  facet_grid(array~height) +
  guides(color = guide_legend(ncol = 1,
                              reverse = TRUE))
print(tomato_plot)
#ggsave(file = "tomato_plot.png")
    }
  }
}
```

```{r, eval=TRUE, warning=TRUE, error=TRUE, cache=TRUE}
lox <- c("Northern", "Central", "Black Belt", "Southern")
array_levs <- c("Single Axis Rotation", "Fixed Open Rack")
combinations <- expand.grid(
  yldvar = c(0.1, 0.3, 0.5, 0.7, 1, 1.20, 1.5, 1.80, 2), # Yield proportion
  price = c(17, 20, 23), # Tomato price
  elcprc = c(0.03, 0.04, 0.05) #Electricity price
)

# Iterate over the combinations and create the plots
for (combo in seq_len(nrow(combinations))) {
  filtered_data <- tav_profit %>%
    filter(
      yldvar == combinations$yldvar[combo],
      price == combinations$price[combo],
      elcprc == combinations$elcprc[combo]
    )
  
  tav_sp_plot <- ggplot(data = filtered_data,
                        mapping = aes(x = al_regs,
                                      y = tav_profit,
                                      color = factor(sprop),
                                      group = factor(sprop))) +
    geom_line() +
    geom_point() +
    facet_grid(height ~ array) +
    guides(color = guide_legend(ncol = 1, reverse = TRUE)) +
    scale_x_discrete(limits = lox,
                     labels = c("North", "Center", "B Belt", "South")) +
    guides(color = guide_legend(ncol = 2, reverse = TRUE))
  
  # Add horizontal line at y = 0 if y has both positive and negative values
  if (min(filtered_data$tav_profit) < 0
      & max(filtered_data$tav_profit) > 0) {
    tav_sp_plot <- tav_sp_plot + 
      geom_hline(yintercept = 0,
                 size = 1,
                 linetype = "dotted", 
                 color = "black")
    }
    
  print(combinations[combo,])
  print(tav_sp_plot)
  ggsave(file = paste0("Plots/tav_sp_", combo, ".png"))
}
```

### Plotting Tomato Profits by Yield Variation

You can see plot breakdown based on solar proportion, crop price, and electricity price. You can see variation for all crop yield variation in one facet of the chart. Each facet of the chart contain av profit three heights of solar panels, four regions of AL, two array types.

```{r, eval=TRUE, warning=TRUE, error=TRUE, cache=TRUE}
lox <- c("Northern", "Central", "Black Belt", "Southern")
array_levs <- c("Single Axis Rotation", "Fixed Open Rack")
combinations <- expand.grid(
  sprop = c(0, 0.25, 0.5, 0.75, 1), # Solar proportion
  price = c(17, 20, 23), # Tomato price
  elcprc = c(0.03, 0.04, 0.05) #Electricity price
)

# Iterate over the combinations and create the plots
for (combo in seq_len(nrow(combinations))) {
  filtered_data <- tav_profit %>%
    filter(
      sprop == combinations$sprop[combo],
      price == combinations$price[combo],
      elcprc == combinations$elcprc[combo]
    )
  
  tav_yv_plot <- ggplot(data = filtered_data,
                        mapping = aes(x = al_regs,
                                      y = tav_profit,
                                      color = factor(yldvar),
                                      group = factor(yldvar))) +
    geom_line() +
    geom_point() +
    facet_grid(height ~ array) +
    guides(color = guide_legend(ncol = 1, 
                                reverse = TRUE)) +
    scale_x_discrete(limits = lox,
                     labels = c("North", "Center", "B Belt", "South")) +
    guides(color = guide_legend(ncol = 2, 
                                reverse = TRUE))
  
  # Add horizontal line at y = 0 if y has both positive and negative values
  if (min(filtered_data$tav_profit) < 0
      & max(filtered_data$tav_profit) > 0) {
    tav_yv_plot <- tav_yv_plot + 
      geom_hline(yintercept = 0,
                 size = 1,
                 linetype = "dotted", 
                 color = "black")
  }
  
  print(combinations[combo,])
  print(tav_yv_plot)
  ggsave(file = paste0("Plots/tav_yv_", combo, ".png"))
  }
```

## Strawberry AV

```{r}
# Define the values for each variable
sprop <- c(0, 0.25, 0.50, 0.75, 1.00)
array <- c("Fixed", "Tracking")
height <- c(4.6, 6.4, 8.2)
yldvar <- c(0.10, 0.30, 0.50, 0.70, 1.00, 1.20, 1.50, 1.80, 2.00)
al_regs <- c("Northern", "Central", "Black Belt", "Southern")
price <- c(3, 6, 9)
elcprc <- c(0.02, 0.03, 0.04)

# Define the required columns
required_columns <- c("sprop", "array", "height", 
                      "al_regs", "yldvar", "price", "elcprc")

# Check if the columns exist in sbav_profit
missing_columns <- setdiff(required_columns, 
                           names(sbav_profit))
if (length(missing_columns) > 0) {
  stop("Missing columns in sbav_profit: ",
       paste(missing_columns, collapse = ", "))
}

# Generate column names using reversed order of expand.grid
col_names <- apply(expand.grid(height, array, sprop), 1,
                   function(x) paste0(x[3], "%_", x[2], "_", x[1]))

# Generate row names using reversed order of expand.grid
row_names <- apply(expand.grid(elcprc, 
                               price,
                               yldvar, 
                               al_regs), 1, 
                   function(x) paste0(x, collapse = "_"))

# Create an empty matrix to store the results
result_matrix <- matrix(NA, nrow = length(row_names), 
                        ncol = length(col_names))
colnames(result_matrix) <- col_names
rownames(result_matrix) <- row_names

# Create a data frame with
# all combinations of parameters in reversed order
param_combinations <- expand.grid(elcprc = elcprc, 
                                  price = price, 
                                  yldvar = yldvar, 
                                  al_regs = al_regs,
                                  height = height, 
                                  array = array, 
                                  sprop = sprop)

# Merge with tav_profit to get sbav_profit values for each combination
merged_data <- merge(param_combinations, 
                     sbav_profit, 
                     by = required_columns,
                     all.x = TRUE)

# Reshape merged_data to fill result_matrix with 
# reversed column and row names
merged_data$col_name <- apply(
  merged_data[, c("sprop", "array", "height")], 1,
  function(x) paste0(x[1], "%_", x[2], "_", x[3]))

merged_data$row_name <- apply(
  merged_data[, c("al_regs", "yldvar", "price", "elcprc")], 1,
  function(x) paste0(x[4], "_",
                     x[3], "_",
                     x[2], "_", x[1]))

# Fill the matrix with sbav_profit values
for (i in seq_len(nrow(result_matrix))) {
  row_condition <- rownames(result_matrix)[i]
  row_data <- merged_data[
    merged_data$row_name == row_condition, ]
  if (nrow(row_data) > 0) {
    result_matrix[i, 
                  match(row_data$col_name, 
                        colnames(result_matrix))] <- round(
                          row_data$sbav_profit, 2)
  }
}
sbav_chtbl <- as.data.frame(result_matrix) #Table in Excel.
rm(result_matrix)
```

```{r}
write.csv(as.data.frame(sbav_chtbl),
          row.names = TRUE,
          #col.names = TRUE,
          file = "sbav_chtbl.csv")
dim(sbav_chtbl)
names(sbav_chtbl)
```

-   Row naming: Electricity Price_Crop Price_Solar Proportion_Alabama Regions

-   Column naming: Solar Proportion_Array Types_Solar Panel Height.

-   Solar Proportion can be converted to total number of panels.

-   Only selected values from each variables are extracted for tabulation purpose.

-   Values displayed in the table are profit from Strawberry AV system.

```{r}
# Display the result matrix
#head(sbav_chtbl)
#tail(sbav_chtbl)
names(sbav_profit)
```

### Plotting Strawberry Profit by Solar Proportion

You can see plot breakdown based on yield variation, crop price, and electricity price. You can see variation for all solar proportion in one facet of the chart. Each facet of the chart contain av profit three heights of solar panels, four regions of AL, two array types.

```{r, echo=TRUE, warning=TRUE, error=TRUE, eval=TRUE}
lox <- c("Northern", "Central", "Black Belt", "Southern")
array_levs = c("Single Axis Rotation", "Fixed Open Rack")
combinations <- expand.grid(
  yldvar = c(0.1, 0.3, 0.5, 0.7, 1, 1.20, 1.5, 1.80, 2), # Yield proportion
  price = c(3, 6, 9), # Strawbeery price
  elcprc = c(0.03, 0.04, 0.05) #Electricity price
)

# Iterate over the combinations and create the plots
for (combo in seq_len(nrow(combinations))) {
  filtered_data <- sbav_profit %>%
    filter(
      yldvar == combinations$yldvar[combo],
      price == combinations$price[combo],
      elcprc == combinations$elcprc[combo]
    )
  
  sbav_sp_plot <- ggplot(data = filtered_data,
                        mapping = aes(x = al_regs,
                                      y = sbav_profit,
                                      color = factor(sprop),
                                      group = factor(sprop))) +
    geom_line() +
    geom_point() +
    facet_grid(height ~ array) +
    guides(color = guide_legend(ncol = 1, reverse = TRUE)) +
    scale_x_discrete(limits = lox,
                     labels = c("North", "Center", "B Belt", "South")) +
    guides(color = guide_legend(ncol = 2, reverse = TRUE))
  
    # Add horizontal line at y = 0 if y has both positive and negative values
  if (min(filtered_data$sbav_profit) < 0
      & max(filtered_data$sbav_profit) > 0) {
    sbav_sp_plot <- sbav_sp_plot + 
      geom_hline(yintercept = 0,
                 size = 1,
                 linetype = "dotted", 
                 color = "black")
  }
  
  print(combinations[combo,])
  print(sbav_sp_plot)
  ggsave(file = paste0("Plots/sbav_sp_", combo, ".png"))
}
```

### Plotting Strawberry Profit by Yield Variation

You can see plot breakdown based on solar proportion, crop price, and electricity price. You can see variation for all crop yield variation in one facet of the chart. Each facet of the chart contain av profit three heights of solar panels, four regions of AL, two array types.

```{r, eval=TRUE, echo=TRUE, warning=TRUE, error=TRUE}
lox <- c("Northern", "Central", "Black Belt", "Southern")
array_levs = c("Single Axis Rotation", "Fixed Open Rack")
combinations <- expand.grid(
  sprop = c(0, 0.25, 0.5, 0.75, 1), # Solar proportion
  price = c(3, 6, 9), # Strawberry price
  elcprc = c(0.03, 0.04, 0.05) #Electricity price
)

# Iterate over the combinations and create the plots
for (combo in seq_len(nrow(combinations))) {
  filtered_data <- sbav_profit %>%
    filter(
      sprop == combinations$sprop[combo],
      price == combinations$price[combo],
      elcprc == combinations$elcprc[combo]
    )
  
  sbav_yv_plot <- ggplot(data = filtered_data,
                        mapping = aes(x = al_regs,
                                      y = sbav_profit,
                                      color = factor(yldvar),
                                      group = factor(yldvar))) +
    geom_line() +
    geom_point() +
    facet_grid(height ~ array) +
    guides(color = guide_legend(ncol = 1, reverse = TRUE)) +
    scale_x_discrete(limits = lox,
                     labels = c("North", "Center", "B Belt", "South")) +
    guides(color = guide_legend(ncol = 2, reverse = TRUE))
  
    # Add horizontal line at y = 0 if y has both positive and negative values
  if (min(filtered_data$sbav_profit) < 0
      & max(filtered_data$sbav_profit) > 0) {
    sbav_yv_plot <- sbav_yv_plot + 
      geom_hline(yintercept = 0,
                 size = 1,
                 linetype = "dotted", 
                 color = "black")
  }
  
  print(combinations[combo,])
  print(sbav_yv_plot)
  ggsave(file = paste0("Plots/sbav_yv_", combo, ".png"))
}
```

## Squash AV

```{r}
# Define the values for each variable
sprop <- c(0, 0.25, 0.50, 0.75, 1.00)
array <- c("Fixed", "Tracking")
height <- c(4.6, 6.4, 8.2)
yldvar <- c(0.10, 0.30, 0.50, 0.70, 1.00, 1.20, 1.50, 1.80, 2.00)
al_regs <- c("Northern", "Central", "Black Belt", "Southern")
price <- c(11, 14, 17)
elcprc <- c(0.02, 0.03, 0.04)

# Define the required columns
required_columns <- c("sprop", "array", "height", 
                      "al_regs", "yldvar", "price", "elcprc")

# Check if the columns exist in sqav_profit
missing_columns <- setdiff(required_columns, 
                           names(sqav_profit))
if (length(missing_columns) > 0) {
  stop("Missing columns in sqav_profit: ",
       paste(missing_columns, collapse = ", "))
}

# Generate column names using reversed order of expand.grid
col_names <- apply(expand.grid(height, array, sprop), 1,
                   function(x) paste0(x[3], "%_", x[2], "_", x[1]))

# Generate row names using reversed order of expand.grid
row_names <- apply(expand.grid(elcprc, 
                               price,
                               yldvar, 
                               al_regs), 1, 
                   function(x) paste0(x, collapse = "_"))

# Create an empty matrix to store the results
result_matrix <- matrix(NA, nrow = length(row_names), 
                        ncol = length(col_names))
colnames(result_matrix) <- col_names
rownames(result_matrix) <- row_names

# Create a data frame with 
# all combinations of parameters in reversed order
param_combinations <- expand.grid(elcprc = elcprc, 
                                  price = price, 
                                  yldvar = yldvar, 
                                  al_regs = al_regs,
                                  height = height, 
                                  array = array, 
                                  sprop = sprop)

# Merge with tav_profit to get sqav_profit values for each combination
merged_data <- merge(param_combinations, 
                     sqav_profit, 
                     by = required_columns,
                     all.x = TRUE)

# Reshape merged_data to fill result_matrix with 
# reversed column and row names
merged_data$col_name <- apply(
  merged_data[, c("sprop", "array", "height")], 1,
  function(x) paste0(x[1], "%_", x[2], "_", x[3]))

merged_data$row_name <- apply(
  merged_data[, c("al_regs", "yldvar", "price", "elcprc")], 1,
  function(x) paste0(x[4], "_",
                     x[3], "_",
                     x[2], "_", x[1]))

# Fill the matrix with sqav_profit values
for (i in seq_len(nrow(result_matrix))) {
  row_condition <- rownames(result_matrix)[i]
  row_data <- merged_data[
    merged_data$row_name == row_condition, ]
  if (nrow(row_data) > 0) {
    result_matrix[i, 
                  match(row_data$col_name, 
                        colnames(result_matrix))] <- round(
                          row_data$sqav_profit, 2)
  }
}
sqav_chtbl <- as.data.frame(result_matrix) #Table in Excel.
rm(result_matrix)
```

```{r}
write.csv(as.data.frame(sqav_chtbl),
          row.names = TRUE,
          file = "sqav_chtbl.csv")
dim(sqav_chtbl)
```

-   Row naming: Electricity Price_Crop Price_Solar Proportion_Alabama Regions

-   Column naming: Solar Proportion_Array Types_Solar Panel Height.

-   Solar Proportion can be converted to total number of panels.

-   Only selected values from each variables are extracted for tabulation purpose.

-   Values displayed in the table are profit from Squash AV system.

```{r}
# Display the result matrix
#head(sqav_chtbl)
#tail(sqav_chtbl)
names(sqav_profit)
```

### Plotting Squash Profit by Solar Proportion

You can see plot breakdown based on yield variation, crop price, and electricity price. You can see variation for all solar proportion in one facet of the chart. Each facet of the chart contain av profit three heights of solar panels, four regions of AL, two array types.

```{r, echo=TRUE, results='show', warning=FALSE, error=TRUE, eval=TRUE}
lox <- c("Northern", "Central", "Black Belt", "Southern")
array_levs = c("Single Axis Rotation", "Fixed Open Rack")
combinations <- expand.grid(
  yldvar = c(0.1, 0.3, 0.5, 0.7, 1, 1.20, 1.5, 1.80, 2), # Yield proportion
  price = c(11, 14, 17), # Tomato price
  elcprc = c(0.03, 0.04, 0.05) #Electricity price
)

# Iterate over the combinations and create the plots
for (combo in seq_len(nrow(combinations))) {
  filtered_data <- sqav_profit %>%
    filter(
      yldvar == combinations$yldvar[combo],
      price == combinations$price[combo],
      elcprc == combinations$elcprc[combo]
    )
  
  sqav_sp_plot <- ggplot(data = filtered_data,
                        mapping = aes(x = al_regs,
                                      y = sqav_profit,
                                      color = factor(sprop),
                                      group = factor(sprop))) +
    geom_line() +
    geom_point() +
    facet_grid(height ~ array) +
    guides(color = guide_legend(ncol = 1, reverse = TRUE)) +
    scale_x_discrete(limits = lox,
                     labels = c("North", "Center", "B Belt", "South")) +
    guides(color = guide_legend(ncol = 2, reverse = TRUE))
  
      # Add horizontal line at y = 0 if y has both positive and negative values
  if (min(filtered_data$sqav_profit) < 0
      & max(filtered_data$sqav_profit) > 0) {
    sqav_sp_plot <- sqav_sp_plot + 
      geom_hline(yintercept = 0,
                 size = 1,
                 linetype = "dotted", 
                 color = "black")
  }
  
  print(combinations[combo,])
  print(sqav_sp_plot)
  ggsave(file = paste0("Plots/sqav_sp_", combo, ".png"))
}
```

### Plotting Squash Profit by Yield Variation

You can see plot breakdown based on solar proportion, crop price, and electricity price. You can see variation for all crop yield variation in one facet of the chart. Each facet of the chart contain av profit three heights of solar panels, four regions of AL, two array types.

```{r, echo=TRUE, results='show', warning=FALSE, error=TRUE, eval=TRUE}
lox <- c("Northern", "Central", "Black Belt", "Southern")
array_levs = c("Single Axis Rotation", "Fixed Open Rack")
combinations <- expand.grid(
  sprop = c(0, 0.25, 0.5, 0.75, 1), # Solar proportion
  price = c(11, 14, 17), # Tomato price
  elcprc = c(0.03, 0.04, 0.05) #Electricity price
)

# Iterate over the combinations and create the plots
for (combo in seq_len(nrow(combinations))) {
  filtered_data <- sqav_profit %>%
    filter(
      sprop == combinations$sprop[combo],
      price == combinations$price[combo],
      elcprc == combinations$elcprc[combo]
    )
  
  sqav_yv_plot <- ggplot(data = filtered_data,
                        mapping = aes(x = al_regs,
                                      y = sqav_profit,
                                      color = factor(yldvar),
                                      group = factor(yldvar))) +
    geom_line() +
    geom_point() +
    facet_grid(height ~ array) +
    guides(color = guide_legend(ncol = 1, 
                                reverse = TRUE)) +
    scale_x_discrete(limits = lox,
                     labels = c("North", "Center", "B Belt", "South")) +
    guides(color = guide_legend(ncol = 2, 
                                reverse = TRUE))
  
      # Add horizontal line at y = 0 if y has both positive and negative values
  if (min(filtered_data$sqav_profit) < 0
      & max(filtered_data$sqav_profit) > 0) {
    sqav_yv_plot <- sqav_yv_plot + 
      geom_hline(yintercept = 0,
                 size = 1,
                 linetype = "dotted", 
                 color = "black")
  }
  
  print(combinations[combo,])
  print(sqav_yv_plot)
  ggsave(file = paste0("Plots/sqav_yv_", combo, ".png"))
}
```
