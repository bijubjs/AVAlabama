---
title: "AV Profit"
author: "Bijesh Mishra, Ph.D."
toc: true
number-sections: true
colorlinks: true
format:
    pdf:
      toc-location: before-body
    html:
      link-external-icon: true
      link-external-newwindow: true
    ipynb: default
editor: visual
editor_options:
  chunk_output_type: inline
---

\newpage

Analysis in this file start by loading data saved after simulating tomato, strawberry, and squash AV profits. See simulation file for more details. The result tables I have here are quite big. Results are summarized in separate excel file (Results.xlsx).

# Setting Up

## Housekeeping

```{r, warning=FALSE, error=TRUE}
# #| echo: TRUE
rm(list = ls()) # Clean the environment.
options(
  warn=0, # Warnings. options(warn=-1) / options(warn=0)
  scipen=999 # No scientific notations.
  )
```

## Working directory

Codes and output are suppressed. Errors and warnings are visible. No warning and no error means code is working as it should.

```{r, echo=FALSE, results='hide', error=TRUE, eval=FALSE, warning=TRUE}
path_mac = "/Users/bmishra/Library/CloudStorage/OneDrive-AuburnUniversity/Collaboration/Ngbede M/Choice-paper"
path_office = "Users\\bzm0094\\OneDrive - Auburn University\\Collaboration\\Ngbede M\\Choice-paper"
ifelse(Sys.info()[6] == "bmishra",
       setwd(path_mac),
       setwd(path_office))
```

## Load libraries

```{r, error=TRUE, warning=FALSE, echo=TRUE, eval=TRUE}
library(tidyverse, warn.conflicts = FALSE, quietly = TRUE)
library(psych, warn.conflicts = FALSE, quietly = TRUE)
library(likert,  warn.conflicts = FALSE, quietly = TRUE) # Likert Items
library(mice,  warn.conflicts = FALSE, quietly = TRUE)
library(openxlsx2, warn.conflicts = FALSE, quietly = TRUE)
library(ggpubr, warn.conflicts = FALSE, quietly = TRUE) # Scatter plot
library(gmodels,  warn.conflicts = FALSE, quietly = TRUE) # Crosstab
library(reshape2, warn.conflicts = FALSE, quietly = TRUE) # Reshape data
library(pacman,  warn.conflicts = FALSE, quietly = TRUE) 
library(progress, warn.conflicts = FALSE, quietly = TRUE) # Progress bar
library(arrow, warn.conflicts = FALSE, quietly = TRUE) # Feather
library(plot3D, warn.conflicts = FALSE, quietly = TRUE)
library(plotly, warn.conflicts = FALSE, quietly = TRUE) # 3D plotting
library(lattice, warn.conflicts = FALSE, quietly = TRUE)
library(purrr, warn.conflicts = FALSE, quietly = TRUE)
library(furrr, warn.conflicts = FALSE, quietly = TRUE)
library(pheatmap, warn.conflicts = FALSE, quietly = TRUE)
library(grid, warn.conflicts = FALSE, quietly = TRUE)
library(data.table, warn.conflicts = FALSE, quietly = TRUE)
library(parallel, warn.conflicts = FALSE, quietly = TRUE)
```

```{r, echo=TRUE}
pacman::p_loaded()
```

## Theme for plots

Setting theme for plots:

```{r, error=TRUE, warning=FALSE, echo=TRUE, eval=TRUE}
####### Plotting Data: #####
# Map Theme:
plottheme <- ggplot() +
  theme_void() +
  # Mapping theme:
  theme(axis.title = element_blank(),
        axis.ticks = element_blank(),
        axis.text = element_blank(),
        panel.border = element_blank(),
        plot.margin = margin(t = 0, 
                             r = 0, 
                             b = 0, 
                             l = 0, 
                             unit = "cm"),
        plot.title = element_text(hjust = 0.5),
        plot.background = element_rect(fill = "white", 
                                       color = "black",
                                       linewidth = 0),
        panel.background = element_rect(fill = "white", 
                                        color = "black",
                                        linewidth = 0),
        panel.grid.major.x = element_line(color = "lightgrey",
                                          linetype = 2,
                                          linewidth = 0),
        panel.grid.minor.x = element_line(color = "lightgrey",
                                          linetype = 2,
                                          linewidth = 0),
        panel.grid.major.y = element_line(color = "grey",
                                          linetype = 2,
                                          linewidth = 0),
        panel.grid.minor.y = element_line(color = "grey",
                                          linetype = 2,
                                          linewidth = 0),
        axis.line.x.top = element_line(color = "white",
                                       linetype = 2,
                                       linewidth = 0),
        axis.line.y.right = element_line(color = "white",
                                         linetype = 2,
                                         linewidth = 0),
        axis.line.x.bottom = element_line(color = "black",
                                          linetype = 1,
                                          linewidth = 0),
        axis.line.y.left = element_line(color = "black",
                                        linetype = 1,
                                        linewidth = 0),
        # Text formatting:
        text = element_text(family = "serif", # font
                            size = 12, # font size
                            colour = "black"# font color
        ),
        legend.position = c(0.95, -0.05),
        legend.key = element_rect(color = "black", 
                                  fill = NA, 
                                  linewidth = 0.05, 
                                  linetype = 1),
        legend.justification = "right",
        legend.direction = "horizontal")
```

# Import data

Import necessary data.

## Tomato AV

Parameters defining agrivoltaic systems:

-   sprop = proportion of solar in agrivoltaic system (0 to 1 in 0.5 increment.) Length = 21.

-   panels = number of solar panels. Length = 16. Some sprop have same number of panels.

-   al_regs = four regions of Alabama. Northern, Central, Black Belt, Southern. Length = 4.

-   array = Solar array; Sun tracking (Tracking) and non-tracking (Fixed). Length = 2.

-   elecprc = electricity price (1 cents to 6 cents). Length = 6.

-   height = clearance height of solar panels. 4.6 ft., 6.4 ft., and 8.2 ft. Length = 3.

-   yldvar = crop yield variation (10% to 200%) = Length 21.

-   yield = crop yield variation based on yldvar. (same as yldvar) = Length = 21.

Calculated results using above parameters:

-   dc_kw = DC system size (kW) See [PVWatts® Calculator](https://pvwatts.nrel.gov/pvwatts.php).

-   energy = total energy generated from solar system. See: [PVWatts® Calculator](https://pvwatts.nrel.gov/pvwatts.php).

-   capex = AV system capex per kW. See: [Capex Cost for AV](https://www.nrel.gov/docs/fy21osti/77811.pdf) table 1 and table 3.

-   ttlcost = total solar system cost in AV. See: [Capex Cost for AV](https://www.nrel.gov/docs/fy21osti/77811.pdf) table 1 and table 3.

-   anncost = annualized total cost.

-   moncost = monthly total cost.

-   price = crop yield price per bucket.

-   eprofit = profit from electricity.

Result of Interests:

-   eannprof = annualized total profit from electricity.

-   emonprof = monthly total profit from electricity.

-   profit = profit from crops.

-   tav_profit = total profit from solar and tomato.

```{r}
tav_profit <- as.data.frame(
  read_feather(file = "Data/tav_profit.feather")
  )
#str(tav_profit)
#head(tav_profit); head(tav_profit)
dim(tav_profit)
```

## Calculate tavp_wocp

-   Profit at 100% crop at their respective price is subtracted from tav_profit.

-   tavp_wocp = tav_profit - profit from 100% crop at their respective prices. This variable gives an idea where av profit stands in relation to crop profit. It helps to identify relative profitability of agrivoltaic system compared to crop only.

    ```{r}
    # Calculate the profit:
    # Step 1: Filter the dataframe to get the unique profit values for each price when yldvar is 1
    unique_profits <- unique(tav_profit[tav_profit$yldvar == 1, 
                                        c("price", "profit")])

    # Step 2: Create a lookup table for unique profits by price
    profit_lookup <- setNames(unique_profits$profit, 
                              unique_profits$price)

    # Step 3: Create the new variable tavp_wocp by subtracting the unique profit from tav_profit
    tav_profit$tavp_wocp <- mapply(function(tav_profit, price) {
      profit_to_subtract <- ifelse(price %in% 
                                     names(profit_lookup), 
                                   profit_lookup[as.character(price)], 0)
      return(tav_profit - profit_to_subtract)
    }, tav_profit$tav_profit, tav_profit$price)
    rm(unique_profits); rm(profit_lookup)
    ```

## TAV Profit \> Tomato Alone

Tomato yield where tomato AV start becoming more profitable than tomato alone.

```{r}
# Convert the data frame to a data.table for faster operations
setDT(tav_profit)

# Function to process each subset
process_subset <- function(subset) {
  subset <- subset[order(-tavp_wocp)]
  
  # Find the row where yield changes from positive to negative
  change_row <- which(diff(sign(subset$tavp_wocp)) == -2)[1]
  
  # Check if change_row is not NA
  if (!is.na(change_row)) {
    result_row <- subset[change_row, ]
    return(result_row)
  } else {
    return(NULL)
  }
}

# Split data by unique combinations of the filtering criteria
split_data <- split(tav_profit, 
                    by = c("al_regs", "array", "sprop", 
                           "elcprc", "price", "height"))

# Apply the process_subset function in parallel
results <- mclapply(split_data, 
                    process_subset, 
                    mc.cores = detectCores())

# Combine all results into a single data.table
tav_be_yld <- rbindlist(results, 
                        use.names = TRUE,
                        fill = TRUE) %>% 
  select(al_regs, array, sprop,panels, elcprc, price,
         height, profit, yldvar, yield, tav_profit, tavp_wocp)
rm(results); rm(split_data); rm(process_subset)
```

```{r}
write.csv(as.data.frame(tav_be_yld),
          row.names = TRUE,
          #col.names = TRUE,
          file = "Results/tav_brkevn_yield.csv")
dim(tav_be_yld)
```

## Strawberry AV

See tomato for variable descriptions.

sbav_profit = total profit from solar and strawberry.

```{r}
sbav_profit <- as.data.frame(
  read_feather(file = "Data/sbav_profit.feather")
  )
#str(sbav_profit)
#head(sbav_profit); tail(sbav_profit)
dim(sbav_profit)
```

## Calculate sbvp_wocp

-   Profit at 100% crop at their respective price is subtracted from sbav_profit.

-   sbavp_wocp = sbav_profit - profit from 100% crop at their respective prices. This variable gives an idea where av profit stands in relation to crop profit. It helps to identify relative profitability of agrivoltaic system compared to crop only.

    ```{r}
    # Calculate the profit:
    # Step 1: Filter the dataframe to get the unique profit values for each price when yldvar is 1
    unique_profits <- unique(sbav_profit[sbav_profit$yldvar == 1, 
                                        c("price", "profit")])

    # Step 2: Create a lookup table for unique profits by price
    profit_lookup <- setNames(unique_profits$profit, 
                              unique_profits$price)

    # Step 3: Create the new variable sbavp_wocp by subtracting the unique profit from sqav_profit
    sbav_profit$sbavp_wocp <- mapply(function(sbav_profit, price) {
      profit_to_subtract <- ifelse(price %in% 
                                     names(profit_lookup), 
                                   profit_lookup[as.character(price)], 0)
      return(sbav_profit - profit_to_subtract)
    }, sbav_profit$sbav_profit, sbav_profit$price)
    rm(unique_profits); rm(profit_lookup)
    ```

## SBAV Profit \> Strawberry Alone

Strawberry yield where strawberry AV profit start becoming more profitable than strawberry alone.

```{r}
# Convert the data frame to a data.table for faster operations
setDT(sbav_profit)

# Function to process each subset
process_subset <- function(subset) {
  subset <- subset[order(-sbavp_wocp)]
  
  # Find the row where yield changes from positive to negative
  change_row <- which(diff(sign(subset$sbavp_wocp)) == -2)[1]
  
  # Check if change_row is not NA
  if (!is.na(change_row)) {
    result_row <- subset[change_row, ]
    return(result_row)
  } else {
    return(NULL)
  }
}

# Split data by unique combinations of the filtering criteria
split_data <- split(sbav_profit, 
                    by = c("al_regs", "array", "sprop", 
                           "elcprc", "price", "height"))

# Apply the process_subset function in parallel
results <- mclapply(split_data, 
                    process_subset, 
                    mc.cores = detectCores())

# Combine all results into a single data.table
sbav_be_yld <- rbindlist(results, 
                        use.names = TRUE,
                        fill = TRUE) %>% 
    select(al_regs, array, sprop,panels, elcprc, price,
         height, profit, yldvar, yield, sbav_profit, sbavp_wocp)
rm(results); rm(split_data); rm(process_subset)
```

```{r}
write.csv(as.data.frame(sbav_be_yld),
          row.names = TRUE,
          #col.names = TRUE,
          file = "Results/sbav_brkevn_yield.csv")
dim(sbav_be_yld)
```

## Squash AV

-   See tomato for variable descriptions.

-   sqav_profit = total profit from solar and squash.

```{r}
sqav_profit <- as.data.frame(
  read_feather(file = "Data/sqav_profit.feather")
  )
#head(sqav_profit); tail(sqav_profit)
dim(sqav_profit)
```

## Calculate sqvp_wocp

-   Profit at 100% crop at their respective price is subtracted from sqav_profit.

-   sqavp_wocp = sbav_profit - profit from 100% crop at their respective prices. This variable gives an idea where av profit stands in relation to crop profit. It helps to identify relative profitability of agrivoltaic system compared to crop only.

    ```{r}
    # Calculate the profit:
    # Step 1: Filter the dataframe to get the unique profit values for each price when yldvar is 1
    unique_profits <- unique(sqav_profit[sqav_profit$yldvar == 1, 
                                        c("price", "profit")])

    # Step 2: Create a lookup table for unique profits by price
    profit_lookup <- setNames(unique_profits$profit, 
                              unique_profits$price)

    # Step 3: Create the new variable sbavp_wocp by subtracting the unique profit from sqav_profit
    sqav_profit$sqavp_wocp <- mapply(function(sqav_profit, price) {
      profit_to_subtract <- ifelse(price %in% 
                                     names(profit_lookup), 
                                   profit_lookup[as.character(price)], 0)
      return(sqav_profit - profit_to_subtract)
    }, sqav_profit$sqav_profit, sqav_profit$price)
    rm(unique_profits); rm(profit_lookup)
    ```

## SQAV Profit \> Squash Alone

Summer squash yield where squash AV profit start becoming more profitable than squash alone.

```{r}
# Convert the data frame to a data.table for faster operations
setDT(sqav_profit)

# Function to process each subset
process_subset <- function(subset) {
  subset <- subset[order(-sqavp_wocp)]
  
  # Find the row where yield changes from positive to negative
  change_row <- which(diff(sign(subset$sqavp_wocp)) == -2)[1]
  
  # Check if change_row is not NA
  if (!is.na(change_row)) {
    result_row <- subset[change_row, ]
    return(result_row)
  } else {
    return(NULL)
  }
}

# Split data by unique combinations of the filtering criteria
split_data <- split(sqav_profit, 
                    by = c("al_regs", "array", "sprop", 
                           "elcprc", "price", "height"))

# Apply the process_subset function in parallel
results <- mclapply(split_data, 
                    process_subset, 
                    mc.cores = detectCores())

# Combine all results into a single data.table
sqav_be_yld <- rbindlist(results, 
                        use.names = TRUE,
                        fill = TRUE) %>% 
    select(al_regs, array, sprop,panels, elcprc, price,
         height, profit, yldvar, yield, sqav_profit, sqavp_wocp)
rm(results); rm(split_data); rm(process_subset)
```

```{r}
write.csv(as.data.frame(sqav_be_yld),
          row.names = TRUE,
          #col.names = TRUE,
          file = "Results/sqav_brkevn_yield.csv")
dim(sqav_be_yld)
```

# Tomato AV Results

## tav_profit Crosstab (648\*15)

-   Row naming: Electricity Price_Crop Price_Solar Proportion_Alabama Regions.

-   Column naming: Solar Proportion_Array Types_Solar Panel Height.

-   Solar Proportion can be converted to total number of panels.

-   Only selected values from each variables are extracted for tabulation purpose.

-   Values displayed in the table are profit from Tomato AV system.

```{r}
# Define the values for each variable
sprop <- c(0, 0.05, 0.10, 0.15, 0.20, 0.25, 0.30, 0.35, 0.40, 0.45, 0.50,
           0.55, 0.60, 0.65, 0.70, 0.75, 0.80, 0.85, 0.90, 0.95, 1.00) # Land Proportion
array <- c("Fixed", "Tracking") # Solar Array
height <- c(4.6, 6.4, 8.2) # Panel height
yldvar <- c(0.10, 0.20, 0.30, 0.40, 0.50, 0.60, 0.70, 0.80, 0.90, 1.00, 
            1.10, 1.20, 1.30, 1.40, 1.50, 1.60, 1.70, 1.80, 1.90, 2.00)
al_regs <- c("Northern", "Central", 
             "Black Belt", "Southern") # Regions of AL
price <- c(17, 18, 19, 20, 21, 22, 23) # Crop Price
elcprc <- c(0.02, 0.03, 0.04) # Electricity Price

# Define the required columns
required_columns <- c("sprop", "array", "height", "al_regs",
                      "yldvar", "price", "elcprc")

# Check if the columns exist in tav_profit
missing_columns <- setdiff(required_columns, 
                           names(tav_profit))
if (length(missing_columns) > 0) {
  stop("Missing columns in tav_profit: ", 
       paste(missing_columns, collapse = ", "))
}

# Generate column names using expand.grid without array
col_names <- apply(expand.grid(height, sprop),
                   1, function(x) paste0(x[2], "%_", x[1]))

# Generate row names using expand.grid with array included
row_names <- apply(expand.grid(elcprc, price, 
                               yldvar, al_regs, array), 1, 
                   function(x) paste0(x[4], "_",
                                      x[3], "_", 
                                      x[2], "_", 
                                      x[1], "_", 
                                      x[5]))

# Create an empty matrix to store the results
result_matrix <- matrix(NA, 
                        nrow = length(row_names),
                        ncol = length(col_names))
colnames(result_matrix) <- col_names
rownames(result_matrix) <- row_names

# Create a data frame with all combinations of parameters
param_combinations <- expand.grid(elcprc = elcprc, 
                                  price = price, 
                                  yldvar = yldvar, 
                                  al_regs = al_regs,
                                  array = array, 
                                  height = height, 
                                  sprop = sprop)

# Merge with tav_profit to get av_profit values for each combination
merged_data <- merge(param_combinations, 
                     tav_profit, 
                     by = c("sprop", "array", "height",
                            "al_regs", "yldvar", 
                            "price", "elcprc"), 
                     all.x = TRUE)

# Reshape merged_data to fill result_matrix with adjusted column and row names
merged_data$col_name <- apply(merged_data[, c("sprop", "height")], 1,
                              function(x) paste0(x[1], "%_", x[2]))
merged_data$row_name <- apply(merged_data[, c("al_regs", "yldvar", 
                                              "price", "elcprc", 
                                              "array")], 1, 
                              function(x) paste0(x[1], "_",
                                                 x[2], "_", 
                                                 x[3], "_", 
                                                 x[4], "_", 
                                                 x[5]))

# Fill the matrix with av_profit values
for (i in seq_len(nrow(result_matrix))) {
  row_condition <- rownames(result_matrix)[i]
  row_data <- merged_data[merged_data$row_name == row_condition, ]
  if (nrow(row_data) > 0) {
    result_matrix[i, 
                  match(row_data$col_name, 
                        colnames(result_matrix))] <- round (
                             row_data$tav_profit, 2)
  }
}

# Display the result matrix
ct_tav_pft64815 <- as.data.frame(result_matrix) # Table in Excel.
rm(result_matrix); rm(sprop); rm(array); rm(height); 
rm(elcprc); rm(price); rm(yldvar); rm(al_regs)
```

## tav_profit Crosstab (324\*30)

```{r}
# Define the values for each variable
sprop <- c(0, 0.05, 0.10, 0.15, 0.20, 0.25, 0.30, 0.35, 0.40, 0.45, 0.50,
           0.55, 0.60, 0.65, 0.70, 0.75, 0.80, 0.85, 0.90, 0.95, 1.00) # Land Proportion
array <- c("Fixed", "Tracking") # Solar Array
height <- c(4.6, 6.4, 8.2) # Panel height
yldvar <- c(0.10, 0.20, 0.30, 0.40, 0.50, 0.60, 0.70, 0.80, 0.90, 1.00, 
            1.10, 1.20, 1.30, 1.40, 1.50, 1.60, 1.70, 1.80, 1.90, 2.00)
al_regs <- c("Northern", "Central", "Black Belt", "Southern") # Regions of AL
price <- c(17, 18, 19, 20, 21, 22, 23) # Crop Price
elcprc <- c(0.02, 0.03, 0.04) # Electricity Price

# Define the required columns
required_columns <- c("sprop", "array", "height", 
                      "al_regs", "yldvar", "price", "elcprc")

# Check if the columns exist in tav_profit
missing_columns <- setdiff(required_columns, 
                           names(tav_profit))
if (length(missing_columns) > 0) {
  stop("Missing columns in tav_profit: ",
       paste(missing_columns,
             collapse = ", "))
}

# Generate column names using reversed order of expand.grid
col_names <- apply(expand.grid(height, array, sprop), 1,
                   function(x) paste0(x[3], x[2], x[1]))

# Generate row names using reversed order of expand.grid
row_names <- apply(expand.grid(elcprc, 
                               price,
                               yldvar, 
                               al_regs), 1, 
                   function(x) paste0(x, collapse = ""))

# Create an empty matrix to store the results
result_matrix <- matrix(NA, 
                        nrow = length(row_names), 
                        ncol = length(col_names))
colnames(result_matrix) <- col_names
rownames(result_matrix) <- row_names

# Create a data frame with 
# all combinations of parameters in reversed order
param_combinations <- expand.grid(elcprc = elcprc, 
                                  price = price, 
                                  yldvar = yldvar, 
                                  al_regs = al_regs,
                                  height = height, 
                                  array = array, 
                                  sprop = sprop)

# Merge with tav_profit to get tav_profit values for each combination
merged_data <- merge(param_combinations, 
                     tav_profit, 
                     by = required_columns,
                     all.x = TRUE)

# Reshape merged_data to fill result_matrix with 
# reversed column and row names
merged_data$col_name <- apply(
  merged_data[, c("sprop", "array", "height")], 1,
  function(x) paste0(x[1], x[2], x[3]))

merged_data$row_name <- apply(
  merged_data[, c("al_regs", "yldvar", "price", "elcprc")], 1,
  function(x) paste0(x[4],
                     x[3],
                     x[2],
                     x[1]))

# Fill the matrix with tav_profit values
for (i in seq_len(nrow(result_matrix))) {
  row_condition <- rownames(result_matrix)[i]
  row_data <- merged_data[
    merged_data$row_name == row_condition, ]
  if (nrow(row_data) > 0) {
    result_matrix[i, 
                  match(row_data$col_name, 
                        colnames(result_matrix))] <- round(
                          row_data$tav_profit, 2)
  }
}
ct_tav_pft <- as.data.frame(result_matrix) # Table in Excel.
#Shape crosstab.
# Display the result matrix
rm(result_matrix); rm(sprop); rm(array); rm(height); 
rm(elcprc); rm(price); rm(yldvar); rm(al_regs)
```

```{r}
write.csv(as.data.frame(ct_tav_pft),
          row.names = TRUE,
          file = "Results/ct_tav_profit.csv")
dim(ct_tav_pft)
```

## tav_profit Heatmap

-   Heatmap of 324\*30 dimension matrix
-   Tomato profit.

```{r, eval=TRUE}
colorcount = length(unique(as.vector(as.matrix(ct_tav_pft[-1]))))
colorcount
heatmap_plot <- pheatmap(t(ct_tav_pft),
                         #clustering_distance_rows = "correlation",
                         clustering_distance_rows = "euclidean",
                         clustering_distance_cols = "euclidean",
                         clustering_method = "complete",
                         color = colorRampPalette(c("red", 
                                                    "yellow", 
                                                    "green"))(colorcount),
                         #cutree_rows = 5,
                         #cutree_cols = 4,
                         cluster_rows = FALSE,
                         cluster_cols = FALSE,
                         show_rownames = FALSE,
                         show_colnames = FALSE,
                         display_numbers = FALSE,
                         border_color = "black",
                         number_format = "%.2f",
                         #cellheight = 16,
                         #cellwidth = 3
                         )
```

```{r, eval=TRUE, echo=TRUE}
ggsave(heatmap_plot,
       height = 8,
       width = 12,
       units = "in",
       #height = 40,
       #width = 80,
       #units = "in",
       limitsize = FALSE,
       file = paste0("Plots/gp_tav_pft", ".png"))
#rm(colorcount); rm(heatmap_plot)
```

## tavp_wocp Crosstab

-   Heatmap of 324\*30 dimension matrix.

-   See tav_profit for variable naming convention.

    ```{r}
    # Define the values for each variable
    sprop <- c(0, 0.05, 0.10, 0.15, 0.20, 0.25, 
               0.30, 0.35, 0.40, 0.45, 0.50,
               0.55, 0.60, 0.65, 0.70, 0.75, 
               0.80, 0.85, 0.90, 0.95, 1.00)
    array <- c("Fixed", "Tracking") # Solar Array
    height <- c(4.6, 6.4, 8.2) # Panel height
    yldvar <- c(0.10, 0.20, 0.30, 0.40, 0.50, 0.60, 0.70, 0.80, 0.90, 1.00,
            1.10, 1.20, 1.30, 1.40, 1.50, 1.60, 1.70, 1.80, 1.90, 2.00)
    al_regs <- c("Northern", "Central", "Black Belt", "Southern") # Regions of AL
    price <- c(17, 18, 19, 20, 21, 22, 23) # Crop Price
    elcprc <- c(0.02, 0.03, 0.04) # Electricity Price

    # Define the required columns
    required_columns <- c("sprop", "array", "height", 
                      "al_regs", "yldvar", "price", "elcprc")

    # Check if the columns exist in tav_profit
    missing_columns <- setdiff(required_columns, 
                           names(tav_profit))
    if (length(missing_columns) > 0) {
      stop("Missing columns in tavp_wocp: ",
           paste(missing_columns, collapse = ", "))
    }

    # Generate column names using reversed order of expand.grid
    col_names <- apply(expand.grid(height, array, sprop), 1,
                       function(x) paste0(x[3], x[2], x[1]))

    # Generate row names using reversed order of expand.grid
    row_names <- apply(expand.grid(elcprc, 
                                   price,
                                   yldvar, 
                                   al_regs), 1, 
                       function(x) paste0(x, collapse = ""))

    # Create an empty matrix to store the results
    result_matrix <- matrix(NA, nrow = length(row_names), 
                            ncol = length(col_names))
    colnames(result_matrix) <- col_names
    rownames(result_matrix) <- row_names

    # Create a data frame with 
    # all combinations of parameters in reversed order
    param_combinations <- expand.grid(elcprc = elcprc, 
                                      price = price, 
                                      yldvar = yldvar, 
                                      al_regs = al_regs,
                                      height = height, 
                                      array = array, 
                                      sprop = sprop)

    # Merge with tav_profit to get tav_profit values for each combination
    merged_data <- merge(param_combinations, 
                         tav_profit, 
                         by = required_columns,
                         all.x = TRUE)

    # Reshape merged_data to fill result_matrix with 
    # reversed column and row names
    merged_data$col_name <- apply(
      merged_data[, c("sprop", "array", "height")], 1,
      function(x) paste0(x[1], x[2], x[3]))

    merged_data$row_name <- apply(
      merged_data[, c("al_regs", "yldvar", "price", "elcprc")], 1,
      function(x) paste0(x[4],
                         x[3],
                         x[2],
                         x[1]))

    # Fill the matrix with tav_profit values
    for (i in seq_len(nrow(result_matrix))) {
      row_condition <- rownames(result_matrix)[i]
      row_data <- merged_data[
        merged_data$row_name == row_condition, ]
      if (nrow(row_data) > 0) {
        result_matrix[i, 
                      match(row_data$col_name, 
                            colnames(result_matrix))] <- round(
                              row_data$tavp_wocp, 2)
      }
    }
    ct_tavp_wocp <- as.data.frame(result_matrix) # Table in Excel.
    rm(result_matrix)
    ```

```{r}
dim(ct_tavp_wocp)
write.csv(as.data.frame(ct_tavp_wocp),
          row.names = TRUE,
          file = "Results/ct_tavp_wocp.csv")
```

## tavp_wocp Heatmap

-   Heatmap of 324\*30 dimension matrix.

```{r}
colorcount = length(unique(as.vector(as.matrix(ct_tavp_wocp[-1]))))
colorcount
heatmap_plot <- pheatmap(t(ct_tavp_wocp),
                         #clustering_distance_rows = "correlation",
                         clustering_distance_rows = "euclidean",
                         clustering_distance_cols = "euclidean",
                         clustering_method = "complete",
                         color = colorRampPalette(c("red", 
                                                    "yellow", 
                                                    "green"))(colorcount),
                         #cutree_rows = 5,
                         #cutree_cols = 4,
                         cutree_rows = 5,
                         cutree_cols = 4,
                         cluster_rows = FALSE,
                         cluster_cols = FALSE,
                         show_rownames = FALSE,
                         show_colnames = FALSE,
                         display_numbers = FALSE,
                         number_format = "%.2f",
                         #cellheight = 3,
                         #cellwidth = 3
                         )
```

```{r, eval=TRUE, echo=TRUE}
ggsave(heatmap_plot,
       height = 8,
       width = 12,
       units = "in",
       file = paste0("Plots/gp_tavp_wocp", ".png"))
rm(heatmap_plot); rm(colorcount)
```

## tav_be_yld Crosstab

```{r}
# Define the values for each variable
sprop <- c(0, 0.05, 0.10, 0.15, 0.20, 0.25, 0.30, 0.35, 0.40, 0.45, 0.50,
           0.55, 0.60, 0.65, 0.70, 0.75, 0.80, 0.85, 0.90, 0.95, 1.00)
array <- c("Fixed", "Tracking") # Solar Array
height <- c(4.6, 6.4, 8.2) # Panel height
al_regs <- c("Northern", "Central", "Black Belt", "Southern")
price <- c(17, 18, 19, 20, 21, 22, 23) # Crop Price
elcprc <- c(0.02, 0.03, 0.04) # Electricity Price
yldvar <- c(0.10, 0.20, 0.30, 0.40, 0.50, 0.60, 0.70, 0.80, 0.90, 1.00,
            1.10, 1.20, 1.30, 1.40, 1.50, 1.60, 1.70, 1.80, 1.90, 2.00)

# Define the required columns
required_columns <- c("sprop", "array", "height", 
                      "al_regs", "price", "elcprc")

# Check if the columns exist in tav_profit
missing_columns <- setdiff(required_columns, 
                           names(tav_be_yld))
if (length(missing_columns) > 0) {
  stop("Missing columns in tavp_be_yld: ",
       paste(missing_columns, collapse = ", "))
}

# Generate column names using reversed order of expand.grid
col_names <- apply(expand.grid(height, array, sprop), 1,
                   function(x) paste0(x[3], x[2], x[1]))

# Generate row names using reversed order of expand.grid
row_names <- apply(expand.grid(elcprc, 
                               price,
                               #yldvar, 
                               al_regs), 1, 
                   function(x) paste0(x, collapse = ""))

# Create an empty matrix to store the results
result_matrix <- matrix(NA, nrow = length(row_names), 
                        ncol = length(col_names))
colnames(result_matrix) <- col_names
rownames(result_matrix) <- row_names

# Create a data frame with 
# all combinations of parameters in reversed order
param_combinations <- expand.grid(elcprc = elcprc, 
                                  price = price, 
                                  #yldvar = yldvar, 
                                  al_regs = al_regs,
                                  height = height, 
                                  array = array, 
                                  sprop = sprop)

# Merge with tav_be_yld to get tav_be_yld values for each combination
merged_data <- merge(param_combinations, 
                     tav_be_yld, 
                     by = required_columns,
                     all.x = TRUE)

# Reshape merged_data to fill result_matrix with 
# reversed column and row names
merged_data$col_name <- apply(
  merged_data[, c("sprop", "array", "height")], 1,
  function(x) paste0(x[1], x[2], x[3]))

merged_data$row_name <- apply(
  merged_data[, c("al_regs", "price", "elcprc")], 1,
  function(x) paste0(x[3],
                     x[2],
                     x[1]))

# Fill the matrix with tav_profit values
for (i in seq_len(nrow(result_matrix))) {
  row_condition <- rownames(result_matrix)[i]
  row_data <- merged_data[
    merged_data$row_name == row_condition, ]
  if (nrow(row_data) > 0) {
    result_matrix[i, 
                  match(row_data$col_name, 
                        colnames(result_matrix))] <- round(
                          row_data$yield, 2)
  }
}
ct_tavp_be_yld <- as.data.frame(result_matrix) # Table in Excel.
write.csv(as.data.frame(ct_tavp_be_yld),
          row.names = TRUE,
          file = "Results/ct_tavp_be_yld.csv")
dim(ct_tavp_be_yld)
rm(result_matrix)
```

## tav_be_yld Heatmap

```{r}
uniquevalue = unique(as.vector(as.matrix(ct_tavp_be_yld[-1])))
uniquevalue
colorcount = length(unique(as.vector(as.matrix(ct_tavp_be_yld[-1]))))
colorcount
heatmap_plot <- pheatmap((ct_tavp_be_yld),
                         #clustering_distance_rows = "correlation",
                         clustering_distance_rows = "euclidean",
                         clustering_distance_cols = "euclidean",
                         clustering_method = "complete",
                         angle_col = 90,
                         na_col = "white",
                         color = colorRampPalette(c("green", 
                                                    "yellow", 
                                                    "red"))(colorcount),
                         cellheight = 5,
                         cellwidth = 5,
                         fontsize = 12,
                         fontsize_row = 4,
                         fontsize_col = 4,
                         cluster_rows = FALSE,
                         cluster_cols = FALSE,
                         show_rownames = TRUE,
                         show_colnames = TRUE,
                         display_numbers = FALSE,
                         number_format = "%.2f",
                         legend_breaks = uniquevalue
                         )
```

```{r}
ggsave(heatmap_plot,
       height = 8,
       width = 12,
       units = "in",
       file = paste0("Plots/gp_tav_be_yld", ".png"))
rm(heatmap_plot); rm(colorcount); rm(uniquevalue)
```

## Plotting Tomato Profits by Panels

You can see plot breakdown based on yield variation, crop price, and electricity price. You can see variation for all solar proportion in one facet of the chart. Each facet of the chart contain av profit three heights of solar panels, four regions of AL, two array types.

```{r, eval=TRUE, warning=TRUE, error=TRUE, cache=TRUE}
combinations <- expand.grid(
  yldvar = c(0.1, 0.3, 0.5, 0.7, 1, 1.20, 1.5, 1.80, 2), # Yield variation
  price = c(17, 20, 23), # Tomato price
  elcprc = c(0.03, 0.04, 0.05) #Electricity price
)

# Iterate over the combinations and create the plots
for (combo in seq_len(nrow(combinations))) {
  filtered_data <- tav_profit %>%
    filter(
      yldvar == combinations$yldvar[combo],
      price == combinations$price[combo],
      elcprc == combinations$elcprc[combo]
    )
  # If by panel, put panels below in color and group.
  tav_sp_plot <- ggplot(data = filtered_data,
                        mapping = aes(x = al_regs,
                                      y = tav_profit,
                                      color = factor(panels),
                                      group = factor(panels))) +
    geom_line() +
    geom_point() +
    facet_grid(height ~ array,
               labeller = as_labeller(
                 c(
                   "4.6" = "4.6 ft. Height",
                   "6.4" = "6.4 ft. Height",
                   "8.2" = "8.2 ft. Height",
                   Tracking = "Single Axis Rotation", 
                   Fixed = "Fixed Open Rack"
                   ))) +
    guides(color = guide_legend(ncol = 1, 
                                reverse = TRUE)) +
    scale_x_discrete(limits = c("Northern", "Central",
                                "Black Belt", "Southern"), 
                     labels = c("North", "Center", 
                                "B Belt", "South")) +
    guides(color = guide_legend(ncol = 2, 
                                reverse = TRUE)) +
    labs(x = "Regions of Alabama",
         y = "Profit ($) from Tomato Agrivoltaic System",
         color = "Number of Solar \n Panels per Acre",
         title = (list(combinations[combo,]))
         ) +
    theme(strip.background = element_blank())
  
  # Add horizontal line at y = 0 if y has both positive and negative values
  if (min(filtered_data$tav_profit) < 0 &
      max(filtered_data$tav_profit) > 0) {
    tav_sp_plot <- tav_sp_plot + 
      geom_hline(yintercept = 0, 
                 linewidth = 0.30, 
                 linetype = "dashed", 
                 color = "black")
  }
  print(combinations[combo,])
  print(tav_sp_plot)
  ggsave(file = paste0("Plots/tav_sp_", combo, ".png"))
  #break
}
```

## Plotting Tomato Profits by Yields

You can see plot breakdown based on solar proportion, crop price, and electricity price. You can see variation for all crop yield variation in one facet of the chart. Each facet of the chart contain av profit three heights of solar panels, four regions of AL, two array types.

```{r, eval=TRUE, warning=TRUE, error=TRUE, cache=TRUE}
combinations <- expand.grid(
  sprop = c(0, 0.25, 0.50, 0.75, 1.00), # Solar proportion
  price = c(17, 20, 23), # Tomato price
  elcprc = c(0.03, 0.04, 0.05) #Electricity price
)

# Iterate over the combinations and create the plots
for (combo in seq_len(nrow(combinations))) {
  filtered_data <- tav_profit %>%
    filter(
      sprop == combinations$sprop[combo],
      price == combinations$price[combo],
      elcprc == combinations$elcprc[combo]
    )
  # If by yield, put yield below in color and group.
  tav_yv_plot <- ggplot(data = filtered_data,
                        mapping = aes(x = al_regs,
                                      y = tav_profit,
                                      color = factor(yield),
                                      group = factor(yield))) +
    geom_line() +
    geom_point() +
    facet_grid(height ~ array,
               labeller = as_labeller(
                 c(
                   "4.6" = "4.6 ft. Height",
                   "6.4" = "6.4 ft. Height",
                   "8.2" = "8.2 ft. Height",
                   Tracking = "Single Axis Rotation", 
                   Fixed = "Fixed Open Rack"
                   ))) +
    guides(color = guide_legend(ncol = 1, 
                                reverse = TRUE)) +
    scale_x_discrete(limits = c("Northern", "Central",
                                "Black Belt", "Southern"), 
                     labels = c("North", "Center", 
                                "B Belt", "South")) +
    guides(color = guide_legend(ncol = 2, 
                                reverse = TRUE)) +
    labs(x = "Regions of Alabama",
         y = "Profit ($) from Tomato Agrivoltaic System",
         color = "Tomato Yield \n (25 Lb Buckets)",
         title = (list(combinations[combo,]))
         ) +
    theme(strip.background = element_blank())
  # Add horizontal line at y = 0 if y has both positive and negative values
  if (min(filtered_data$tav_profit) < 0 &
      max(filtered_data$tav_profit) > 0) {
    tav_yv_plot <- tav_yv_plot + 
      geom_hline(yintercept = 0, 
                 linewidth = 0.30, 
                 linetype = "dashed", 
                 color = "black")
  }
  print(combinations[combo,])
  print(tav_yv_plot)
  ggsave(file = paste0("Plots/tav_yv_", combo, ".png"))
  #break
}
```

# Strawberry AV Results

## sbav_profit Crosstab (648\*15)

-   Row naming: Electricity Price_Crop Price_Solar Proportion_Alabama Regions

-   Column naming: Solar Proportion_Array Types_Solar Panel Height.

-   Solar Proportion can be converted to total number of panels.

-   Only selected values from each variables are extracted for tabulation purpose.

-   Values displayed in the table are profit from Strawberry AV system.

```{r, warning=TRUE, error=TRUE}
# Define the values for each variable
sprop <- c(0, 0.05, 0.10, 0.15, 0.20, 0.25, 0.30, 0.35, 0.40, 0.45, 0.50,
           0.55, 0.60, 0.65, 0.70, 0.75, 0.80, 0.85, 0.90, 0.95, 1.00) # Land Proportion
array <- c("Fixed", "Tracking")
height <- c(4.6, 6.4, 8.2)
yldvar <- c(0.10, 0.20, 0.30, 0.40, 0.50, 0.60, 0.70, 0.80, 0.90, 1.00, 
            1.10, 1.20, 1.30, 1.40, 1.50, 1.60, 1.70, 1.80, 1.90, 2.00)
al_regs <- c("Northern", "Central", "Black Belt", "Southern")
price <- c(3, 4, 5, 6, 7, 8, 9)
elcprc <- c(0.02, 0.03, 0.04)

# Define the required columns
required_columns <- c("sprop", "array", "height", "al_regs", 
                      "yldvar", "price", "elcprc")

# Check if the columns exist in tav_profit
missing_columns <- setdiff(required_columns, 
                           names(sbav_profit))
if (length(missing_columns) > 0) {
  stop("Missing columns in sbav_profit: ", 
       paste(missing_columns,
             collapse = ", "))
  }

# Generate column names using expand.grid without array
col_names <- apply(expand.grid(height, sprop), 
                   1, function(x) 
                     paste0(x[2], "%_",
                            x[1]))

# Generate row names using expand.grid with array included
row_names <- apply(expand.grid(elcprc, price, yldvar, al_regs, array),
                   1, function(x) paste0(x[4], "_", 
                                         x[3], "_", 
                                         x[2], "_",
                                         x[1], "_", 
                                         x[5]))

# Create an empty matrix to store the results
result_matrix <- matrix(NA, 
                        nrow = length(row_names), 
                        ncol = length(col_names))
colnames(result_matrix) <- col_names
rownames(result_matrix) <- row_names

# Create a data frame with all combinations of parameters
param_combinations <- expand.grid(elcprc = elcprc, 
                                  price = price, 
                                  yldvar = yldvar, 
                                  al_regs = al_regs,
                                  array = array, 
                                  height = height, 
                                  sprop = sprop)

# Merge with tav_profit to get av_profit values for each combination
merged_data <- merge(param_combinations, 
                     sbav_profit, 
                     by = c("sprop", "array", "height",
                            "al_regs", "yldvar", "price",
                            "elcprc"),
                     all.x = TRUE)

# Reshape merged_data to fill result_matrix with adjusted column and row names
merged_data$col_name <- apply(merged_data[, c("sprop", "height")],
                              1, function(x) paste0(x[1], "%_",
                                                    x[2]))
merged_data$row_name <- apply(merged_data[, c("al_regs", "yldvar", "price",
                                              "elcprc", "array")], 1,
                              function(x) paste0(x[1], "_",
                                                 x[2], "_",
                                                 x[3], "_",
                                                 x[4], "_",
                                                 x[5]))

# Fill the matrix with av_profit values
for (i in seq_len(nrow(result_matrix))) {
  row_condition <- rownames(result_matrix)[i]
  row_data <- merged_data[merged_data$row_name == row_condition, ]
  if (nrow(row_data) > 0) {
    result_matrix[i, match(
      row_data$col_name,
      colnames(result_matrix))] <- round(row_data$sbav_profit, 2)
  }
}

# Display the result matrix
ct_sbav_pft64815 <- as.data.frame(result_matrix) # Table in Excel.
rm(result_matrix)
```

## sbav_profit Crosstab (324\*30)

```{r}
# Define the values for each variable
sprop <- c(0, 0.05, 0.10, 0.15, 0.20, 0.25, 0.30, 0.35, 0.40, 0.45, 0.50,
           0.55, 0.60, 0.65, 0.70, 0.75, 0.80, 0.85, 0.90, 0.95, 1.00) # Land Proportion
array <- c("Fixed", "Tracking")
height <- c(4.6, 6.4, 8.2)
yldvar <- c(0.10, 0.20, 0.30, 0.40, 0.50, 0.60, 0.70, 0.80, 0.90, 1.00, 
            1.10, 1.20, 1.30, 1.40, 1.50, 1.60, 1.70, 1.80, 1.90, 2.00)
al_regs <- c("Northern", "Central", "Black Belt", "Southern")
price <- c(3, 4, 5, 6, 7, 8, 9)
elcprc <- c(0.02, 0.03, 0.04)

# Define the required columns
required_columns <- c("sprop", "array", "height", 
                      "al_regs", "yldvar", "price", "elcprc")

# Check if the columns exist in sbav_profit
missing_columns <- setdiff(required_columns, 
                           names(sbav_profit))
if (length(missing_columns) > 0) {
  stop("Missing columns in sbav_profit: ",
       paste(missing_columns, collapse = ", "))
}

# Generate column names using reversed order of expand.grid
col_names <- apply(expand.grid(height, array, sprop), 1,
                   function(x) paste0(x[3], x[2], x[1]))

# Generate row names using reversed order of expand.grid
row_names <- apply(expand.grid(elcprc, 
                               price,
                               yldvar, 
                               al_regs), 1, 
                   function(x) paste0(x, collapse = ""))

# Create an empty matrix to store the results
result_matrix <- matrix(NA, 
                        nrow = length(row_names), 
                        ncol = length(col_names))
colnames(result_matrix) <- col_names
rownames(result_matrix) <- row_names

# Create a data frame with
# all combinations of parameters in reversed order
param_combinations <- expand.grid(elcprc = elcprc, 
                                  price = price, 
                                  yldvar = yldvar, 
                                  al_regs = al_regs,
                                  height = height, 
                                  array = array, 
                                  sprop = sprop)

# Merge with tav_profit to get sbav_profit values for each combination
merged_data <- merge(param_combinations, 
                     sbav_profit, 
                     by = required_columns,
                     all.x = TRUE)

# Reshape merged_data to fill result_matrix with 
# reversed column and row names
merged_data$col_name <- apply(
  merged_data[, c("sprop", "array", "height")], 1,
  function(x) paste0(x[1],
                     x[2], 
                     x[3]))

merged_data$row_name <- apply(
  merged_data[, c("al_regs", "yldvar", "price", "elcprc")], 1,
  function(x) paste0(x[4],
                     x[3],
                     x[2],
                     x[1]))

# Fill the matrix with sbav_profit values
for (i in seq_len(nrow(result_matrix))) {
  row_condition <- rownames(result_matrix)[i]
  row_data <- merged_data[
    merged_data$row_name == row_condition, ]
  if (nrow(row_data) > 0) {
    result_matrix[i, 
                  match(row_data$col_name, 
                        colnames(result_matrix))] <- round(
                          row_data$sbav_profit, 2)
  }
}
ct_sbav_pft <- as.data.frame(result_matrix) #Table in Excel.
# Display the result matrix
ct_sbav_pft <- as.data.frame(result_matrix) # Table in Excel.
rm(result_matrix); rm(sprop); rm(array); rm(height); 
rm(elcprc); rm(price); rm(yldvar); rm(al_regs)
```

```{r}
write.csv(as.data.frame(ct_sbav_pft),
          row.names = TRUE,
          #col.names = TRUE,
          file = "Results/ct_sbav_pft.csv")
dim(ct_sbav_pft)
```

## sbav_profit Heatmap

-   Heatmap of 648\*15 dimension matrix.

```{r, eval=TRUE}
colorcount = length(unique(as.vector(as.matrix(ct_sbav_pft[-1]))))
colorcount
heatmap_plot <- pheatmap(t(ct_sbav_pft),
                         #clustering_distance_rows = "correlation",
                         clustering_distance_rows = "euclidean",
                         clustering_distance_cols = "euclidean",
                         clustering_method = "complete",
                         color = colorRampPalette(c("red", 
                                                    "yellow", 
                                                    "green"))(colorcount),
                         cluster_rows = FALSE,
                         cluster_cols = FALSE,
                         show_rownames = FALSE,
                         show_colnames = FALSE,
                         display_numbers = FALSE,
                         number_format = "%.2f",
                         #cellheight = 3,
                         #cellwidth = 3
                         )
```

```{r, eval=TRUE, echo=TRUE}
ggsave(heatmap_plot,
       height = 8,
       width = 12,
       units = "in",
       file = paste0("Plots/gp_sbav_pft", ".png"))
rm(heatmap_plot)
rm(colorcount)
```

## sbavp_wocp Crosstab

-   Row naming: Electricity Price_Crop Price_Solar Proportion_Alabama Regions

-   Column naming: Solar Proportion_Array Types_Solar Panel Height.

-   Solar Proportion can be converted to total number of panels.

-   Only selected values from each variables are extracted for tabulation purpose.

-   Values displayed in the table are profit from Strawberry AV system.

```{r, warning=TRUE, error=TRUE}
# Define the values for each variable
sprop <- c(0, 0.05, 0.10, 0.15, 0.20, 0.25, 0.30, 0.35, 0.40, 0.45, 0.50,
           0.55, 0.60, 0.65, 0.70, 0.75, 0.80, 0.85, 0.90, 0.95, 1.00) # Land Proportion
array <- c("Fixed", "Tracking")
height <- c(4.6, 6.4, 8.2)
yldvar <- c(0.10, 0.20, 0.30, 0.40, 0.50, 0.60, 0.70, 0.80, 0.90, 1.00, 
            1.10, 1.20, 1.30, 1.40, 1.50, 1.60, 1.70, 1.80, 1.90, 2.00)
al_regs <- c("Northern", "Central", "Black Belt", "Southern")
price <- c(3, 4, 5, 6, 7, 8, 9)
elcprc <- c(0.02, 0.03, 0.04)

# Define the required columns
required_columns <- c("sprop", "array", "height", 
                      "al_regs", "yldvar", "price", "elcprc")

# Check if the columns exist in sbav_profit
missing_columns <- setdiff(required_columns, 
                           names(sbav_profit))
if (length(missing_columns) > 0) {
  stop("Missing columns in sbav_profit: ",
       paste(missing_columns, collapse = ", "))
}

# Generate column names using reversed order of expand.grid
col_names <- apply(expand.grid(height, array, sprop), 1,
                   function(x) paste0(x[3], x[2], x[1]))

# Generate row names using reversed order of expand.grid
row_names <- apply(expand.grid(elcprc, 
                               price,
                               yldvar, 
                               al_regs), 1, 
                   function(x) paste0(x, collapse = ""))

# Create an empty matrix to store the results
result_matrix <- matrix(NA, nrow = length(row_names), 
                        ncol = length(col_names))
colnames(result_matrix) <- col_names
rownames(result_matrix) <- row_names

# Create a data frame with
# all combinations of parameters in reversed order
param_combinations <- expand.grid(elcprc = elcprc, 
                                  price = price, 
                                  yldvar = yldvar, 
                                  al_regs = al_regs,
                                  height = height, 
                                  array = array, 
                                  sprop = sprop)

# Merge with tav_profit to get sbav_profit values for each combination
merged_data <- merge(param_combinations, 
                     sbav_profit, 
                     by = required_columns,
                     all.x = TRUE)

# Reshape merged_data to fill result_matrix with 
# reversed column and row names
merged_data$col_name <- apply(
  merged_data[, c("sprop", "array", "height")], 1,
  function(x) paste0(x[1],
                     x[2], 
                     x[3]))

merged_data$row_name <- apply(
  merged_data[, c("al_regs", "yldvar", "price", "elcprc")], 1,
  function(x) paste0(x[4],
                     x[3],
                     x[2],
                     x[1]))

# Fill the matrix with sbav_profit values
for (i in seq_len(nrow(result_matrix))) {
  row_condition <- rownames(result_matrix)[i]
  row_data <- merged_data[
    merged_data$row_name == row_condition, ]
  if (nrow(row_data) > 0) {
    result_matrix[i, 
                  match(row_data$col_name, 
                        colnames(result_matrix))] <- round(
                          row_data$sbavp_wocp, 2)
  }
}
ct_sbavp_wocp <- as.data.frame(result_matrix) #Table in Excel.
rm(result_matrix)
```

```{r}
write.csv(as.data.frame(ct_sbavp_wocp),
          row.names = TRUE,
          #col.names = TRUE,
          file = "Results/ct_sbavp_wocp.csv")
dim(ct_sbavp_wocp)
```

## sbavp_wocp Heatmap

-   Heatmap of 324\*30 dimension matrix.

```{r}
colorcount = length(unique(as.vector(as.matrix(ct_sbavp_wocp[-1]))))
colorcount
heatmap_plot <- pheatmap(t(ct_sbavp_wocp),
                         #clustering_distance_rows = "correlation",
                         clustering_distance_rows = "euclidean",
                         clustering_distance_cols = "euclidean",
                         clustering_method = "complete",
                         color = colorRampPalette(c("red", 
                                                    "yellow", 
                                                    "green"))(colorcount),
                         #cutree_rows = 5,
                         #cutree_cols = 4,
                         cluster_rows = FALSE,
                         cluster_cols = FALSE,
                         show_rownames = FALSE,
                         show_colnames = FALSE,
                         display_numbers = FALSE,
                         number_format = "%.2f",
                         #cellheight = 3,
                         #cellwidth = 3
                         )
```

```{r, eval=TRUE, echo=TRUE}
ggsave(heatmap_plot,
       height = 8,
       width = 12,
       units = "in",
       file = paste0("Plots/gp_sbavp_wocp", ".png"))
rm(heatmap_plot)
rm(colorcount)
```

## sbav_be_yld Crosstab

```{r}
sprop <- c(0, 0.05, 0.10, 0.15, 0.20, 0.25, 0.30, 0.35, 0.40, 0.45, 0.50,
           0.55, 0.60, 0.65, 0.70, 0.75, 0.80, 0.85, 0.90, 0.95, 1.00)
array <- c("Fixed", "Tracking") # Solar Array
height <- c(4.6, 6.4, 8.2) # Panel height
al_regs <- c("Northern", "Central", "Black Belt", "Southern")
price <- c(3, 4, 5, 6, 7, 8, 9)
elcprc <- c(0.02, 0.03, 0.04) # Electricity Price
yldvar <- c(0.10, 0.20, 0.30, 0.40, 0.50, 0.60, 0.70, 0.80, 0.90, 1.00,
            1.10, 1.20, 1.30, 1.40, 1.50, 1.60, 1.70, 1.80, 1.90, 2.00)

# Define the required columns
required_columns <- c("sprop", "array", "height", 
                      "al_regs", "price", "elcprc")

# Check if the columns exist in sbav_profit
missing_columns <- setdiff(required_columns, 
                           names(sbav_be_yld))
if (length(missing_columns) > 0) {
  stop("Missing columns in sbav_be_yld: ",
       paste(missing_columns, collapse = ", "))
}

# Generate column names using reversed order of expand.grid
col_names <- apply(expand.grid(height, array, sprop), 1,
                   function(x) paste0(x[3], x[2], x[1]))

# Generate row names using reversed order of expand.grid
row_names <- apply(expand.grid(elcprc, 
                               price,
                               al_regs), 1, 
                   function(x) paste0(x, collapse = ""))

# Create an empty matrix to store the results
result_matrix <- matrix(NA, nrow = length(row_names), 
                        ncol = length(col_names))
colnames(result_matrix) <- col_names
rownames(result_matrix) <- row_names

# Create a data frame with 
# all combinations of parameters in reversed order
param_combinations <- expand.grid(elcprc = elcprc, 
                                  price = price, 
                                  al_regs = al_regs,
                                  height = height, 
                                  array = array, 
                                  sprop = sprop)

# Merge with tavp_be_yld to get tavp_be_yld values for each combination
merged_data <- merge(param_combinations, 
                     sbav_be_yld, 
                     by = required_columns,
                     all.x = TRUE)

# Reshape merged_data to fill result_matrix with 
# reversed column and row names
merged_data$col_name <- apply(
  merged_data[, c("sprop", "array", "height")], 1,
  function(x) paste0(x[1], x[2], x[3]))

merged_data$row_name <- apply(
  merged_data[, c("al_regs", "price", "elcprc")], 1,
  function(x) paste0(x[3],
                     x[2],
                     x[1]))

# Fill the matrix with sbav_profit values
for (i in seq_len(nrow(result_matrix))) {
  row_condition <- rownames(result_matrix)[i]
  row_data <- merged_data[
    merged_data$row_name == row_condition, ]
  if (nrow(row_data) > 0) {
    result_matrix[i, 
                  match(row_data$col_name, 
                        colnames(result_matrix))] <- round(
                          row_data$yield, 2)
  }
}
ct_sbav_be_yld <- as.data.frame(result_matrix) # Table in Excel.
write.csv(as.data.frame(ct_sbav_be_yld),
          row.names = TRUE,
          file = "Results/ct_sbav_be_yld.csv")
dim(ct_sbav_be_yld)
```

## sbav_be_yld Heatmap

```{r}
uniquevalue <- unique(as.vector(as.matrix(ct_sbav_be_yld[-1])))
uniquevalue
colorcount <- length(unique(as.vector(as.matrix(ct_sbav_be_yld[-1]))))
colorcount
heatmap_plot <- pheatmap((ct_sbav_be_yld),
                         #clustering_distance_rows = "correlation",
                         clustering_distance_rows = "euclidean",
                         clustering_distance_cols = "euclidean",
                         clustering_method = "complete",
                         angle_col = 90,
                         na_col = "white",
                         color = colorRampPalette(c("green", 
                                                    "yellow", 
                                                    "red"))(colorcount),
                         cellheight = 5,
                         cellwidth = 5,
                         fontsize = 12,
                         fontsize_row = 4,
                         fontsize_col = 4,
                         cluster_rows = FALSE,
                         cluster_cols = FALSE,
                         show_rownames = TRUE,
                         show_colnames = TRUE,
                         display_numbers = FALSE,
                         number_format = "%.2f",
                         legend_breaks = uniquevalue,
                         legend_labels = c(uniquevalue)
                         )
```

```{r}
ggsave(heatmap_plot,
       height = 8,
       width = 12,
       units = "in",
       file = paste0("Plots/gp_sbav_be_yld", ".png"))
rm(heatmap_plot); rm(colorcount); rm(uniquevalue)
```

## Plotting Strawberry Profit by Panels

You can see plot breakdown based on yield variation, crop price, and electricity price. You can see variation for all solar proportion in one facet of the chart. Each facet of the chart contain av profit three heights of solar panels, four regions of AL, two array types.

```{r, echo=TRUE, warning=TRUE, error=TRUE, eval=TRUE, cache=TRUE}
combinations <- expand.grid(
  yldvar = c(0.1, 0.3, 0.5, 0.7, 1, 1.20, 1.5, 1.80, 2), # Yield variation
  price = c(3, 6, 9), # Strawberry price
  elcprc = c(0.03, 0.04, 0.05) # Electricity price
)

# Iterate over the combinations and create the plots
for (combo in seq_len(nrow(combinations))) {
  filtered_data <- sbav_profit %>%
    filter(
      yldvar == combinations$yldvar[combo],
      price == combinations$price[combo],
      elcprc == combinations$elcprc[combo]
    )
  # If by panel, put panels below in color and group.
  sbav_sp_plot <- ggplot(data = filtered_data,
                        mapping = aes(x = al_regs,
                                      y = sbav_profit,
                                      color = factor(panels),
                                      group = factor(panels))) +
    geom_line() +
    geom_point() +
    facet_grid(height ~ array,
               labeller = as_labeller(
                 c(
                   "4.6" = "4.6 ft. Height",
                   "6.4" = "6.4 ft. Height",
                   "8.2" = "8.2 ft. Height",
                   Tracking = "Single Axis Rotation", 
                   Fixed = "Fixed Open Rack"
                   ))) +
    guides(color = guide_legend(ncol = 1, 
                                reverse = TRUE)) +
    scale_x_discrete(limits = c("Northern", "Central",
                                "Black Belt", "Southern"), 
                     labels = c("North", "Center", 
                                "B Belt", "South")) +
    guides(color = guide_legend(ncol = 2, 
                                reverse = TRUE)) +
    labs(x = "Regions of Alabama",
         y = "Profit ($) from Strawberry Agrivoltaic System",
         color = "Number of Solar \n Panels per Acre",
         title = (list(combinations[combo,]))
         ) +
    theme(strip.background = element_blank())
  # Add horizontal line at y = 0 if y has both positive and negative values
  if (min(filtered_data$sbav_profit) < 0 &
      max(filtered_data$sbav_profit) > 0) {
    sbav_sp_plot <- sbav_sp_plot + 
      geom_hline(yintercept = 0, 
                 linewidth = 0.30, 
                 linetype = "dashed", 
                 color = "black")
  }
  print(combinations[combo,])
  print(sbav_sp_plot)
  ggsave(file = paste0("Plots/sbav_sp_", combo, ".png"))
  #break
}
```

## Plotting Strawberry Profit by Yields

You can see plot breakdown based on solar proportion, crop price, and electricity price. You can see variation for all crop yield variation in one facet of the chart. Each facet of the chart contain av profit three heights of solar panels, four regions of AL, two array types.

```{r, eval=TRUE, echo=TRUE, warning=TRUE, error=TRUE, cache=TRUE}
combinations <- expand.grid(
  sprop = c(0, 0.25, 0.50, 0.75, 1.00), # Solar proportion
  price = c(3, 6, 9), # Strawberry price
  elcprc = c(0.03, 0.04, 0.05) #Electricity price
)

# Iterate over the combinations and create the plots
for (combo in seq_len(nrow(combinations))) {
  filtered_data <- sbav_profit %>%
    filter(
      sprop == combinations$sprop[combo],
      price == combinations$price[combo],
      elcprc == combinations$elcprc[combo]
    )
  # If by yield, put yield below in color and group.
  sbav_yv_plot <- ggplot(data = filtered_data,
                        mapping = aes(x = al_regs,
                                      y = sbav_profit,
                                      color = factor(yield),
                                      group = factor(yield))) +
    geom_line() +
    geom_point() +
    facet_grid(height ~ array,
               labeller = as_labeller(
                 c(
                   "4.6" = "4.6 ft. Height",
                   "6.4" = "6.4 ft. Height",
                   "8.2" = "8.2 ft. Height",
                   Tracking = "Single Axis Rotation", 
                   Fixed = "Fixed Open Rack"
                   ))) +
    guides(color = guide_legend(ncol = 1, 
                                reverse = TRUE)) +
    scale_x_discrete(limits = c("Northern", "Central",
                                "Black Belt", "Southern"), 
                     labels = c("North", "Center", 
                                "B Belt", "South")) +
    guides(color = guide_legend(ncol = 2, 
                                reverse = TRUE)) +
    labs(x = "Regions of Alabama",
         y = "Profit ($) from Strawberry Agrivoltaic System",
         color = "Strawberry Yield \n (25 Lb Buckets)",
         title = (list(combinations[combo,]))
         ) +
    theme(strip.background = element_blank())
  # Add horizontal line at y = 0 if y has both positive and negative values
  if (min(filtered_data$sbav_profit) < 0 &
      max(filtered_data$sbav_profit) > 0) {
    sbav_yv_plot <- sbav_yv_plot + 
      geom_hline(yintercept = 0, 
                 linewidth = 0.30, 
                 linetype = "dashed", 
                 color = "black")
  }
  print(combinations[combo,])
  print(sbav_yv_plot)
  ggsave(file = paste0("Plots/sbav_yv_", combo, ".png"))
  #break
}
```

# Squash AV Results

## sqav_profit Crosstab (648\*15)

-   Row naming: Electricity Price_Crop Price_Solar Proportion_Alabama Regions

-   Column naming: Solar Proportion_Array Types_Solar Panel Height.

-   Solar Proportion can be converted to total number of panels.

-   Only selected values from each variables are extracted for tabulation purpose.

-   Values displayed in the table are profit from Squash AV system.

```{r}
# Define the values for each variable
sprop <- c(0, 0.05, 0.10, 0.15, 0.20, 0.25, 0.30, 0.35, 0.40, 0.45, 0.50,
           0.55, 0.60, 0.65, 0.70, 0.75, 0.80, 0.85, 0.90, 0.95, 1.00) # Land Proportion
array <- c("Fixed", "Tracking")
height <- c(4.6, 6.4, 8.2)
yldvar <- c(0.10, 0.20, 0.30, 0.40, 0.50, 0.60, 0.70, 0.80, 0.90, 1.00, 
            1.10, 1.20, 1.30, 1.40, 1.50, 1.60, 1.70, 1.80, 1.90, 2.00)
al_regs <- c("Northern", "Central", "Black Belt", "Southern")
price <- c(11, 12, 13, 14, 15, 16, 17)
elcprc <- c(0.02, 0.03, 0.04)

# Define the required columns
required_columns <- c("sprop", "array", "height", "al_regs", 
                      "yldvar", "price", "elcprc")

# Check if the columns exist in tav_profit
missing_columns <- setdiff(required_columns, 
                           names(sqav_profit))
if (length(missing_columns) > 0) {
  stop("Missing columns in sqav_profit: ", 
       paste(missing_columns,
             collapse = ", "))
  }

# Generate column names using expand.grid without array
col_names <- apply(expand.grid(height, sprop), 
                   1, function(x) 
                     paste0(x[2], "%_",
                            x[1]))

# Generate row names using expand.grid with array included
row_names <- apply(expand.grid(elcprc, price, yldvar, al_regs, array),
                   1, function(x) paste0(x[4], "_", 
                                         x[3], "_", 
                                         x[2], "_",
                                         x[1], "_", 
                                         x[5]))

# Create an empty matrix to store the results
result_matrix <- matrix(NA, 
                        nrow = length(row_names), 
                        ncol = length(col_names))
colnames(result_matrix) <- col_names
rownames(result_matrix) <- row_names

# Create a data frame with all combinations of parameters
param_combinations <- expand.grid(elcprc = elcprc, 
                                  price = price, 
                                  yldvar = yldvar, 
                                  al_regs = al_regs,
                                  array = array, 
                                  height = height, 
                                  sprop = sprop)

# Merge with tav_profit to get av_profit values for each combination
merged_data <- merge(param_combinations, 
                     sqav_profit, 
                     by = c("sprop", "array", "height",
                            "al_regs", "yldvar", "price",
                            "elcprc"),
                     all.x = TRUE)

# Reshape merged_data to fill result_matrix with adjusted column and row names
merged_data$col_name <- apply(merged_data[, c("sprop", "height")],
                              1, function(x) paste0(x[1], "%_",
                                                    x[2]))
merged_data$row_name <- apply(merged_data[, c("al_regs", "yldvar", "price",
                                              "elcprc", "array")], 1,
                              function(x) paste0(x[1], "_",
                                                 x[2], "_",
                                                 x[3], "_",
                                                 x[4], "_",
                                                 x[5]))

# Fill the matrix with av_profit values
for (i in seq_len(nrow(result_matrix))) {
  row_condition <- rownames(result_matrix)[i]
  row_data <- merged_data[merged_data$row_name == row_condition, ]
  if (nrow(row_data) > 0) {
    result_matrix[i, match(
      row_data$col_name,
      colnames(result_matrix))] <- round(row_data$sqav_profit, 2)
  }
}

# Display the result matrix
ct_sqav_pft64815 <- as.data.frame(result_matrix) # Table in Excel.
rm(result_matrix)
```

## sqav_profit Crosstab (324\*30)

```{r}
#Shape crosstab.
# Define the values for each variable
sprop <- c(0, 0.05, 0.10, 0.15, 0.20, 0.25, 0.30, 0.35, 0.40, 0.45, 0.50,
           0.55, 0.60, 0.65, 0.70, 0.75, 0.80, 0.85, 0.90, 0.95, 1.00) # Land Proportion
array <- c("Fixed", "Tracking")
height <- c(4.6, 6.4, 8.2)
yldvar <- c(0.10, 0.20, 0.30, 0.40, 0.50, 0.60, 0.70, 0.80, 0.90, 1.00, 
            1.10, 1.20, 1.30, 1.40, 1.50, 1.60, 1.70, 1.80, 1.90, 2.00)
al_regs <- c("Northern", "Central", "Black Belt", "Southern")
price <- c(11, 12, 13, 14, 15, 16, 17)
elcprc <- c(0.02, 0.03, 0.04)

# Define the required columns
required_columns <- c("sprop", "array", "height", 
                      "al_regs", "yldvar", "price", "elcprc")

# Check if the columns exist in sqav_profit
missing_columns <- setdiff(required_columns, 
                           names(sqav_profit))
if (length(missing_columns) > 0) {
  stop("Missing columns in sqav_profit: ",
       paste(missing_columns, collapse = ", "))
}

# Generate column names using reversed order of expand.grid
col_names <- apply(expand.grid(height, array, sprop), 1,
                   function(x) paste0(x[3],
                                      x[2],
                                      x[1]))

# Generate row names using reversed order of expand.grid
row_names <- apply(expand.grid(elcprc, 
                               price,
                               yldvar, 
                               al_regs), 1, 
                   function(x) paste0(x, collapse = ""))

# Create an empty matrix to store the results
result_matrix <- matrix(NA, nrow = length(row_names), 
                        ncol = length(col_names))
colnames(result_matrix) <- col_names
rownames(result_matrix) <- row_names

# Create a data frame with 
# all combinations of parameters in reversed order
param_combinations <- expand.grid(elcprc = elcprc, 
                                  price = price, 
                                  yldvar = yldvar, 
                                  al_regs = al_regs,
                                  height = height, 
                                  array = array, 
                                  sprop = sprop)

# Merge with tav_profit to get sqav_profit values for each combination
merged_data <- merge(param_combinations, 
                     sqav_profit, 
                     by = required_columns,
                     all.x = TRUE)

# Reshape merged_data to fill result_matrix with 
# reversed column and row names
merged_data$col_name <- apply(
  merged_data[, c("sprop", "array", "height")], 1,
  function(x) paste0(x[1],
                     x[2],
                     x[3]))

merged_data$row_name <- apply(
  merged_data[, c("al_regs", "yldvar", "price", "elcprc")], 1,
  function(x) paste0(x[4],
                     x[3],
                     x[2],
                     x[1]))

# Fill the matrix with sqav_profit values
for (i in seq_len(nrow(result_matrix))) {
  row_condition <- rownames(result_matrix)[i]
  row_data <- merged_data[
    merged_data$row_name == row_condition, ]
  if (nrow(row_data) > 0) {
    result_matrix[i, 
                  match(row_data$col_name, 
                        colnames(result_matrix))] <- round(
                          row_data$sqav_profit, 2)
  }
}
ct_sqav_pft <- as.data.frame(result_matrix) # Table in Excel.
rm(result_matrix); rm(sprop); rm(array); rm(height); 
rm(elcprc); rm(price); rm(yldvar); rm(al_regs)
```

```{r}
write.csv(as.data.frame(ct_sqav_pft),
          row.names = TRUE,
          file = "Results/ct_sqav_pft.csv")
dim(ct_sqav_pft)
```

## sqav_profit Heatmap

-   Heatmap of 648\*15 dimension matrix.

```{r, eval=TRUE}
colorcount = length(unique(as.vector(as.matrix(ct_sqav_pft[-1]))))
colorcount
heatmap_plot <- pheatmap(t(ct_sqav_pft),
                         #clustering_distance_rows = "correlation",
                         clustering_distance_rows = "euclidean",
                         clustering_distance_cols = "euclidean",
                         clustering_method = "complete",
                         color = colorRampPalette(c("red", 
                                                    "yellow", 
                                                    "green"))(colorcount),
                         #cutree_rows = 5,
                         #cutree_cols = 4,
                         #cellheight = 3,
                         #cellwidth = 3,
                         cluster_rows = FALSE,
                         cluster_cols = FALSE,
                         show_rownames = FALSE,
                         show_colnames = FALSE,
                         display_numbers = FALSE,
                         number_format = "%.2f")
```

```{r, eval=TRUE, echo=TRUE, eval=TRUE}
ggsave(heatmap_plot,
       height = 8,
       width = 12,
       units = "in",
       file = paste0("Plots/gp_sqav_pft", ".png"))
rm(heatmap_plot)
rm(colorcount)
```

## sqavp_wocp Crosstab

-   Profit at 100% crop at their respective price is subtracted from tav_profit.

-   tavp_wocp = tav_profit - profit from 100% crop at their respective prices. This variable gives an idea where av profit stands in relation to crop profit. It helps to identify relative profitability of agrivoltaic system compared to crop only.

```{r}
# Define the values for each variable
sprop <- c(0, 0.05, 0.10, 0.15, 0.20, 0.25, 0.30, 0.35, 0.40, 0.45, 0.50,
           0.55, 0.60, 0.65, 0.70, 0.75, 0.80, 0.85, 0.90, 0.95, 1.00) # Land Proportion
array <- c("Fixed", "Tracking")
height <- c(4.6, 6.4, 8.2)
yldvar <- c(0.10, 0.20, 0.30, 0.40, 0.50, 0.60, 0.70, 0.80, 0.90, 1.00, 
            1.10, 1.20, 1.30, 1.40, 1.50, 1.60, 1.70, 1.80, 1.90, 2.00)
al_regs <- c("Northern", "Central", "Black Belt", "Southern")
price <- c(11, 12, 13, 14, 15, 16, 17)
elcprc <- c(0.02, 0.03, 0.04)

# Define the required columns
required_columns <- c("sprop", "array", "height", 
                      "al_regs", "yldvar", "price", "elcprc")

# Check if the columns exist in sqav_profit
missing_columns <- setdiff(required_columns, 
                           names(sqav_profit))
if (length(missing_columns) > 0) {
  stop("Missing columns in sqav_profit: ",
       paste(missing_columns, collapse = ", "))
}

# Generate column names using reversed order of expand.grid
col_names <- apply(expand.grid(height, array, sprop), 1,
                   function(x) paste0(x[3],
                                      x[2],
                                      x[1]))

# Generate row names using reversed order of expand.grid
row_names <- apply(expand.grid(elcprc, 
                               price,
                               yldvar, 
                               al_regs), 1, 
                   function(x) paste0(x, collapse = ""))

# Create an empty matrix to store the results
result_matrix <- matrix(NA, nrow = length(row_names), 
                        ncol = length(col_names))
colnames(result_matrix) <- col_names
rownames(result_matrix) <- row_names

# Create a data frame with 
# all combinations of parameters in reversed order
param_combinations <- expand.grid(elcprc = elcprc, 
                                  price = price, 
                                  yldvar = yldvar, 
                                  al_regs = al_regs,
                                  height = height, 
                                  array = array, 
                                  sprop = sprop)

# Merge with tav_profit to get sqav_profit values for each combination
merged_data <- merge(param_combinations, 
                     sqav_profit, 
                     by = required_columns,
                     all.x = TRUE)

# Reshape merged_data to fill result_matrix with 
# reversed column and row names
merged_data$col_name <- apply(
  merged_data[, c("sprop", "array", "height")], 1,
  function(x) paste0(x[1],
                     x[2],
                     x[3]))

merged_data$row_name <- apply(
  merged_data[, c("al_regs", "yldvar", "price", "elcprc")], 1,
  function(x) paste0(x[4],
                     x[3],
                     x[2],
                     x[1]))

# Fill the matrix with sqav_profit values
for (i in seq_len(nrow(result_matrix))) {
  row_condition <- rownames(result_matrix)[i]
  row_data <- merged_data[
    merged_data$row_name == row_condition, ]
  if (nrow(row_data) > 0) {
    result_matrix[i, 
                  match(row_data$col_name, 
                        colnames(result_matrix))] <- round(
                          row_data$sqavp_wocp, 2)
  }
}
ct_sqavp_wocp <- as.data.frame(result_matrix) #Table in Excel.
rm(result_matrix)
```

```{r}
write.csv(as.data.frame(ct_sqavp_wocp),
          row.names = TRUE,
          file = "Results/ct_sqavp_wocp.csv")
dim(ct_sqavp_wocp)
```

## sqav_wocp Heatmap

-   Heatmap of 324\*30 dimension matrix.

```{r}
colorcount = length(unique(as.vector(as.matrix(ct_sqavp_wocp[-1]))))
colorcount
heatmap_plot <- pheatmap(t(ct_sqavp_wocp),
                         #clustering_distance_rows = "correlation",
                         clustering_distance_rows = "euclidean",
                         clustering_distance_cols = "euclidean",
                         clustering_method = "complete",
                         color = colorRampPalette(c("red", 
                                                    "yellow", 
                                                    "green"))(colorcount),
                         #cutree_rows = 5,
                         #cutree_cols = 4,
                         cluster_rows = FALSE,
                         cluster_cols = FALSE,
                         show_rownames = FALSE,
                         show_colnames = FALSE,
                         display_numbers = FALSE,
                         number_format = "%.2f",
                         #cellheight = 3,
                         #cellwidth = 3
                         )
```

```{r, eval=TRUE, echo=TRUE}
ggsave(heatmap_plot,
       height = 8,
       width = 12,
       units = "in",
       file = paste0("Plots/gp_sqavp_wocp", ".png"))
rm(heatmap_plot)
rm(colorcount)
```

## sqav_be_yld Crosstab

```{r}
# Define the values for each variable
sprop <- c(0, 0.05, 0.10, 0.15, 0.20, 0.25, 0.30, 0.35, 0.40, 0.45, 0.50,
           0.55, 0.60, 0.65, 0.70, 0.75, 0.80, 0.85, 0.90, 0.95, 1.00)
array <- c("Fixed", "Tracking") # Solar Array
height <- c(4.6, 6.4, 8.2) # Panel height
al_regs <- c("Northern", "Central", "Black Belt", "Southern")
price <- c(11, 12, 13, 14, 15, 16, 17)
elcprc <- c(0.02, 0.03, 0.04) # Electricity Price
yldvar <- c(0.10, 0.20, 0.30, 0.40, 0.50, 0.60, 0.70, 0.80, 0.90, 1.00,
            1.10, 1.20, 1.30, 1.40, 1.50, 1.60, 1.70, 1.80, 1.90, 2.00)

# Define the required columns
required_columns <- c("sprop", "array", "height", 
                      "al_regs", "price", "elcprc")

# Check if the columns exist in tav_profit
missing_columns <- setdiff(required_columns, 
                           names(sqav_be_yld))
if (length(missing_columns) > 0) {
  stop("Missing columns in sqavp_be_yld: ",
       paste(missing_columns, collapse = ", "))
}

# Generate column names using reversed order of expand.grid
col_names <- apply(expand.grid(height, array, sprop), 1,
                   function(x) paste0(x[3], x[2], x[1]))

# Generate row names using reversed order of expand.grid
row_names <- apply(expand.grid(elcprc, 
                               price,
                               al_regs), 1, 
                   function(x) paste0(x, collapse = ""))

# Create an empty matrix to store the results
result_matrix <- matrix(NA, nrow = length(row_names), 
                        ncol = length(col_names))
colnames(result_matrix) <- col_names
rownames(result_matrix) <- row_names

# Create a data frame with 
# all combinations of parameters in reversed order
param_combinations <- expand.grid(elcprc = elcprc, 
                                  price = price, 
                                  al_regs = al_regs,
                                  height = height, 
                                  array = array, 
                                  sprop = sprop)

# Merge with tavp_be_yld to get sbav_be_yld values for each combination
merged_data <- merge(param_combinations, 
                     sqav_be_yld, 
                     by = required_columns,
                     all.x = TRUE)

# Reshape merged_data to fill result_matrix with 
# reversed column and row names
merged_data$col_name <- apply(
  merged_data[, c("sprop", "array", "height")], 1,
  function(x) paste0(x[1], x[2], x[3]))

merged_data$row_name <- apply(
  merged_data[, c("al_regs", "price", "elcprc")], 1,
  function(x) paste0(x[3],
                     x[2],
                     x[1]))

# Fill the matrix with sbav_profit values
for (i in seq_len(nrow(result_matrix))) {
  row_condition <- rownames(result_matrix)[i]
  row_data <- merged_data[
    merged_data$row_name == row_condition, ]
  if (nrow(row_data) > 0) {
    result_matrix[i, 
                  match(row_data$col_name, 
                        colnames(result_matrix))] <- round(
                          row_data$yield, 2)
  }
}
ct_sqav_be_yld <- as.data.frame(result_matrix) # Table in Excel.
write.csv(as.data.frame(ct_sqav_be_yld),
          row.names = TRUE,
          file = "Results/ct_sqav_be_yld.csv")
dim(ct_sqav_be_yld)
rm(result_matrix)
```

## sqav_be_yld Heatmap

```{r}
uniquevalue = unique(as.vector(as.matrix(ct_sqav_be_yld[-1])))
uniquevalue
colorcount = length(unique(as.vector(as.matrix(ct_sqav_be_yld[-1]))))
colorcount
heatmap_plot <- pheatmap((ct_sqav_be_yld),
                         #clustering_distance_rows = "correlation",
                         clustering_distance_rows = "euclidean",
                         clustering_distance_cols = "euclidean",
                         clustering_method = "complete",
                         angle_col = 90,
                         na_col = "white",
                         color = colorRampPalette(c("green", 
                                                    "yellow", 
                                                    "red"))(colorcount),
                         cellheight = 5,
                         cellwidth = 5,
                         fontsize = 12,
                         fontsize_row = 4,
                         fontsize_col = 4,
                         cluster_rows = FALSE,
                         cluster_cols = FALSE,
                         show_rownames = TRUE,
                         show_colnames = TRUE,
                         display_numbers = FALSE,
                         number_format = "%.2f",
                         annotation_colors = c(uniquevalue),
                         legend_breaks = uniquevalue,
                         legend_labels = c(uniquevalue)
                         )
```

```{r}
ggsave(heatmap_plot,
       height = 8,
       width = 12,
       units = "in",
       file = paste0("Plots/gp_sqav_be_yld", ".png"))
rm(heatmap_plot); rm(colorcount); rm(uniquevalue)
```

## Plotting Squash Profit by Panels

You can see plot breakdown based on yield variation, crop price, and electricity price. You can see variation for all solar proportion in one facet of the chart. Each facet of the chart contain av profit three heights of solar panels, four regions of AL, two array types.

```{r, cache=TRUE, warning=FALSE, error=TRUE, eval=TRUE}
combinations <- expand.grid(
  yldvar = c(0.1, 0.3, 0.5, 0.7, 1, 1.20, 1.5, 1.80, 2), # Yield variation
  price = c(11, 14, 17), # Squash price
  elcprc = c(0.03, 0.04, 0.05) #Electricity price
)

# Iterate over the combinations and create the plots
for (combo in seq_len(nrow(combinations))) {
  filtered_data <- sqav_profit %>%
    filter(
      yldvar == combinations$yldvar[combo],
      price == combinations$price[combo],
      elcprc == combinations$elcprc[combo]
    )
  # If by panel, put panels below in color and group.
  sqav_sp_plot <- ggplot(data = filtered_data,
                        mapping = aes(x = al_regs,
                                      y = sqav_profit,
                                      color = factor(panels),
                                      group = factor(panels))) +
    geom_line() +
    geom_point() +
    facet_grid(height ~ array,
               labeller = as_labeller(
                 c(
                   "4.6" = "4.6 ft. Height",
                   "6.4" = "6.4 ft. Height",
                   "8.2" = "8.2 ft. Height",
                   Tracking = "Single Axis Rotation", 
                   Fixed = "Fixed Open Rack"
                   ))) +
    guides(color = guide_legend(ncol = 1, 
                                reverse = TRUE)) +
    scale_x_discrete(limits = c("Northern", "Central",
                                "Black Belt", "Southern"), 
                     labels = c("North", "Center", 
                                "B Belt", "South")) +
    guides(color = guide_legend(ncol = 2, 
                                reverse = TRUE)) +
    labs(x = "Regions of Alabama",
         y = "Profit ($) from Squash Agrivoltaic System",
         color = "Number of Solar \n Panels per Acre",
         title = (list(combinations[combo,]))
         ) +
    theme(strip.background = element_blank())
  # Add horizontal line at y = 0 if y has both positive and negative values
  if (min(filtered_data$sqav_profit) < 0 &
      max(filtered_data$sqav_profit) > 0) {
    sqav_sp_plot <- sqav_sp_plot + 
      geom_hline(yintercept = 0, 
                 linewidth = 0.30, 
                 linetype = "dashed", 
                 color = "black")
  }
  print(combinations[combo,])
  print(sqav_sp_plot)
  ggsave(file = paste0("Plots/sqav_sp_", combo, ".png"))
  #break
}
```

## Plotting Squash Profit by Yields

You can see plot breakdown based on solar proportion, crop price, and electricity price. You can see variation for all crop yield variation in one facet of the chart. Each facet of the chart contain av profit three heights of solar panels, four regions of AL, two array types.

```{r, cache=TRUE, results='show', warning=FALSE, error=TRUE, eval=TRUE}
combinations <- expand.grid(
  sprop = c(0, 0.25, 0.50, 0.75, 1.00), # Solar proportion
  price = c(11, 14, 17), # Squash price
  elcprc = c(0.03, 0.04, 0.05) #Electricity price
)

# Iterate over the combinations and create the plots
for (combo in seq_len(nrow(combinations))) {
  filtered_data <- sqav_profit %>%
    filter(
      sprop == combinations$sprop[combo],
      price == combinations$price[combo],
      elcprc == combinations$elcprc[combo]
    )
  # If by yield, put yield below in color and group.
  sqav_yv_plot <- ggplot(data = filtered_data,
                        mapping = aes(x = al_regs,
                                      y = sqav_profit,
                                      color = factor(yield),
                                      group = factor(yield))) +
    geom_line() +
    geom_point() +
    facet_grid(height ~ array,
               labeller = as_labeller(
                 c(
                   "4.6" = "4.6 ft. Height",
                   "6.4" = "6.4 ft. Height",
                   "8.2" = "8.2 ft. Height",
                   Tracking = "Single Axis Rotation", 
                   Fixed = "Fixed Open Rack"
                   ))) +
    guides(color = guide_legend(ncol = 1, 
                                reverse = TRUE)) +
    scale_x_discrete(limits = c("Northern", "Central",
                                "Black Belt", "Southern"), 
                     labels = c("North", "Center", 
                                "B Belt", "South")) +
    guides(color = guide_legend(ncol = 2, 
                                reverse = TRUE)) +
    labs(x = "Regions of Alabama",
         y = "Profit ($) from Squash Agrivoltaic System",
         color = "Squash Yield \n (25 Lb Buckets)",
         title = (list(combinations[combo,]))
         ) +
    theme(strip.background = element_blank())
  # Add horizontal line at y = 0 if y has both positive and negative values
  if (min(filtered_data$sqav_profit) < 0 &
      max(filtered_data$sqav_profit) > 0) {
    sqav_yv_plot <- sqav_yv_plot + 
      geom_hline(yintercept = 0, 
                 linewidth = 0.30, 
                 linetype = "dashed", 
                 color = "black")
  }
  print(combinations[combo,])
  print(sqav_yv_plot)
  ggsave(file = paste0("Plots/sqav_yv_", combo, ".png"))
  #break
}
```
