import pandas as pd
import xlrd
import pandas as pd
import xlrd
import pandas as pd
claer
clear
import pandas as pd
import pandas as pd
import pandas as pd
import pandas as pd
import pandas as pd
import pandas as pd
# #| echo: TRUE
rm(list = ls()) # Clean the environment.
options(
warn=0, # Warnings. options(warn=-1) / options(warn=0)
scipen=999 # No scientific notations.
)
library(tidyverse, warn.conflicts = FALSE, quietly = TRUE)
library(psych, warn.conflicts = FALSE, quietly = TRUE)
library(likert,  warn.conflicts = FALSE, quietly = TRUE) # Likert Items
library(mice,  warn.conflicts = FALSE, quietly = TRUE)
library(openxlsx2, warn.conflicts = FALSE, quietly = TRUE)
library(ggpubr, warn.conflicts = FALSE, quietly = TRUE) # Scatter plot
library(gmodels,  warn.conflicts = FALSE, quietly = TRUE) # Crosstab
library(reshape2, warn.conflicts = FALSE, quietly = TRUE) # Reshape data
library(pacman,  warn.conflicts = FALSE, quietly = TRUE) # Package Management
library(progress, warn.conflicts = FALSE, quietly = TRUE) # Progress bar
library(arrow, warn.conflicts = FALSE, quietly = TRUE) # Feather
library(plot3D, warn.conflicts = FALSE, quietly = TRUE)
library(plotly, warn.conflicts = FALSE, quietly = TRUE) # 3D plotting
library(lattice, warn.conflicts = FALSE, quietly = TRUE)
#pacman::p_loaded()
####### Plotting Data: #####
# Map Theme:
plottheme <- ggplot() +
theme_void() +
# Mapping theme:
theme(axis.title = element_blank(),
axis.ticks = element_blank(),
axis.text = element_blank(),
panel.border = element_blank(),
plot.margin = margin(t = 0,
r = 0,
b = 0,
l = 0,
unit = "cm"),
plot.title = element_text(hjust = 0.5),
plot.background = element_rect(fill = "white",
color = "black",
linewidth = 0),
panel.background = element_rect(fill = "white",
color = "black",
linewidth = 0),
panel.grid.major.x = element_line(color = "lightgrey",
linetype = 2,
linewidth = 0),
panel.grid.minor.x = element_line(color = "lightgrey",
linetype = 2,
linewidth = 0),
panel.grid.major.y = element_line(color = "grey",
linetype = 2,
linewidth = 0),
panel.grid.minor.y = element_line(color = "grey",
linetype = 2,
linewidth = 0),
axis.line.x.top = element_line(color = "white",
linetype = 2,
linewidth = 0),
axis.line.y.right = element_line(color = "white",
linetype = 2,
linewidth = 0),
axis.line.x.bottom = element_line(color = "black",
linetype = 1,
linewidth = 0),
axis.line.y.left = element_line(color = "black",
linetype = 1,
linewidth = 0),
# Text formatting:
text = element_text(family = "serif", # font
size = 12, # font size
colour = "black"# font color
),
legend.position = c(0.95, -0.05),
legend.key = element_rect(color = "black",
fill = NA,
linewidth = 0.05,
linetype = 1),
legend.justification = "right",
legend.direction = "horizontal")
tav_profit <- as.data.frame(read_feather(file = "tav_profit.feather"))
#str(tav_profit)
#head(tav_profit); head(tav_profit)
dim(tav_profit)
sbav_profit <- as.data.frame(read_feather(file = "sbav_profit.feather"))
#str(sbav_profit)
#head(sbav_profit); tail(sbav_profit)
dim(sbav_profit)
sqav_profit <- as.data.frame(read_feather(file = "sqav_profit.feather"))
#str(sqav_profit)
#head(sqav_profit); tail(sqav_profit)
dim(sqav_profit)
# Define the values for each variable
sprop <- c(0, 0.25, 0.50, 0.75, 1.00) # Land Proportion
array <- c("Fixed", "Tracking") # Solar Array
height <- c(4.6, 6.4, 8.2) # Panel height
yldvar <- c(0.10, 0.30, 0.50, 0.70, 1.00, 1.20, 1.50, 1.80, 2.00) # Crop Yield Variation
al_regs <- c("Northern", "Central", "Black Belt", "Southern") # Regions of AL
price <- c(17, 20, 23) # Crop Price
elcprc <- c(0.02, 0.03, 0.04) # Electricity Price
# Define the required columns
required_columns <- c("sprop", "array", "height",
"al_regs", "yldvar", "price", "elcprc")
# Check if the columns exist in tav_profit
missing_columns <- setdiff(required_columns,
names(tav_profit))
if (length(missing_columns) > 0) {
stop("Missing columns in tav_profit: ",
paste(missing_columns, collapse = ", "))
}
# Generate column names using reversed order of expand.grid
col_names <- apply(expand.grid(height, array, sprop), 1,
function(x) paste0(x[3], "%_", x[2], "_", x[1]))
# Generate row names using reversed order of expand.grid
row_names <- apply(expand.grid(elcprc,
price,
yldvar,
al_regs), 1,
function(x) paste0(x, collapse = "_"))
# Create an empty matrix to store the results
result_matrix <- matrix(NA, nrow = length(row_names),
ncol = length(col_names))
colnames(result_matrix) <- col_names
rownames(result_matrix) <- row_names
# Create a data frame with
# all combinations of parameters in reversed order
param_combinations <- expand.grid(elcprc = elcprc,
price = price,
yldvar = yldvar,
al_regs = al_regs,
height = height,
array = array,
sprop = sprop)
# Merge with tav_profit to get tav_profit values for each combination
merged_data <- merge(param_combinations,
tav_profit,
by = required_columns,
all.x = TRUE)
# Reshape merged_data to fill result_matrix with
# reversed column and row names
merged_data$col_name <- apply(
merged_data[, c("sprop", "array", "height")], 1,
function(x) paste0(x[1], "%_", x[2], "_", x[3]))
merged_data$row_name <- apply(
merged_data[, c("al_regs", "yldvar", "price", "elcprc")], 1,
function(x) paste0(x[4], "_",
x[3], "_",
x[2], "_", x[1]))
# Fill the matrix with tav_profit values
for (i in seq_len(nrow(result_matrix))) {
row_condition <- rownames(result_matrix)[i]
row_data <- merged_data[
merged_data$row_name == row_condition, ]
if (nrow(row_data) > 0) {
result_matrix[i,
match(row_data$col_name,
colnames(result_matrix))] <- round(
row_data$tav_profit, 2)
}
tav_chtbl <- as.data.frame(result_matrix) #Table in Excel.
rm(result_matrix)
write.csv(as.data.frame(tav_chtbl),
row.names = TRUE,
col.names = TRUE,
file = "tav_chtbl.csv")
dim(tav_chtbl)
# Display the result matrix
#head(tav_chtbl)
#tail(tav_chtbl)
names(tav_profit)
# Define the combinations of yield, price, and elcprc
combinations <- expand.grid(
yield = unique(tav_profit$yield),
price = unique(tav_profit$price),
elcprc = unique(tav_profit$elcprc)
)
# Iterate over the combinations and create the plots
for (combo in seq_len(nrow(combinations))) {
filtered_data <- tav_profit %>%
filter(
yield == combinations$yield[combo],
price == combinations$price[combo],
elcprc == combinations$elcprc[combo]
)
tomato_plot <- ggplot(data = filtered_data,
mapping = aes(x = sprop,
y = tav_profit,
color = factor(al_regs),
group = factor(al_regs))) +
#geom_line() +
geom_point() +
facet_grid(array ~ height) +
guides(color = guide_legend(ncol = 1, reverse = TRUE))
print(tomato_plot)
# ggsave(file = paste0("tomato_plot_", combo, ".png"))
}
