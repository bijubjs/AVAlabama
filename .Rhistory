.groups = 'drop'
) # dimension of matrix is 168*6
matrix2 <- elec_price # dimension of matrix is 11*1
# Initialize the result data frame
# energy_revenue <- data.frame(matrix(nrow = 1848, ncol = 9))
energy_revenue <- data.frame(
matrix(nrow = nrow(matrix2)*nrow(matrix1),
ncol = ncol(matrix2)+ncol(matrix1)+1))
# Variable to keep track of the row index in the result matrix
row_index <- 1
# Loop through each value of the second matrix
for (i in 1:nrow(matrix2)) {
# Loop through each value of the second matrix
for (j in 1:nrow(matrix1)) {
# First matrix, second matrix, combined two matrices.
new_row <- c(matrix1[j, ],
matrix2[i, ],
matrix1$energy[j] * matrix2$epr_kwh[i])
# Assign the new row to the result matrix
energy_revenue[row_index, ] <- new_row
# Increment the row index
row_index <- row_index + 1
}
# Name the columns
colnames(energy_revenue) <- c(colnames(matrix1), "elcprc", "elcrev")
# Display the result
dim(energy_revenue)
head(energy_revenue); tail(energy_revenue)
# Check for any NAs in the result
if(any(is.na(energy_revenue))) {
na_indices <- which(is.na(energy_revenue), arr.ind = TRUE)
print(paste("NAs found at rows:", unique(na_indices[, 1])))
} else {
print("No NAs found in the result data frame.")
}
## | results='hide'
# Sample data
set.seed(123)
matrix1 <- energy_output # dimension of matrix is 176*7
matrix2 <- elec_price # dimension of matrix is 11*1
# Initializing the result matrix
result_matrix <- data.frame(matrix(ncol = nrow(matrix2),
nrow = 0))
colnames(result_matrix) <- c(colnames(matrix1),  "elcrev", "elcprc")
# Loop to multiply first and second matrices
for (i in 1:nrow(matrix2)) {
temp_matrix <- matrix1
temp_matrix$E_Prc <- matrix2[i, ]
temp_matrix$E_Rev <- matrix1$energy[j] * matrix2$epr_kwh[i]
result_matrix <- rbind(result_matrix, temp_matrix)
}
# Display the resulting matrix
dim(result_matrix)
head(result_matrix)
tail(result_matrix)
lox <- c("Northern", "Central", "Black Belt", "Southern")
array_levs = c("Single Axis Rotation", "Fixed Open Rack")
datalot_levs = c("Location 1", "Location 2")
for (i in unique(energy_revenue$elcprc)) {
a = ggplot(data = (energy_revenue %>%
filter(elcprc == i)),
mapping = aes(x =al_regs,
y = elcrev,
#fill = energy,
color = factor(panels),
group = factor(panels)))+
geom_line()+
geom_point()+
facet_grid(.~array) +
scale_x_discrete(limits = lox,
labels = c("North", "Center", "B Belt", "South")) +
guides(color = guide_legend(ncol =2, reverse = TRUE))
cat("Electricity Price = ", i)
print(a)
}
lox <- c("Northern", "Central", "Black Belt", "Southern")
array_levs = c("Single Axis Rotation", "Fixed Open Rack")
datalot_levs = c("Location 1", "Location 2")
for (i in unique(energy_revenue$elcprc)) {
a = ggplot(data = (energy_revenue %>%
filter(elcprc == i)),
mapping = aes(x =al_regs,
y = elcrev,
#fill = energy,
color = factor(sprop),
group = factor(sprop)))+
geom_line()+
geom_point()+
facet_grid(.~array) +
scale_x_discrete(limits = lox,
labels = c("North", "Center", "B Belt", "South")) +
guides(color = guide_legend(ncol = 2, reverse = TRUE))
cat("Electricity Price = ", i)
print(a)
}
cat("energy_revenue dimension = ", dim(energy_revenue)) # 1936*9
names(energy_revenue)
cat("capex = ", dim(capex)) # 6*3
names(capex)
expanded_data <- energy_revenue %>%
slice(rep(1:n(),
each = 3))
capex_height <- rep(unique(capex$height),
length.out = nrow(energy_revenue))
energy_cost = cbind(expanded_data, capex_height) %>%
rename(height = capex_height)
energy_cost <- left_join(energy_cost,
capex,
by = c("array", "height")) %>%
mutate(ttlcost = capex*dc_kw,
anncost = ttlcost*(0.05*(1 + 0.05)^25)/
((1 + 0.05)^25 - 1),
moncost = ttlcost*((0.05/12)*(1 + (0.05/12))^(25*12))/
((1 + (0.05/12))^(25*12) - 1))
dim(energy_cost)
head(energy_cost)
tail(energy_cost)
sliderInput("bins", "Number of bins:",
min = 1, max = 100, value = 30)
names(tav_profit)
# #| echo: TRUE
rm(list = ls()) # Clean the environment.
options(
warn=0, # Warnings. options(warn=-1) / options(warn=0)
scipen=999 # No scientific notations.
)
path_mac = "/Users/bmishra/Library/CloudStorage/OneDrive-AuburnUniversity/Collaboration/Ngbede M/Choice-paper"
path_office = "Users\\bzm0094\\OneDrive - Auburn University\\Collaboration\\Ngbede M\\Choice-paper"
ifelse(Sys.info()[6] == "bmishra",
setwd(path_mac),
setwd(path_office))
library(tidyverse, warn.conflicts = FALSE, quietly = TRUE)
library(psych, warn.conflicts = FALSE, quietly = TRUE)
library(likert,  warn.conflicts = FALSE, quietly = TRUE) # Likert Items
library(mice,  warn.conflicts = FALSE, quietly = TRUE)
library(openxlsx2, warn.conflicts = FALSE, quietly = TRUE)
library(ggpubr, warn.conflicts = FALSE, quietly = TRUE) # Scatter plot
library(gmodels,  warn.conflicts = FALSE, quietly = TRUE) # Crosstab
library(reshape2, warn.conflicts = FALSE, quietly = TRUE) # Reshape data
library(pacman,  warn.conflicts = FALSE, quietly = TRUE) # Package Management
library(progress, warn.conflicts = FALSE, quietly = TRUE) #progress bar
library(arrow, warn.conflicts = FALSE, quietly = TRUE) #progress bar
pacman::p_loaded()
####### Progress Bar #####
pb = progress_bar$new(
format = "Processing data at :rate. Processed :bytes in :elapsed.",
clear = TRUE,
total = NA,
width = 80)
f = function() {
for (i in 1:100) {
pb$tick(sample(1:100 * 1000, 1))
Sys.sleep(2/100)
}
pb$tick(1e7)
#invisible()
}
####### Plotting Data: #####
# Map Theme:
plottheme <- ggplot() +
theme_void() +
# Mapping theme:
theme(axis.title = element_blank(),
axis.ticks = element_blank(),
axis.text = element_blank(),
panel.border = element_blank(),
plot.margin = margin(t = 0,
r = 0,
b = 0,
l = 0,
unit = "cm"),
plot.title = element_text(hjust = 0.5),
plot.background = element_rect(fill = "white",
color = "black",
linewidth = 0),
panel.background = element_rect(fill = "white",
color = "black",
linewidth = 0),
panel.grid.major.x = element_line(color = "lightgrey",
linetype = 2,
linewidth = 0),
panel.grid.minor.x = element_line(color = "lightgrey",
linetype = 2,
linewidth = 0),
panel.grid.major.y = element_line(color = "grey",
linetype = 2,
linewidth = 0),
panel.grid.minor.y = element_line(color = "grey",
linetype = 2,
linewidth = 0),
axis.line.x.top = element_line(color = "white",
linetype = 2,
linewidth = 0),
axis.line.y.right = element_line(color = "white",
linetype = 2,
linewidth = 0),
axis.line.x.bottom = element_line(color = "black",
linetype = 1,
linewidth = 0),
axis.line.y.left = element_line(color = "black",
linetype = 1,
linewidth = 0),
# Text formatting:
text = element_text(family = "serif", # font
size = 12, # font size
colour = "black"# font color
),
legend.position = c(0.95, -0.05),
legend.key = element_rect(color = "black",
fill = NA,
linewidth = 0.05,
linetype = 1),
legend.justification = "right",
legend.direction = "horizontal")
tav_profit <- as.data.frame(read_feather(file = "tav_profit.feather"))
dim(tav_profit)
#str(tav_profit)
head(tav_profit); head(tav_profit)
sbav_profit <- as.data.frame(read_feather(file = "sbav_profit.feather"))
dim(sbav_profit)
#str(sbav_profit)
head(sbav_profit); tail(sbav_profit)
sqav_profit <- as.data.frame(read_feather(file = "sqav_profit.feather"))
dim(sqav_profit)
#str(sqav_profit)
head(sqav_profit); tail(sqav_profit)
# Define the values for each variable
sprop <- c(0, 0.25, 0.50, 0.75, 1.00)
array <- c("Fixed", "Tracking")
height <- c(4.6, 6.4, 8.2)
yldvar <- c(0.10, 0.30, 0.50, 0.70, 1.00, 1.20, 1.50, 1.80, 2.00)
al_regs <- c("Northern", "Central", "Black Belt", "Southern")
price <- c(17, 20, 23)
elcprc <- c(0.01, 0.03, 0.06)
# Define the required columns
required_columns <- c("sprop", "array", "height",
"al_regs", "yldvar", "price", "elcprc")
# Check if the columns exist in tav_profit
missing_columns <- setdiff(required_columns,
names(tav_profit))
if (length(missing_columns) > 0) {
stop("Missing columns in tav_profit: ",
paste(missing_columns, collapse = ", "))
}
# Generate column names using reversed order of expand.grid
col_names <- apply(expand.grid(height, array, sprop), 1,
function(x) paste0(x[3], "%_", x[2], "_", x[1]))
# Generate row names using reversed order of expand.grid
row_names <- apply(expand.grid(elcprc,
price,
yldvar,
al_regs), 1,
function(x) paste0(x, collapse = "_"))
# Create an empty matrix to store the results
result_matrix <- matrix(NA, nrow = length(row_names),
ncol = length(col_names))
colnames(result_matrix) <- col_names
rownames(result_matrix) <- row_names
# Create a data frame with
# all combinations of parameters in reversed order
param_combinations <- expand.grid(elcprc = elcprc,
price = price,
yldvar = yldvar,
al_regs = al_regs,
height = height,
array = array,
sprop = sprop)
# Merge with tav_profit to get tav_profit values for each combination
merged_data <- merge(param_combinations,
tav_profit,
by = required_columns,
all.x = TRUE)
# Reshape merged_data to fill result_matrix with
# reversed column and row names
merged_data$col_name <- apply(
merged_data[, c("sprop", "array", "height")], 1,
function(x) paste0(x[1], "%_", x[2], "_", x[3]))
merged_data$row_name <- apply(
merged_data[, c("al_regs", "yldvar", "price", "elcprc")], 1,
function(x) paste0(x[4], "_",
x[3], "_",
x[2], "_", x[1]))
# Fill the matrix with tav_profit values
for (i in seq_len(nrow(result_matrix))) {
row_condition <- rownames(result_matrix)[i]
row_data <- merged_data[
merged_data$row_name == row_condition, ]
if (nrow(row_data) > 0) {
result_matrix[i,
match(row_data$col_name,
colnames(result_matrix))] <- round(
row_data$tav_profit, 2)
}
write.csv(as.data.frame(result_matrix),
row.names = TRUE,
col.names = TRUE,
file = "tav_chtbl.csv")
dim(as.data.frame(result_matrix))
# Display the result matrix
head(result_matrix)
tail(result_matrix)
# Define the values for each variable
sprop <- c(0, 0.25, 0.50, 0.75, 1.00)
array <- c("Fixed", "Tracking")
height <- c(4.6, 6.4, 8.2)
yldvar <- c(0.10, 0.30, 0.50, 0.70, 1.00, 1.20, 1.50, 1.80, 2.00)
al_regs <- c("Northern", "Central", "Black Belt", "Southern")
price <- c(3, 6, 9)
elcprc <- c(0.01, 0.03, 0.06)
# Define the required columns
required_columns <- c("sprop", "array", "height",
"al_regs", "yldvar", "price", "elcprc")
# Check if the columns exist in sbav_profit
missing_columns <- setdiff(required_columns,
names(sbav_profit))
if (length(missing_columns) > 0) {
stop("Missing columns in sbav_profit: ",
paste(missing_columns, collapse = ", "))
}
# Generate column names using reversed order of expand.grid
col_names <- apply(expand.grid(height, array, sprop), 1,
function(x) paste0(x[3], "%_", x[2], "_", x[1]))
# Generate row names using reversed order of expand.grid
row_names <- apply(expand.grid(elcprc,
price,
yldvar,
al_regs), 1,
function(x) paste0(x, collapse = "_"))
# Create an empty matrix to store the results
result_matrix <- matrix(NA, nrow = length(row_names),
ncol = length(col_names))
colnames(result_matrix) <- col_names
rownames(result_matrix) <- row_names
# Create a data frame with
# all combinations of parameters in reversed order
param_combinations <- expand.grid(elcprc = elcprc,
price = price,
yldvar = yldvar,
al_regs = al_regs,
height = height,
array = array,
sprop = sprop)
# Merge with tav_profit to get sbav_profit values for each combination
merged_data <- merge(param_combinations,
sbav_profit,
by = required_columns,
all.x = TRUE)
# Reshape merged_data to fill result_matrix with
# reversed column and row names
merged_data$col_name <- apply(
merged_data[, c("sprop", "array", "height")], 1,
function(x) paste0(x[1], "%_", x[2], "_", x[3]))
merged_data$row_name <- apply(
merged_data[, c("al_regs", "yldvar", "price", "elcprc")], 1,
function(x) paste0(x[4], "_",
x[3], "_",
x[2], "_", x[1]))
# Fill the matrix with sbav_profit values
for (i in seq_len(nrow(result_matrix))) {
row_condition <- rownames(result_matrix)[i]
row_data <- merged_data[
merged_data$row_name == row_condition, ]
if (nrow(row_data) > 0) {
result_matrix[i,
match(row_data$col_name,
colnames(result_matrix))] <- round(
row_data$sbav_profit, 2)
}
write.csv(as.data.frame(result_matrix),
row.names = TRUE,
col.names = TRUE,
file = "sbav_chtbl.csv")
dim(as.data.frame(result_matrix))
# Display the result matrix
head(result_matrix)
tail(result_matrix)
# Define the values for each variable
sprop <- c(0, 0.25, 0.50, 0.75, 1.00)
array <- c("Fixed", "Tracking")
height <- c(4.6, 6.4, 8.2)
yldvar <- c(0.10, 0.30, 0.50, 0.70, 1.00, 1.20, 1.50, 1.80, 2.00)
al_regs <- c("Northern", "Central", "Black Belt", "Southern")
price <- c(11, 14, 17)
elcprc <- c(0.01, 0.03, 0.06)
# Define the required columns
required_columns <- c("sprop", "array", "height",
"al_regs", "yldvar", "price", "elcprc")
# Check if the columns exist in sqav_profit
missing_columns <- setdiff(required_columns,
names(sqav_profit))
if (length(missing_columns) > 0) {
stop("Missing columns in sqav_profit: ",
paste(missing_columns, collapse = ", "))
}
# Generate column names using reversed order of expand.grid
col_names <- apply(expand.grid(height, array, sprop), 1,
function(x) paste0(x[3], "%_", x[2], "_", x[1]))
# Generate row names using reversed order of expand.grid
row_names <- apply(expand.grid(elcprc,
price,
yldvar,
al_regs), 1,
function(x) paste0(x, collapse = "_"))
# Create an empty matrix to store the results
result_matrix <- matrix(NA, nrow = length(row_names),
ncol = length(col_names))
colnames(result_matrix) <- col_names
rownames(result_matrix) <- row_names
# Create a data frame with
# all combinations of parameters in reversed order
param_combinations <- expand.grid(elcprc = elcprc,
price = price,
yldvar = yldvar,
al_regs = al_regs,
height = height,
array = array,
sprop = sprop)
# Merge with tav_profit to get sqav_profit values for each combination
merged_data <- merge(param_combinations,
sqav_profit,
by = required_columns,
all.x = TRUE)
# Reshape merged_data to fill result_matrix with
# reversed column and row names
merged_data$col_name <- apply(
merged_data[, c("sprop", "array", "height")], 1,
function(x) paste0(x[1], "%_", x[2], "_", x[3]))
merged_data$row_name <- apply(
merged_data[, c("al_regs", "yldvar", "price", "elcprc")], 1,
function(x) paste0(x[4], "_",
x[3], "_",
x[2], "_", x[1]))
# Fill the matrix with sqav_profit values
for (i in seq_len(nrow(result_matrix))) {
row_condition <- rownames(result_matrix)[i]
row_data <- merged_data[
merged_data$row_name == row_condition, ]
if (nrow(row_data) > 0) {
result_matrix[i,
match(row_data$col_name,
colnames(result_matrix))] <- round(
row_data$sqav_profit, 2)
}
names(tav_profit)
write.csv(as.data.frame(result_matrix),
row.names = TRUE,
file = "sqav_chtbl.csv")
dim(as.data.frame(result_matrix))
# Display the result matrix
head(result_matrix)
tail(result_matrix)
names(tav_profit)
library(shiny)
library(array)
library(shiny, warn.conflicts = FALSE, quietly = TRUE) #feather
library(arrow, warn.conflicts = FALSE, quietly = TRUE) #feather
tav_profit <- as.data.frame(read_feather(file = "tav_profit.feather"))
# Install and load necessary packages
# Define the UI
ui <- fluidPage(
titlePanel("Filtered Data Table"),
sidebarLayout(
sidebarPanel(
selectInput("sprop", "Select sprop:", choices = NULL),
selectInput("al_regs", "Select al_regs:", choices = NULL),
selectInput("array", "Select array:", choices = NULL),
selectInput("elcprc", "Select elcprc:", choices = NULL),
selectInput("height", "Select height:", choices = NULL),
selectInput("capex", "Select capex:", choices = NULL),
selectInput("price", "Select price:", choices = NULL),
selectInput("yldvar", "Select yldvar:", choices = NULL)
),
mainPanel(
dataTableOutput("filteredTable")
)
# Define the server logic
server <- function(input, output, session) {
# Load your data (replace 'your_dataframe' with the actual dataframe name)
df <- tav_profit
# Update the selectInput choices based on the unique values in the dataframe
observe({
updateSelectInput(session, "sprop", choices = unique(df$sprop))
updateSelectInput(session, "al_regs", choices = unique(df$al_regs))
updateSelectInput(session, "array", choices = unique(df$array))
updateSelectInput(session, "elcprc", choices = unique(df$elcprc))
updateSelectInput(session, "height", choices = unique(df$height))
updateSelectInput(session, "capex", choices = unique(df$capex))
updateSelectInput(session, "price", choices = unique(df$price))
updateSelectInput(session, "yldvar", choices = unique(df$yldvar))
})
# Filter the dataframe based on the selected inputs
filteredData <- reactive({
df %>%
filter(
sprop == input$sprop,
al_regs == input$al_regs,
array == input$array,
elcprc == input$elcprc,
height == input$height,
capex == input$capex,
price == input$price,
yldvar == input$yldvar
) %>%
select(tav_profit)
})
# Render the filtered table
output$filteredTable <- renderDataTable({
filteredData()
})
}
# Run the Shiny app
shinyApp(ui = ui, server = server)
