file = "Results/ct_tavp_wocp R25.csv")
colorcount = length(unique(as.vector(as.matrix(ct_tavp_wocp[-1]))))
colorcount
heatmap_plot <- pheatmap(t(ct_tavp_wocp),
#clustering_distance_rows = "correlation",
clustering_distance_rows = "euclidean",
clustering_distance_cols = "euclidean",
clustering_method = "complete",
color = colorRampPalette(c("red",
"yellow",
"green"))(colorcount),
#cutree_rows = 5,
#cutree_cols = 4,
cutree_rows = 5,
cutree_cols = 4,
cluster_rows = FALSE,
cluster_cols = FALSE,
show_rownames = FALSE,
show_colnames = FALSE,
display_numbers = FALSE,
number_format = "%.2f",
#cellheight = 3,
#cellwidth = 3
)
colorcount = length(unique(as.vector(as.matrix(ct_tavp_wocp[-1]))))
heatmap_plot <- pheatmap(t(ct_tavp_wocp),
#clustering_distance_rows = "correlation",
clustering_distance_rows = "euclidean",
clustering_distance_cols = "euclidean",
clustering_method = "complete",
color = colorRampPalette(c("red",
"yellow",
"green"))(colorcount),
#cutree_rows = 5,
#cutree_cols = 4,
cutree_rows = 5,
cutree_cols = 4,
cluster_rows = FALSE,
cluster_cols = FALSE,
show_rownames = FALSE,
show_colnames = FALSE,
display_numbers = FALSE,
number_format = "%.2f",
#cellheight = 3,
#cellwidth = 3
)
rm(colorcount, heatmap_plot)
colorcount = length(unique(as.vector(as.matrix(ct_tavp_wocp[-1]))))
heatmap_plot <- pheatmap(t(ct_tavp_wocp),
#clustering_distance_rows = "correlation",
clustering_distance_rows = "euclidean",
clustering_distance_cols = "euclidean",
clustering_method = "complete",
color = colorRampPalette(c("red",
"yellow",
"green"))(colorcount),
#cutree_rows = 5,
#cutree_cols = 4,
cutree_rows = 5,
cutree_cols = 4,
cluster_rows = FALSE,
cluster_cols = FALSE,
show_rownames = FALSE,
show_colnames = FALSE,
display_numbers = FALSE,
number_format = "%.2f",
#cellheight = 3,
#cellwidth = 3
)
ggsave(heatmap_plot,
height = 8,
width = 12,
units = "in",
file = paste0("Plots/gp_tavp_wocp R25", ".png"))
rm(heatmap_plot, colorcount)
# Define the values for each variable
sprop <- c(0.05, 0.25, 0.50, 0.75, 0.80, 0.85, 0.90, 1)
array <- c("Fixed", "Tracking") # Solar Array
height <- c(4.6, 6.4, 8.2) # Panel height
al_regs <- c("Northern", "Central", "Black Belt", "Southern")
price <- c(17, 20, 23) # Crop Price
elcprc <- c(0.02, 0.03, 0.04) # Electricity Price
#elcprc <- c(0.04) # Electricity Price
yldvar <- c(1)
# Define the required columns
required_columns <- c("sprop", "array", "height",
"al_regs", "price", "elcprc")
# Check if the columns exist in tav_profit
missing_columns <- setdiff(required_columns,
names(tav_be_yld))
if (length(missing_columns) > 0) {
stop("Missing columns in tavp_be_yld: ",
paste(missing_columns, collapse = ", "))
}
# Generate column names using reversed order of expand.grid
col_names <- apply(expand.grid(height, array, sprop), 1,
function(x) paste0(x[3] , x[2] , x[1]))
# Generate row names using reversed order of expand.grid
row_names <- apply(expand.grid(elcprc,
price,
#yldvar,
al_regs), 1,
function(x) paste0(x, collapse = ""))
# Create an empty matrix to store the results
result_matrix <- matrix(NA, nrow = length(row_names),
ncol = length(col_names))
colnames(result_matrix) <- col_names
rownames(result_matrix) <- row_names
# Create a data frame with
# all combinations of parameters in reversed order
param_combinations <- expand.grid(elcprc = elcprc,
price = price,
#yldvar = yldvar,
al_regs = al_regs,
height = height,
array = array,
sprop = sprop)
# Merge with tav_be_yld to get tav_be_yld values for each combination
merged_data <- merge(param_combinations,
tav_be_yld,
by = required_columns,
all.x = TRUE)
# Reshape merged_data to fill result_matrix with
# reversed column and row names
merged_data$col_name <- apply(
merged_data[, c("sprop", "array", "height")], 1,
function(x) paste0(x[1], x[2], x[3]))
merged_data$row_name <- apply(
merged_data[, c("al_regs", "price", "elcprc")], 1,
function(x) paste0(x[3],
x[2],
x[1]))
# Fill the matrix with tav_profit values
for (i in seq_len(nrow(result_matrix))) {
row_condition <- rownames(result_matrix)[i]
row_data <- merged_data[
merged_data$row_name == row_condition, ]
if (nrow(row_data) > 0) {
result_matrix[i,
match(row_data$col_name,
colnames(result_matrix))] <- round(
row_data$yield, 0)
}
}
ct_tav_be_yld <- as.data.frame(result_matrix) # Table in Excel.
rm(result_matrix)
# Define the values for each variable
sprop <- c(0.05, 0.25, 0.50, 0.75, 0.80, 0.85, 0.90, 1)
array <- c("Fixed", "Tracking") # Solar Array
height <- c(4.6, 6.4, 8.2) # Panel height
al_regs <- c("Northern", "Central", "Black Belt", "Southern")
price <- c(17, 20, 23) # Crop Price
elcprc <- c(0.02, 0.03, 0.04) # Electricity Price
#elcprc <- c(0.04) # Electricity Price
yldvar <- c(1)
# Define the required columns
required_columns <- c("sprop", "array", "height",
"al_regs", "price", "elcprc")
# Check if the columns exist in tav_profit
missing_columns <- setdiff(required_columns,
names(tav_be_yld))
if (length(missing_columns) > 0) {
stop("Missing columns in tavp_be_yld: ",
paste(missing_columns, collapse = ", "))
}
# Generate column names using reversed order of expand.grid
col_names <- apply(expand.grid(height, array, sprop), 1,
function(x) paste0(x[3] , x[2] , x[1]))
# Generate row names using reversed order of expand.grid
row_names <- apply(expand.grid(elcprc,
price,
#yldvar,
al_regs), 1,
function(x) paste0(x, collapse = ""))
# Create an empty matrix to store the results
result_matrix <- matrix(NA, nrow = length(row_names),
ncol = length(col_names))
colnames(result_matrix) <- col_names
rownames(result_matrix) <- row_names
# Create a data frame with
# all combinations of parameters in reversed order
param_combinations <- expand.grid(elcprc = elcprc,
price = price,
#yldvar = yldvar,
al_regs = al_regs,
height = height,
array = array,
sprop = sprop)
# Merge with tav_be_yld to get tav_be_yld values for each combination
merged_data <- merge(param_combinations,
tav_be_yld,
by = required_columns,
all.x = TRUE)
# Reshape merged_data to fill result_matrix with
# reversed column and row names
merged_data$col_name <- apply(
merged_data[, c("sprop", "array", "height")], 1,
function(x) paste0(x[1], x[2], x[3]))
merged_data$row_name <- apply(
merged_data[, c("al_regs", "price", "elcprc")], 1,
function(x) paste0(x[3],
x[2],
x[1]))
# Fill the matrix with tav_profit values
for (i in seq_len(nrow(result_matrix))) {
row_condition <- rownames(result_matrix)[i]
row_data <- merged_data[
merged_data$row_name == row_condition, ]
if (nrow(row_data) > 0) {
result_matrix[i,
match(row_data$col_name,
colnames(result_matrix))] <- round(
row_data$yield, 0)
}
}
ct_tav_be_yld <- as.data.frame(result_matrix) # Table in Excel.
rm(result_matrix, merged_data, row_data, param_combinations)
rm(al_regs, array, col_names, elcprc, height, i, missing_columns)
rm(price, required_columns, row_condition, row_names, sprop, yldvar)
write.csv(as.data.frame(ct_tav_be_yld),
row.names = TRUE,
file = "Results/ct_tav_be_yld R25.csv")
uniquevalue = unique(as.vector(as.matrix(ct_tav_be_yld[-1])))
uniquevalue
colorcount = length(unique(as.vector(as.matrix(ct_tav_be_yld[-1]))))
colorcount
heatmap_plot <- pheatmap((ct_tav_be_yld),
#clustering_distance_rows = "correlation",
clustering_distance_rows = "euclidean",
clustering_distance_cols = "euclidean",
clustering_method = "complete",
angle_col = 90,
na_col = "white",
color = colorRampPalette(
c("green", "yellow","red")
)(colorcount),
cellheight = 13,
cellwidth = 14,
fontsize = 12,
fontsize_row = 12,
fontsize_col = 12,
number_color = "white",
fontsize_number = 5,
cluster_rows = FALSE,
cluster_cols = FALSE,
show_rownames = TRUE,
show_colnames = TRUE,
display_numbers = TRUE,
number_format = "%.0f"
#legend_breaks = uniquevalue
)
uniquevalue = unique(as.vector(as.matrix(ct_tav_be_yld[-1])))
colorcount = length(unique(as.vector(as.matrix(ct_tav_be_yld[-1]))))
heatmap_plot <- pheatmap((ct_tav_be_yld),
#clustering_distance_rows = "correlation",
clustering_distance_rows = "euclidean",
clustering_distance_cols = "euclidean",
clustering_method = "complete",
angle_col = 90,
na_col = "white",
color = colorRampPalette(
c("green", "yellow","red")
)(colorcount),
cellheight = 13,
cellwidth = 14,
fontsize = 12,
fontsize_row = 12,
fontsize_col = 12,
number_color = "white",
fontsize_number = 5,
cluster_rows = FALSE,
cluster_cols = FALSE,
show_rownames = TRUE,
show_colnames = TRUE,
display_numbers = TRUE,
number_format = "%.0f"
#legend_breaks = uniquevalue
)
ggsave(heatmap_plot,
height = 8,
width = 12,
units = "in",
file = paste0("Plots/gp_tav_be_yld R25", ".png"))
rm(heatmap_plot, colorcount, uniquevalue)
combinations <- expand.grid(
yldvar = c(0, 0.1, 0.3, 0.5, 0.7, 1, 1.20, 1.5, 1.80, 2), # Yield
price = c(17, 20, 23), # Tomato price
elcprc = c(0.03, 0.04, 0.05) #Electricity price
)
# Iterate over the combinations and create the plots
for (combo in seq_len(nrow(combinations))) {
filtered_data <- tav_profit %>%
filter(
yldvar == combinations$yldvar[combo],
price == combinations$price[combo],
elcprc == combinations$elcprc[combo]
)
# If by panel, put panels below in color and group.
tav_sp_plot <- ggplot(data = filtered_data,
mapping = aes(x = al_regs,
y = tav_profit,
color = factor(panels),
group = factor(panels))) +
geom_line() +
geom_point() +
facet_grid(height ~ array,
labeller = as_labeller(
c(
"4.6" = "4.6 ft. Height",
"6.4" = "6.4 ft. Height",
"8.2" = "8.2 ft. Height",
Tracking = "Single Axis Rotation",
Fixed = "Fixed Open Rack"
))) +
guides(color = guide_legend(ncol = 1,
reverse = TRUE)) +
scale_x_discrete(limits = c("Northern", "Central",
"Black Belt", "Southern"),
labels = c("North", "Center",
"B Belt", "South")) +
guides(color = guide_legend(ncol = 2,
reverse = TRUE)) +
labs(x = "Regions of Alabama",
y = "Profit ($) from Tomato Agrivoltaic System",
color = "Number of Solar \n Panels per Acre",
title = (list(combinations[combo,]))
) +
theme(strip.background = element_blank())
# Add horizontal line at y = 0 if y has both positive and negative values
if (min(filtered_data$tav_profit) < 0 &
max(filtered_data$tav_profit) > 0) {
tav_sp_plot <- tav_sp_plot +
geom_hline(yintercept = 0,
linewidth = 0.30,
linetype = "dashed",
color = "black")
}
print(combinations[combo,])
print(tav_sp_plot)
ggsave(file = paste0("Plots/tav_sp_R25", combo, ".png"))
#break
}
combinations <- expand.grid(
sprop = c(0, 0.25, 0.50, 0.75, 1.00), # Solar proportion
price = c(17, 20, 23), # Tomato price
elcprc = c(0.03, 0.04, 0.05) #Electricity price
)
# Iterate over the combinations and create the plots
for (combo in seq_len(nrow(combinations))) {
filtered_data <- tav_profit %>%
filter(
sprop == combinations$sprop[combo],
price == combinations$price[combo],
elcprc == combinations$elcprc[combo]
)
# If by yield, put yield below in color and group.
tav_yv_plot <- ggplot(data = filtered_data,
mapping = aes(x = al_regs,
y = tav_profit,
color = factor(yield),
group = factor(yield))) +
geom_line() +
geom_point() +
facet_grid(height ~ array,
labeller = as_labeller(
c(
"4.6" = "4.6 ft. Height",
"6.4" = "6.4 ft. Height",
"8.2" = "8.2 ft. Height",
Tracking = "Single Axis Rotation",
Fixed = "Fixed Open Rack"
))) +
guides(color = guide_legend(ncol = 1,
reverse = TRUE)) +
scale_x_discrete(limits = c("Northern", "Central",
"Black Belt", "Southern"),
labels = c("North", "Center",
"B Belt", "South")) +
guides(color = guide_legend(ncol = 2,
reverse = TRUE)) +
labs(x = "Regions of Alabama",
y = "Profit ($) from Tomato Agrivoltaic System",
color = "Tomato Yield \n (25 Lb Buckets)",
title = (list(combinations[combo,]))
) +
theme(strip.background = element_blank())
# Add horizontal line at y = 0 if y has both positive and negative values
if (min(filtered_data$tav_profit) < 0 &
max(filtered_data$tav_profit) > 0) {
tav_yv_plot <- tav_yv_plot +
geom_hline(yintercept = 0,
linewidth = 0.30,
linetype = "dashed",
color = "black")
}
print(combinations[combo,])
print(tav_yv_plot)
ggsave(file = paste0("Plots/tav_yv_R25", combo, ".png"))
#break
}
rm(combinations, combo)
rm(list = ls())
options(
warn=0,
scipen=999
)
library(tidyverse, warn.conflicts = FALSE, quietly = TRUE)
library(psych, warn.conflicts = FALSE, quietly = TRUE)
library(likert,  warn.conflicts = FALSE, quietly = TRUE)
library(mice,  warn.conflicts = FALSE, quietly = TRUE)
library(openxlsx2, warn.conflicts = FALSE, quietly = TRUE)
library(ggpubr, warn.conflicts = FALSE, quietly = TRUE)
library(gmodels,  warn.conflicts = FALSE, quietly = TRUE)
library(reshape2, warn.conflicts = FALSE, quietly = TRUE)
library(arrow, warn.conflicts = FALSE, quietly = TRUE)
library(plot3D, warn.conflicts = FALSE, quietly = TRUE)
library(plotly, warn.conflicts = FALSE, quietly = TRUE)
library(lattice, warn.conflicts = FALSE, quietly = TRUE)
library(purrr, warn.conflicts = FALSE, quietly = TRUE)
library(furrr, warn.conflicts = FALSE, quietly = TRUE)
library(pheatmap, warn.conflicts = FALSE, quietly = TRUE)
library(grid, warn.conflicts = FALSE, quietly = TRUE)
library(data.table, warn.conflicts = FALSE, quietly = TRUE)
library(parallel, warn.conflicts = FALSE, quietly = TRUE)
rm(list = ls())
options(warn=0, scipen=999)
library(tidyverse, warn.conflicts = FALSE, quietly = TRUE)
library(psych, warn.conflicts = FALSE, quietly = TRUE)
library(likert,  warn.conflicts = FALSE, quietly = TRUE)
library(mice,  warn.conflicts = FALSE, quietly = TRUE)
library(openxlsx2, warn.conflicts = FALSE, quietly = TRUE)
library(ggpubr, warn.conflicts = FALSE, quietly = TRUE)
library(gmodels,  warn.conflicts = FALSE, quietly = TRUE)
library(reshape2, warn.conflicts = FALSE, quietly = TRUE)
library(pacman,  warn.conflicts = FALSE, quietly = TRUE)
library(progress, warn.conflicts = FALSE, quietly = TRUE)
library(arrow, warn.conflicts = FALSE, quietly = TRUE)
####### Plotting Data: #####
# Map Theme:
plottheme <- ggplot() +
theme_void() +
# Mapping theme:
theme(axis.title = element_blank(),
axis.ticks = element_blank(),
axis.text = element_blank(),
panel.border = element_blank(),
plot.margin = margin(t = 0,
r = 0,
b = 0,
l = 0,
unit = "cm"),
plot.title = element_text(hjust = 0.5),
plot.background = element_rect(fill = "white",
color = "black",
linewidth = 0),
panel.background = element_rect(fill = "white",
color = "black",
linewidth = 0),
panel.grid.major.x = element_line(color = "lightgrey",
linetype = 2,
linewidth = 0),
panel.grid.minor.x = element_line(color = "lightgrey",
linetype = 2,
linewidth = 0),
panel.grid.major.y = element_line(color = "grey",
linetype = 2,
linewidth = 0),
panel.grid.minor.y = element_line(color = "grey",
linetype = 2,
linewidth = 0),
axis.line.x.top = element_line(color = "white",
linetype = 2,
linewidth = 0),
axis.line.y.right = element_line(color = "white",
linetype = 2,
linewidth = 0),
axis.line.x.bottom = element_line(color = "black",
linetype = 1,
linewidth = 0),
axis.line.y.left = element_line(color = "black",
linetype = 1,
linewidth = 0),
# Text formatting:
text = element_text(family = "serif", # font
size = 12, # font size
colour = "black"# font color
),
legend.key = element_rect(color = "black",
fill = NA,
linewidth = 0.05,
linetype = 1),
legend.justification = "right",
legend.direction = "horizontal")
tomato <- read_xlsx("Data/Parameters.xlsx",
sheet = "Tomato",
start_row = 2,
start_col = 9,
skip_empty_rows = TRUE,
skip_empty_cols = TRUE,
col_names = TRUE) %>%
rename(yield = Yield,
yldvar = `Yield Variation (%)`)
names(tav_profit)
elec_price <- read_xlsx("Data/Parameters.xlsx",
sheet = "Electricity Price") %>%
rename(epr_kwh = `Electricity Price ($/kWh)`)
elec_price <- read_xlsx("Data/Parameters.xlsx",
sheet = "Electricity Price") %>%
rename(epr_kwh = `Electricity Price ($/kWh)`)
elec_price <- read_xlsx("Data/Parameters.xlsx",
sheet = "Electricity Price") %>%
rename(epr_kwh = `Electricity Price ($/kWh)`)
