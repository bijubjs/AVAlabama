row_index <- 1
# Loop through each value of the second matrix
for (i in 1:nrow(matrix2)) {
# Loop through each value of the second matrix
for (j in 1:nrow(matrix1)) {
# First matrix, second matrix, combined two matrices.
new_row <- c(matrix1[j, ],
matrix2[i, ],
matrix1$energy[j] * matrix2$epr_kwh[i])
# Assign the new row to the result matrix
energy_revenue[row_index, ] <- new_row
# Increment the row index
row_index <- row_index + 1
}
# Name the columns
colnames(energy_revenue) <- c(colnames(matrix1), "elcprc", "elcrev")
# Display the result
dim(energy_revenue)
head(energy_revenue); tail(energy_revenue)
# Check for any NAs in the result
if(any(is.na(energy_revenue))) {
na_indices <- which(is.na(energy_revenue), arr.ind = TRUE)
print(paste("NAs found at rows:", unique(na_indices[, 1])))
} else {
print("No NAs found in the result data frame.")
}
# Chunk 19
## | results='hide'
# Sample data
set.seed(123)
matrix1 <- energy_output # dimension of matrix is 176*7
matrix2 <- elec_price # dimension of matrix is 11*1
# Initializing the result matrix
result_matrix <- data.frame(matrix(ncol = nrow(matrix2),
nrow = 0))
colnames(result_matrix) <- c(colnames(matrix1),  "elcrev", "elcprc")
# Loop to multiply first and second matrices
for (i in 1:nrow(matrix2)) {
temp_matrix <- matrix1
temp_matrix$E_Prc <- matrix2[i, ]
temp_matrix$E_Rev <- matrix1$energy[j] * matrix2$epr_kwh[i]
result_matrix <- rbind(result_matrix, temp_matrix)
}
# Display the resulting matrix
dim(result_matrix)
head(result_matrix)
tail(result_matrix)
# Chunk 20
lox <- c("Northern", "Central", "Black Belt", "Southern")
array_levs = c("Single Axis Rotation", "Fixed Open Rack")
datalot_levs = c("Location 1", "Location 2")
for (i in unique(energy_revenue$elcprc)) {
a = ggplot(data = (energy_revenue %>%
filter(elcprc == i)),
mapping = aes(x =al_regs,
y = elcrev,
#fill = energy,
color = factor(panels),
group = factor(panels)))+
geom_line()+
geom_point()+
facet_grid(.~array) +
scale_x_discrete(limits = lox) +
guides(color = guide_legend(reverse = TRUE))
cat("Electricity Price = ", i)
print(a)
}
# Chunk 21
lox <- c("Northern", "Central", "Black Belt", "Southern")
array_levs = c("Single Axis Rotation", "Fixed Open Rack")
datalot_levs = c("Location 1", "Location 2")
for (i in unique(energy_revenue$elcprc)) {
a = ggplot(data = (energy_revenue %>%
filter(elcprc == i)),
mapping = aes(x =al_regs,
y = elcrev,
#fill = energy,
color = factor(sprop),
group = factor(sprop)))+
geom_line()+
geom_point()+
facet_grid(.~array) +
scale_x_discrete(limits = lox) +
guides(color = guide_legend(reverse = TRUE))
cat("Electricity Price = ", i)
print(a)
}
# Chunk 22
cat("energy_revenue dimension = ", dim(energy_revenue)) # 1936*9
names(energy_revenue)
cat("capex = ", dim(capex)) # 6*3
names(capex)
# Chunk 23
expanded_data <- energy_revenue %>%
slice(rep(1:n(),
each = 3))
capex_height <- rep(unique(capex$height),
length.out = nrow(energy_revenue))
energy_cost = cbind(expanded_data, capex_height) %>%
rename(height = capex_height)
energy_cost <- left_join(energy_cost,
capex,
by = c("array", "height")) %>%
mutate(ttlcost = capex*dc_kw,
anncost = ttlcost*(0.05*(1 + 0.05)^25)/((1 + 0.05)^25 - 1),
moncost = ttlcost*((0.05/12)*(1 + (0.05/12))^(25*12))/((1 + (0.05/12))^(25*12) - 1))
dim(energy_cost)
head(energy_cost)
tail(energy_cost)
# Chunk 24
solar_profit <- energy_cost %>%
mutate(eprofit = elcrev - ttlcost,
eannprof = elcrev - anncost,
emonprof = (elcrev/12) - moncost)
dim(solar_profit)
head(solar_profit)
tail(solar_profit)
# Chunk 25
lox <- c("Northern", "Central", "Black Belt", "Southern")
array_levs = c("Single Axis Rotation", "Fixed Open Rack")
datalot_levs = c("Location 1", "Location 2")
for (i in unique(solar_profit$datalot)) {
for (j in unique(solar_profit$elcprc)) {
b = ggplot(
data = (solar_profit %>%
filter(datalot == i, elcprc == j)),
mapping = aes(
x = al_regs,
y = eprofit,
#fill = energy,
color = factor(panels),
group = factor(panels)
)
) +
geom_line() +
geom_point() +
facet_grid(height ~ array) +
scale_x_discrete(limits = lox) +
guides(color = guide_legend(reverse = TRUE))
cat("Datalot = ", i, "and ")
cat("Electricity Price = ", j)
print(b)
}
# Chunk 26
tomato_profit = tomato %>%
select(yldvar, yield,
rolac17, rolac18, rolac19, rolac20,
rolac21, rolac22, rolac23)
dim(tomato_profit)
tomato_profit
# Chunk 27
# Assign column names for clarity
colnames(tomato_profit) <- c("yldvar", "yield",
"rolac17", "rolac18", "rolac19",
"rolac20", "rolac21", "rolac22",
"rolac23")
# Reshape the data frame from wide to long format
tomato_long <- melt(tomato_profit,
id.vars = c("yldvar", "yield"),
measure.vars = c("rolac17", "rolac18", "rolac19",
"rolac20", "rolac21", "rolac22",
"rolac23"),
variable.name = "price",
value.name = "profit")
# Convert the 'Price' column to numeric by extracting the number
tomato_long$price <- as.numeric(gsub("rolac", "", tomato_long$price))
# View the resulting data frame
dim(tomato_long)
head(tomato_long)
tail(tomato_long)
# Chunk 28
ggplot(data = tomato_long,
mapping = aes(x = price,
y = profit,
color = factor(yldvar),
group = factor(yield))) +
geom_line() +
geom_point() +
geom_hline(yintercept = 0,
linetype = "dashed",
color = "black") +
guides(color = guide_legend(reverse = TRUE))
# Chunk 29
ggplot(data = tomato_long,
mapping = aes(x = yield,
y = profit,
#fill = yield,
color = factor(price),
group = factor(price))) +
geom_line() +
geom_point() +
geom_hline(yintercept = 0,
linetype = "dashed",
color = "black") +
# Vertical dashed line is 100% yield
geom_vline(xintercept = tomato_long$yield[11],
linetype = "dashed",
color = "black") +
guides(color = guide_legend(reverse = TRUE))
# Chunk 30
strawberry_profit = strawberry %>%
select(yldvar, yield,
rolac3, rolac4, rolac5, rolac6, rolac7, rolac8, rolac9)
dim(strawberry_profit)
strawberry_profit
# Chunk 31
# Assign column names for clarity
colnames(strawberry_profit) <- c("yldvar", "yield",
"rolac3", "rolac4", "rolac5",
"rolac6", "rolac7", "rolac8",
"rolac9")
# Reshape the data frame from wide to long format
stberry_long <- melt(strawberry_profit,
id.vars = c("yldvar", "yield"),
measure.vars = c("rolac3", "rolac4", "rolac5",
"rolac6", "rolac7", "rolac8",
"rolac9"),
variable.name = "price",
value.name = "profit")
# Convert the 'Price' column to numeric by extracting the number
stberry_long$price <- as.numeric(gsub("rolac", "", stberry_long$price))
# View the resulting data frame
dim(stberry_long)
head(stberry_long)
tail(stberry_long)
# Chunk 32
ggplot(data = stberry_long,
mapping = aes(x = price,
y = profit,
color = factor(yldvar),
group = factor(yield))) +
geom_line() +
geom_point() +
geom_hline(yintercept = 0,
linetype = "dashed",
color = "black") +
guides(color = guide_legend(reverse = TRUE))
# Chunk 33
ggplot(data = stberry_long,
mapping = aes(x = yield,
y = profit,
color = factor(price),
group = factor(price))) +
geom_line() +
geom_point() +
geom_hline(yintercept = 0,
linetype = "dashed",
color = "black") +
#Vertical dashed line is 100% yield
geom_vline(xintercept = stberry_long$yield[11],
linetype = "dashed",
color = "black") +
guides(color = guide_legend(reverse = TRUE))
# Chunk 34
squash_profit = squash %>%
select(yldvar, yield,
rolac11, rolac12, rolac13, rolac14,
rolac15, rolac16, rolac17)
squash_profit
# Chunk 35
# Assign column names for clarity
colnames(squash_profit) <- c("yldvar", "yield",
"rolac11", "rolac12", "rolac13",
"rolac14", "rolac15", "rolac16",
"rolac17")
# Reshape the data frame from wide to long format
squash_long <- melt(squash_profit,
id.vars = c("yldvar", "yield"),
measure.vars = c("rolac11", "rolac12", "rolac13",
"rolac14", "rolac15", "rolac16",
"rolac17"),
variable.name = "price",
value.name = "profit")
# Convert the 'Price' column to numeric by extracting the number
squash_long$price <- as.numeric(gsub("rolac", "", squash_long$price))
# View the resulting data frame
dim(squash_long)
head(squash_long)
tail(squash_long)
# Chunk 36
ggplot(data = squash_long,
mapping = aes(x = price,
y = profit,
color = factor(yldvar),
group = factor(yield))) +
geom_line() +
geom_point() +
geom_hline(yintercept = 0,
linetype = "dashed",
color = "black") +
guides(color = guide_legend(reverse = TRUE))
# Chunk 37
ggplot(data = squash_long,
mapping = aes(x = yield,
y = profit,
color = factor(price),
group = factor(price))) +
geom_line() +
geom_point() +
geom_hline(yintercept = 0,
linetype = "dashed",
color = "black") +
# Vertical dashed line is 100% yield
geom_vline(xintercept = squash_long$yield[11],
linetype = "dashed",
color = "black") +
guides(color = guide_legend(reverse = TRUE))
# Chunk 38
# Generate all combinations of row indices from both matrices
index_combinations <- expand.grid(1:nrow(solar_profit),
1:nrow(tomato_long))
# Define a function to process each combination of indices
process_combination <- function(indices) {
i <- indices[1]
j <- indices[2]
new_row <- c(solar_profit[i, ],
tomato_long[j, ],
#solar_profit[i, 14] = eannprof
solar_profit$eannprof[i] + tomato_long$profit[j])
return(new_row)
}
# Apply the function to each combination of indices and combine the results into a matrix
tav_profit <- do.call(rbind,
lapply(
seq_len(nrow(index_combinations)),
function(k) {
indices <- as.integer(
index_combinations[k, ])
process_combination(indices)
}))
# Optionally, you can convert the result back to a data frame if needed
tav_profit <- as.data.frame(tav_profit) %>%
rename(tav_profit = V21)
tav_profit <- data.frame(lapply(tav_profit, unlist))
str(tav_profit)
head(tav_profit)
tail(tav_profit)
# Chunk 39
#write_csv(tav_profit, "tav_profit.csv")
write_feather(tav_profit,
sink = "tav_profit.feather",
version = 2,
chunk_size = 65536L,
compression = c("default"),
#compression = c("default", "lz4", "lz4_frame", "uncompressed", "zstd"),
compression_level = NULL
)
# Chunk 40
# Generate all combinations of row indices from both matrices
index_combinations <- expand.grid(1:nrow(solar_profit),
1:nrow(stberry_long))
# Define a function to process each combination of indices
process_combination <- function(indices) {
i <- indices[1]
j <- indices[2]
new_row <- c(solar_profit[i, ],
stberry_long[j, ],
#solar_profit[i, 14] = eannprof
solar_profit$eannprof[i] + stberry_long$profit[j])
return(new_row)
}
# Apply the function to each combination of indices and combine the results into a matrix
sbav_profit <- do.call(rbind,
lapply(
seq_len(nrow(index_combinations)),
function(k) {
indices <- as.integer(
index_combinations[k, ])
process_combination(indices)
}))
# Optionally, you can convert the result back to a data frame if needed
sbav_profit <- as.data.frame(sbav_profit) %>%
rename(sbav_profit = V21)
sbav_profit <- data.frame(lapply(sbav_profit, unlist))
str(sbav_profit)
head(sbav_profit)
tail(sbav_profit)
# Chunk 41
#write_csv(sbav_profit, "tav_profit.csv")
write_feather(sbav_profit,
sink = "sbav_profit.feather",
version = 2,
chunk_size = 65536L,
compression = c("default"),
#compression = c("default", "lz4", "lz4_frame", "uncompressed", "zstd"),
compression_level = NULL
)
# Chunk 42
# Generate all combinations of row indices from both matrices
index_combinations <- expand.grid(1:nrow(solar_profit),
1:nrow(squash_long))
# Define a function to process each combination of indices
process_combination <- function(indices) {
i <- indices[1]
j <- indices[2]
new_row <- c(solar_profit[i, ],
squash_long[j, ],
#solar_profit[i, 14] = eannprof
solar_profit$eannprof[i] + squash_long$profit[j])
return(new_row)
}
# Apply the function to each combination of indices and combine the results into a matrix
sqav_profit <- do.call(rbind,
lapply(
seq_len(nrow(index_combinations)),
function(k) {
indices <- as.integer(
index_combinations[k, ])
process_combination(indices)
}))
# Optionally, you can convert the result back to a data frame if needed
sqav_profit <- as.data.frame(sqav_profit) %>%
rename(sqav_profit = V21)
sqav_profit <- data.frame(lapply(sqav_profit, unlist))
str(sqav_profit)
head(sqav_profit)
tail(sqav_profit)
# Chunk 43
#write_csv(sqav_profit, "tav_profit.csv")
write_feather(sqav_profit,
sink = "sqav_profit.feather",
version = 2,
chunk_size = 65536L,
compression = c("default"),
#compression = c("default", "lz4", "lz4_frame", "uncompressed", "zstd"),
compression_level = NULL
)
plottheme %>% ggplot(data = capex,
mapping = (aes(
x = height,
y = capex,
color = array,
group = array))) +
geom_point() +
geom_line() +
# geom_text(aes(label = "Tracker"),
#           nudge_x = 0.05,
#           nudge_y = 0.05,
#           size = 6) +
labs(
title = "CAPEX Cost by Solar Panel Height",
x = "Panel Height (ft.)",
y = "CAPEX Cost ($/W)",
color = "Array"
) +
scale_x_continuous(limits = c(4.5, 8.5)) +
scale_y_continuous(limits = c(1.5, 2.5)) +
guides(color = guide_legend(reverse = TRUE))
lox <- c("Northern", "Central", "Black Belt", "Southern")
array_levs = c("Single Axis Rotation", "Fixed Open Rack")
datalot_levs = c("Location 1", "Location 2")
for (i in unique(energy_revenue$elcprc)) {
a = ggplot(data = (energy_revenue %>%
filter(elcprc == i)),
mapping = aes(x =al_regs,
y = elcrev,
#fill = energy,
color = factor(sprop),
group = factor(sprop)))+
geom_line()+
geom_point()+
facet_grid(.~array) +
scale_x_discrete(limits = lox) +
guides(color = guide_legend(reverse = TRUE))
cat("Electricity Price = ", i)
print(a)
}
lox <- c("Northern", "Central", "Black Belt", "Southern")
array_levs = c("Single Axis Rotation", "Fixed Open Rack")
datalot_levs = c("Location 1", "Location 2")
for (i in unique(energy_revenue$elcprc)) {
a = ggplot(data = (energy_revenue %>%
filter(elcprc == i)),
mapping = aes(x =al_regs,
y = elcrev,
#fill = energy,
color = factor(sprop),
group = factor(sprop)))+
geom_line()+
geom_point()+
facet_grid(.~array) +
scale_x_discrete(limits = lox) +
guides(color = guide_legend(reverse = TRUE))
cat("Electricity Price = ", i)
print(a)
}
View(energy_revenue)
lox <- c("Northern", "Central", "Black Belt", "Southern")
array_levs = c("Single Axis Rotation", "Fixed Open Rack")
datalot_levs = c("Location 1", "Location 2")
for (j in unique(solar_profit$elcprc)) {
b = ggplot(
data = (solar_profit %>%
filter(elcprc == j)),
mapping = aes(
x = al_regs,
y = eprofit,
#fill = energy,
color = factor(panels),
group = factor(panels)
)
) +
geom_line() +
geom_point() +
facet_grid(height ~ array) +
scale_x_discrete(limits = lox) +
guides(color = guide_legend(reverse = TRUE))
cat("Datalot = ", i, "and ")
cat("Electricity Price = ", j)
print(b)
}
shiny::runGadget(sparklyr::connection_spark_shinyapp(), viewer = .rs.embeddedViewer)
