#width = 80,
#units = "in",
limitsize = FALSE,
file = paste0("Plots/gp_tav_pft", ".png"))
#rm(colorcount); rm(heatmap_plot)
# Define the values for each variable
sprop <- c(0, 0.05, 0.10, 0.15, 0.20, 0.25,
0.30, 0.35, 0.40, 0.45, 0.50,
0.55, 0.60, 0.65, 0.70, 0.75,
0.80, 0.85, 0.90, 0.95, 1.00)
array <- c("Fixed", "Tracking") # Solar Array
height <- c(4.6, 6.4, 8.2) # Panel height
yldvar <- c(0, 0.10, 0.20, 0.30, 0.40, 0.50, 0.60, 0.70, 0.80, 0.90,
1.00, 1.10, 1.20, 1.30, 1.40, 1.50, 1.60, 1.70, 1.80,
1.90, 2.00)
al_regs <- c("Northern", "Central", "Black Belt", "Southern") # Regions of AL
price <- c(17, 18, 19, 20, 21, 22, 23) # Crop Price
elcprc <- c(0.02, 0.03, 0.04) # Electricity Price
# Define the required columns
required_columns <- c("sprop", "array", "height",
"al_regs", "yldvar", "price", "elcprc")
# Check if the columns exist in tav_profit
missing_columns <- setdiff(required_columns,
names(tav_profit))
if (length(missing_columns) > 0) {
stop("Missing columns in tavp_wocp: ",
paste(missing_columns, collapse = ", "))
}
# Generate column names using reversed order of expand.grid
col_names <- apply(expand.grid(height, array, sprop), 1,
function(x) paste0(x[3], x[2], x[1]))
# Generate row names using reversed order of expand.grid
row_names <- apply(expand.grid(elcprc,
price,
yldvar,
al_regs), 1,
function(x) paste0(x, collapse = ""))
# Create an empty matrix to store the results
result_matrix <- matrix(NA, nrow = length(row_names),
ncol = length(col_names))
colnames(result_matrix) <- col_names
rownames(result_matrix) <- row_names
# Create a data frame with
# all combinations of parameters in reversed order
param_combinations <- expand.grid(elcprc = elcprc,
price = price,
yldvar = yldvar,
al_regs = al_regs,
height = height,
array = array,
sprop = sprop)
# Merge with tav_profit to get tav_profit values for each combination
merged_data <- merge(param_combinations,
tav_profit,
by = required_columns,
all.x = TRUE)
# Reshape merged_data to fill result_matrix with
# reversed column and row names
merged_data$col_name <- apply(
merged_data[, c("sprop", "array", "height")], 1,
function(x) paste0(x[1], x[2], x[3]))
merged_data$row_name <- apply(
merged_data[, c("al_regs", "yldvar", "price", "elcprc")], 1,
function(x) paste0(x[4],
x[3],
x[2],
x[1]))
# Fill the matrix with tav_profit values
for (i in seq_len(nrow(result_matrix))) {
row_condition <- rownames(result_matrix)[i]
row_data <- merged_data[
merged_data$row_name == row_condition, ]
if (nrow(row_data) > 0) {
result_matrix[i,
match(row_data$col_name,
colnames(result_matrix))] <- round(
row_data$tavp_wocp, 2)
}
ct_tavp_wocp <- as.data.frame(result_matrix) # Table in Excel.
rm(result_matrix)
dim(ct_tavp_wocp)
write.csv(as.data.frame(ct_tavp_wocp),
row.names = TRUE,
file = "Results/ct_tavp_wocp.csv")
colorcount = length(unique(as.vector(as.matrix(ct_tavp_wocp[-1]))))
colorcount
heatmap_plot <- pheatmap(t(ct_tavp_wocp),
#clustering_distance_rows = "correlation",
clustering_distance_rows = "euclidean",
clustering_distance_cols = "euclidean",
clustering_method = "complete",
color = colorRampPalette(c("red",
"yellow",
"green"))(colorcount),
#cutree_rows = 5,
#cutree_cols = 4,
cutree_rows = 5,
cutree_cols = 4,
cluster_rows = FALSE,
cluster_cols = FALSE,
show_rownames = FALSE,
show_colnames = FALSE,
display_numbers = FALSE,
number_format = "%.2f",
#cellheight = 3,
#cellwidth = 3
)
ggsave(heatmap_plot,
height = 8,
width = 12,
units = "in",
file = paste0("Plots/gp_tavp_wocp", ".png"))
rm(heatmap_plot); rm(colorcount)
# Define the values for each variable
sprop <- c(0.05, 0.10, 0.30, 0.50, 0.60, 0.70, 0.80, 0.85)
array <- c("Fixed", "Tracking") # Solar Array
height <- c(4.6, 6.4, 8.2) # Panel height
al_regs <- c("Northern", "Central", "Black Belt", "Southern")
price <- c(17, 20, 23) # Crop Price
elcprc <- c(0.02, 0.03, 0.04) # Electricity Price
yldvar <- c(0, 0.10, 0.20, 0.30, 0.40, 0.50, 0.60, 0.70, 0.80, 0.90, 1.00,
1.10, 1.20, 1.30, 1.40, 1.50, 1.60, 1.70, 1.80, 1.90, 2.00)
# Define the required columns
required_columns <- c("sprop", "array", "height",
"al_regs", "price", "elcprc")
# Check if the columns exist in tav_profit
missing_columns <- setdiff(required_columns,
names(tav_be_yld))
if (length(missing_columns) > 0) {
stop("Missing columns in tavp_be_yld: ",
paste(missing_columns, collapse = ", "))
}
# Generate column names using reversed order of expand.grid
col_names <- apply(expand.grid(height, array, sprop), 1,
function(x) paste0(x[3] , x[2] , x[1]))
# Generate row names using reversed order of expand.grid
row_names <- apply(expand.grid(elcprc,
price,
#yldvar,
al_regs), 1,
function(x) paste0(x, collapse = ""))
# Create an empty matrix to store the results
result_matrix <- matrix(NA, nrow = length(row_names),
ncol = length(col_names))
colnames(result_matrix) <- col_names
rownames(result_matrix) <- row_names
# Create a data frame with
# all combinations of parameters in reversed order
param_combinations <- expand.grid(elcprc = elcprc,
price = price,
#yldvar = yldvar,
al_regs = al_regs,
height = height,
array = array,
sprop = sprop)
# Merge with tav_be_yld to get tav_be_yld values for each combination
merged_data <- merge(param_combinations,
tav_be_yld,
by = required_columns,
all.x = TRUE)
# Reshape merged_data to fill result_matrix with
# reversed column and row names
merged_data$col_name <- apply(
merged_data[, c("sprop", "array", "height")], 1,
function(x) paste0(x[1], x[2], x[3]))
merged_data$row_name <- apply(
merged_data[, c("al_regs", "price", "elcprc")], 1,
function(x) paste0(x[3],
x[2],
x[1]))
# Fill the matrix with tav_profit values
for (i in seq_len(nrow(result_matrix))) {
row_condition <- rownames(result_matrix)[i]
row_data <- merged_data[
merged_data$row_name == row_condition, ]
if (nrow(row_data) > 0) {
result_matrix[i,
match(row_data$col_name,
colnames(result_matrix))] <- round(
row_data$yield, 0)
}
ct_tav_be_yld <- as.data.frame(result_matrix) # Table in Excel.
write.csv(as.data.frame(ct_tav_be_yld),
row.names = TRUE,
file = "Results/ct_tav_be_yld.csv")
dim(ct_tav_be_yld)
rm(result_matrix)
uniquevalue = unique(as.vector(as.matrix(ct_tav_be_yld[-1])))
uniquevalue
colorcount = length(unique(as.vector(as.matrix(ct_tav_be_yld[-1]))))
colorcount
heatmap_plot <- pheatmap((ct_tav_be_yld),
#clustering_distance_rows = "correlation",
clustering_distance_rows = "euclidean",
clustering_distance_cols = "euclidean",
clustering_method = "complete",
angle_col = 90,
na_col = "white",
color = colorRampPalette(c("green",
"yellow",
"red"))(colorcount),
cellheight = 13,
cellwidth = 14,
fontsize = 12,
fontsize_row = 12,
fontsize_col = 12,
number_color = "white",
fontsize_number = 5,
cluster_rows = FALSE,
cluster_cols = FALSE,
show_rownames = TRUE,
show_colnames = TRUE,
display_numbers = TRUE,
number_format = "%.0f"
#legend_breaks = uniquevalue
)
uniquevalue = unique(as.vector(as.matrix(ct_tav_be_yld[-1])))
uniquevalue
colorcount = length(unique(as.vector(as.matrix(ct_tav_be_yld[-1]))))
colorcount
heatmap_plot <- pheatmap((ct_tav_be_yld),
#clustering_distance_rows = "correlation",
clustering_distance_rows = "euclidean",
clustering_distance_cols = "euclidean",
clustering_method = "complete",
angle_col = 90,
na_col = "white",
color = colorRampPalette(c("green",
"yellow",
"red"))(colorcount),
cellheight = 13,
cellwidth = 14,
fontsize = 12,
fontsize_row = 12,
fontsize_col = 12,
number_color = "white",
fontsize_number = 5,
cluster_rows = FALSE,
cluster_cols = FALSE,
show_rownames = TRUE,
show_colnames = TRUE,
display_numbers = TRUE,
number_format = "%.0f"
#legend_breaks = uniquevalue
)
rm(list = ls()) # Clean the environment.
options(
warn=0, # Warnings. options(warn=-1) / options(warn=0)
scipen=999 # No scientific notations.
)
library(conflicted, warn.conflicts = FALSE, quietly = TRUE)
library(tidyverse, warn.conflicts = FALSE, quietly = TRUE)
library(psych, warn.conflicts = FALSE, quietly = TRUE)
library(likert, warn.conflicts = FALSE, quietly = TRUE) # Likert Items
library(mice, warn.conflicts = FALSE, quietly = TRUE)
library(openxlsx2, warn.conflicts = FALSE, quietly = TRUE)
library(ggpubr, warn.conflicts = FALSE, quietly = TRUE) # Scatter plot
library(gmodels, warn.conflicts = FALSE, quietly = TRUE) # Crosstab
library(reshape2, warn.conflicts = FALSE, quietly = TRUE) # Reshape data
library(tidyUSDA, warn.conflicts = FALSE, quietly = TRUE) #AG Census
library(usdarnass, warn.conflicts = FALSE, quietly = TRUE) #AG Census
library(arrow, warn.conflicts = FALSE, quietly = TRUE) # Squeeze Data
rm(list = ls()) # Clean the environment.
options(
warn=0, # Warnings. options(warn=-1) / options(warn=0)
scipen=999 # No scientific notations.
)
library(conflicted, warn.conflicts = FALSE, quietly = TRUE)
library(tidyverse, warn.conflicts = FALSE, quietly = TRUE)
library(psych, warn.conflicts = FALSE, quietly = TRUE)
library(likert, warn.conflicts = FALSE, quietly = TRUE) # Likert Items
library(mice, warn.conflicts = FALSE, quietly = TRUE)
library(openxlsx2, warn.conflicts = FALSE, quietly = TRUE)
library(ggpubr, warn.conflicts = FALSE, quietly = TRUE) # Scatter plot
library(gmodels, warn.conflicts = FALSE, quietly = TRUE) # Crosstab
library(reshape2, warn.conflicts = FALSE, quietly = TRUE) # Reshape data
library(tidyUSDA, warn.conflicts = FALSE, quietly = TRUE) #AG Census
library(usdarnass, warn.conflicts = FALSE, quietly = TRUE) #AG Census
library(arrow, warn.conflicts = FALSE, quietly = TRUE) # Squeeze Data
years <- c("2007", "2017")
alzips_list <- list()
for (year in years) {
alzips <- getQuickstat(
key = "2F2751E2-587A-378D-8CD7-00BF79C0FFD9", # API Key
program = "census",
sector = NULL,
group = NULL,
commodity = NULL,
category = NULL,
data_item = NULL,
#data_item = "PRODUCERS, MALE - NUMBER OF OPERATIONS",
#domain = "TOTAL",
domain = NULL,
geographic_level = "zip code",
state = "alabama",
county = NULL,
year = year,
geometry = TRUE, # sf @ geog_lev=STATE/COUNTY
lower48 = FALSE,
weighted_by_area = FALSE
)
alzips_list[[year]] <- alzips
}
combined_alzips <- bind_rows(alzips_list,
.id = "year")
str(combined_alzips)
head(combined_alzips); tail(combined_alzips)
alcty1997 = getQuickstat(
key = "2F2751E2-587A-378D-8CD7-00BF79C0FFD9", #API Key
program = "census",
sector = NULL,
group = NULL,
commodity = NULL,
category = NULL,
data_item = NULL,
#data_item = "PRODUCERS, MALE - NUMBER OF OPERATIONS",
#domain = "TOTAL",
domain = NULL,
geographic_level = "county",
state = "alabama",
county = NULL,
year = "1997",
geometry = TRUE, #sf @ geog_lev=STATE/COUNTY
lower48 = FALSE,
weighted_by_area = FALSE #
)
head(alcty1997); tail(alcty1997)
alcty2002 = getQuickstat(
key = "2F2751E2-587A-378D-8CD7-00BF79C0FFD9", #API Key
program = "census",
sector = "economics",
group = NULL,
commodity = NULL,
category = NULL,
data_item = NULL,
#data_item = "PRODUCERS, MALE - NUMBER OF OPERATIONS",
#domain = "TOTAL",
domain = NULL,
geographic_level = "county",
state = "alabama",
county = NULL,
year = "2002",
geometry = TRUE, #sf @ geog_lev=STATE/COUNTY
lower48 = FALSE,
weighted_by_area = FALSE
)
head(alcty2002); tail(alcty2002)
# Define the values for each variable
sprop <- c(0, 0.05, 0.10, 0.15, 0.20, 0.25,
0.30, 0.35, 0.40, 0.45, 0.50,
0.55, 0.60, 0.65, 0.70, 0.75,
0.80, 0.85, 0.90, 0.95, 1.00)
array <- c("Fixed", "Tracking") # Solar Array
height <- c(4.6, 6.4, 8.2) # Panel height
yldvar <- c(0, 0.10, 0.20, 0.30, 0.40, 0.50, 0.60, 0.70, 0.80, 0.90,
1.00, 1.10, 1.20, 1.30, 1.40, 1.50, 1.60, 1.70, 1.80,
1.90, 2.00)
al_regs <- c("Northern", "Central", "Black Belt", "Southern") # Regions of AL
price <- c(17, 18, 19, 20, 21, 22, 23) # Crop Price
elcprc <- c(0.02, 0.03, 0.04) # Electricity Price
# Define the required columns
required_columns <- c("sprop", "array", "height",
"al_regs", "yldvar", "price", "elcprc")
# Check if the columns exist in tav_profit
missing_columns <- setdiff(required_columns,
names(tav_profit))
# #| echo: TRUE
rm(list = ls()) # Clean the environment.
options(
warn=0, # Warnings. options(warn=-1) / options(warn=0)
scipen=999 # No scientific notations.
)
path_mac = "/Users/bmishra/Library/CloudStorage/OneDrive-AuburnUniversity/Collaboration/Ngbede M/Choice-paper"
path_office = "Users\\bzm0094\\OneDrive - Auburn University\\Collaboration\\Ngbede M\\Choice-paper"
ifelse(Sys.info()[6] == "bmishra",
setwd(path_mac),
setwd(path_office))
library(tidyverse, warn.conflicts = FALSE, quietly = TRUE)
library(psych, warn.conflicts = FALSE, quietly = TRUE)
library(likert,  warn.conflicts = FALSE, quietly = TRUE) # Likert Items
library(mice,  warn.conflicts = FALSE, quietly = TRUE)
library(openxlsx2, warn.conflicts = FALSE, quietly = TRUE)
library(ggpubr, warn.conflicts = FALSE, quietly = TRUE) # Scatter plot
library(gmodels,  warn.conflicts = FALSE, quietly = TRUE) # Crosstab
library(reshape2, warn.conflicts = FALSE, quietly = TRUE) # Reshape data
library(arrow, warn.conflicts = FALSE, quietly = TRUE) # Feather
library(plot3D, warn.conflicts = FALSE, quietly = TRUE)
library(plotly, warn.conflicts = FALSE, quietly = TRUE) # 3D plotting
library(lattice, warn.conflicts = FALSE, quietly = TRUE)
library(purrr, warn.conflicts = FALSE, quietly = TRUE)
library(furrr, warn.conflicts = FALSE, quietly = TRUE)
library(pheatmap, warn.conflicts = FALSE, quietly = TRUE)
library(grid, warn.conflicts = FALSE, quietly = TRUE)
library(data.table, warn.conflicts = FALSE, quietly = TRUE)
library(parallel, warn.conflicts = FALSE, quietly = TRUE)
tav_profit <- as.data.frame(
read_feather(file = "Data/tav_profit.feather")
)
#str(tav_profit)
#head(tav_profit); head(tav_profit)
dim(tav_profit)
# Calculate the profit:
# Step 1: Filter the dataframe to get the unique profit values for each price when yldvar is 1
unique_profits <- unique(tav_profit[tav_profit$yldvar == 1,
c("price", "profit")])
# Step 2: Create a lookup table for unique profits by price
profit_lookup <- setNames(unique_profits$profit,
unique_profits$price)
# Step 3: Create the new variable tavp_wocp by subtracting the unique profit from tav_profit
tav_profit$tavp_wocp <- mapply(function(
tav_profit,
price
) {
profit_to_subtract <- ifelse(
price %in%
names(profit_lookup),
profit_lookup[as.character(price)], 0)
return(tav_profit - profit_to_subtract)
}, tav_profit$tav_profit, tav_profit$price)
unique_profits # 7 Prices give 7 Profits at 100% Yield.
tav_profit[1:21,] # Sample data.
rm(unique_profits); rm(profit_lookup)
tav_profit$tavp_wosp <- tav_profit$tav_profit - tav_profit$eannprof
# Convert the data frame to a data.table for faster operations
setDT(tav_profit)
# Function to process each subset
process_subset <- function(subset) {
subset <- subset[order(-tavp_wocp)]
# Find the row where yield changes from positive to negative
change_row <- which(diff(sign(subset$tavp_wocp)) == -2)[1]
# Check if change_row is not NA
if (!is.na(change_row)) {
result_row <- subset[change_row, ]
return(result_row)
} else {
return(NULL)
}
# Split data by unique combinations of the filtering criteria
split_data <- split(tav_profit,
by = c("al_regs", "array", "sprop",
"elcprc", "price", "height"))
# Apply the process_subset function in parallel
results <- mclapply(split_data,
process_subset,
mc.cores = detectCores())
# Combine all results into a single data.table
tav_be_yld <- rbindlist(results,
use.names = TRUE,
fill = TRUE) %>%
select(al_regs, array, sprop,panels, elcprc, price,
height, profit, yldvar, yield, tav_profit, tavp_wocp, tavp_wosp)
rm(results); rm(split_data); rm(process_subset)
write.csv(as.data.frame(tav_be_yld),
row.names = TRUE,
#col.names = TRUE,
file = "Results/tav_brkevn_yield.csv")
dim(tav_be_yld)
# Convert the data frame to a data.table for faster operations
setDT(tav_profit)
# Function to process each subset
process_subset <- function(subset) {
subset <- subset[order(-tavp_wosp)]
# Find the row where yield changes from positive to negative
change_row <- which(diff(sign(subset$tavp_wosp)) == -2)[1]
# Check if change_row is not NA
if (!is.na(change_row)) {
result_row <- subset[change_row, ]
return(result_row)
} else {
return(NULL)
}
# Split data by unique combinations of the filtering criteria
split_data <- split(tav_profit,
by = c("al_regs", "array", "sprop",
"elcprc", "price", "height"))
# Apply the process_subset function in parallel
results <- mclapply(split_data,
process_subset,
mc.cores = detectCores())
# Combine all results into a single data.table
tav_be_pden <- rbindlist(results,
use.names = TRUE,
fill = TRUE) %>%
select(al_regs, array, sprop,panels, elcprc, price,
height, profit, yldvar, yield, tav_profit, tavp_wosp)
rm(results); rm(split_data); rm(process_subset)
write.csv(as.data.frame(tav_be_pden),
row.names = TRUE,
#col.names = TRUE,
file = "Results/tav_brkevn_pden.csv")
dim(tav_be_pden)
sbav_profit <- as.data.frame(
read_feather(file = "Data/sbav_profit.feather")
)
#str(sbav_profit)
#head(sbav_profit); tail(sbav_profit)
dim(sbav_profit)
# Calculate the profit:
# Step 1: Filter the dataframe to get the unique profit values for each price when yldvar is 1
unique_profits <- unique(sbav_profit[sbav_profit$yldvar == 1,
c("price", "profit")])
# Step 2: Create a lookup table for unique profits by price
profit_lookup <- setNames(unique_profits$profit,
unique_profits$price)
# Step 3: Create the new variable sbavp_wocp by subtracting the unique profit from sqav_profit
sbav_profit$sbavp_wocp <- mapply(function(sbav_profit, price) {
profit_to_subtract <- ifelse(price %in%
names(profit_lookup),
profit_lookup[as.character(price)], 0)
return(sbav_profit - profit_to_subtract)
}, sbav_profit$sbav_profit, sbav_profit$price)
rm(unique_profits); rm(profit_lookup)
