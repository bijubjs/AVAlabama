"al_regs", "price", "elcprc")
# Check if the columns exist in tav_profit
missing_columns <- setdiff(required_columns,
names(tav_be_yld))
if (length(missing_columns) > 0) {
stop("Missing columns in tavp_be_yld: ",
paste(missing_columns, collapse = ", "))
}
# Generate column names using reversed order of expand.grid
col_names <- apply(expand.grid(height, array, sprop), 1,
function(x) paste0(x[3] , x[2] , x[1]))
# Generate row names using reversed order of expand.grid
row_names <- apply(expand.grid(elcprc,
price,
#yldvar,
al_regs), 1,
function(x) paste0(x, collapse = ""))
# Create an empty matrix to store the results
result_matrix <- matrix(NA, nrow = length(row_names),
ncol = length(col_names))
colnames(result_matrix) <- col_names
rownames(result_matrix) <- row_names
# Create a data frame with
# all combinations of parameters in reversed order
param_combinations <- expand.grid(elcprc = elcprc,
price = price,
#yldvar = yldvar,
al_regs = al_regs,
height = height,
array = array,
sprop = sprop)
# Merge with tav_be_yld to get tav_be_yld values for each combination
merged_data <- merge(param_combinations,
tav_be_yld,
by = required_columns,
all.x = TRUE)
# Reshape merged_data to fill result_matrix with
# reversed column and row names
merged_data$col_name <- apply(
merged_data[, c("sprop", "array", "height")], 1,
function(x) paste0(x[1], x[2], x[3]))
merged_data$row_name <- apply(
merged_data[, c("al_regs", "price", "elcprc")], 1,
function(x) paste0(x[3],
x[2],
x[1]))
# Fill the matrix with tav_profit values
for (i in seq_len(nrow(result_matrix))) {
row_condition <- rownames(result_matrix)[i]
row_data <- merged_data[
merged_data$row_name == row_condition, ]
if (nrow(row_data) > 0) {
result_matrix[i,
match(row_data$col_name,
colnames(result_matrix))] <- round(
row_data$yield, 0)
}
}
ct_tav_be_yld <- as.data.frame(result_matrix) # Table in Excel.
dim(ct_tav_be_yld); rm(result_matrix)
uniquevalue = unique(as.vector(as.matrix(ct_tav_be_yld[-1])))
uniquevalue
colorcount = length(unique(as.vector(as.matrix(ct_tav_be_yld[-1]))))
colorcount
heatmap_plot <- pheatmap((ct_tav_be_yld),
#clustering_distance_rows = "correlation",
clustering_distance_rows = "euclidean",
clustering_distance_cols = "euclidean",
clustering_method = "complete",
angle_col = 90,
na_col = "white",
color = colorRampPalette(
c("green", "yellow","red")
)(colorcount),
cellheight = 13,
cellwidth = 14,
fontsize = 12,
fontsize_row = 12,
fontsize_col = 12,
number_color = "white",
fontsize_number = 5,
cluster_rows = FALSE,
cluster_cols = FALSE,
show_rownames = TRUE,
show_colnames = TRUE,
display_numbers = TRUE,
number_format = "%.0f"
#legend_breaks = uniquevalue
)
# Define the values for each variable
sprop <- c(0, 0.10, 0.20, 0.30, 0.40, 0.50,
0.60, 0.70, 0.80, 0.90, 1.00)
array <- c("Fixed", "Tracking")
height <- c(4.6, 6.4, 8.2)
# yldvar <- c(0, 0.10, 0.20, 0.30, 0.40, 0.50,
#             0.60, 0.70, 0.80, 0.90, 1.00,
#             1.10, 1.20, 1.30, 1.40, 1.50,
#             1.60, 1.70, 1.80, 1.90, 2.00)
yldvar <- c(0.5, 1, 1.5)
al_regs <- c("Northern", "Central",
"Black Belt", "Southern")
price <- c(3, 6, 9)
elcprc <- c(0.04) # Electricity Price
# Define the required columns
required_columns <- c("sprop", "array", "height",
"al_regs", "yldvar", "price", "elcprc")
# Check if the columns exist in sbav_profit
missing_columns <- setdiff(required_columns,
names(sbav_profit))
if (length(missing_columns) > 0) {
stop("Missing columns in sbav_profit: ",
paste(missing_columns, collapse = ", "))
}
# Generate column names using reversed order of expand.grid
col_names <- apply(expand.grid(height, array, sprop), 1,
function(x) paste0(x[3], x[2], x[1]))
# Generate row names using reversed order of expand.grid
row_names <- apply(expand.grid(elcprc,
price,
yldvar,
al_regs), 1,
function(x) paste0(x, collapse = ""))
# Create an empty matrix to store the results
result_matrix <- matrix(NA,
nrow = length(row_names),
ncol = length(col_names))
colnames(result_matrix) <- col_names
rownames(result_matrix) <- row_names
# Create a data frame with
# all combinations of parameters in reversed order
param_combinations <- expand.grid(elcprc = elcprc,
price = price,
yldvar = yldvar,
al_regs = al_regs,
height = height,
array = array,
sprop = sprop)
# Merge with tav_profit to get sbav_profit values for each combination
merged_data <- merge(param_combinations,
sbav_profit,
by = required_columns,
all.x = TRUE)
# Reshape merged_data to fill result_matrix with
# reversed column and row names
merged_data$col_name <- apply(
merged_data[, c("sprop", "array", "height")], 1,
function(x) paste0(x[1],
x[2],
x[3]))
merged_data$row_name <- apply(
merged_data[, c("al_regs", "yldvar", "price", "elcprc")], 1,
function(x) paste0(x[4],
x[3],
x[2],
x[1]))
# Fill the matrix with sbav_profit values
for (i in seq_len(nrow(result_matrix))) {
row_condition <- rownames(result_matrix)[i]
row_data <- merged_data[
merged_data$row_name == row_condition, ]
if (nrow(row_data) > 0) {
result_matrix[i,
match(row_data$col_name,
colnames(result_matrix))] <- round(
row_data$sbav_profit, 2)
}
}
ct_sbav_pft <- as.data.frame(result_matrix) #Table in Excel.
# Display the result matrix
ct_sbav_pft <- as.data.frame(result_matrix) # Table in Excel.
rm(result_matrix); rm(sprop); rm(array); rm(height);
rm(elcprc); rm(price); rm(yldvar); rm(al_regs)
write_xlsx(x = ct_sbav_pft %>%
dplyr::mutate(Row_Names = rownames(ct_sbav_pft)) %>%
dplyr::select(Row_Names, everything()),
file = "Results/Profit Ctab SBAV.xlsx",
as_table = TRUE)
dim(ct_sbav_pft)
# Calculate color count based on unique values, excluding zero
colorcount <- length(unique(as.vector(as.matrix(ct_sbav_pft[-1]))))
# Define custom breaks to ensure zero is distinctly marked
# Calculate min and max values to define the range
min_val <- min(ct_sbav_pft, na.rm = TRUE)
max_val <- max(ct_sbav_pft, na.rm = TRUE)
# Create breaks that ensure zero is in the middle
breaks <- seq(min_val, max_val, length.out = colorcount)
# Separate color palettes for negative and positive values
# Negative values: Shades of red
neg_colors <- colorRampPalette(c("#890800",
"#FF1709",
"#FF8F89"))(sum(breaks < 0))
# Define the color for zero separately
zero_color <- "#FF8F89"
# Positive values: Shades of green
pos_colors <- colorRampPalette(c("#99E699",
"#32CD32",
"#196719"))(sum(breaks > 0))
# Combine negative colors, zero, and positive colors
custom_colors <- c(neg_colors,
zero_color,
pos_colors)
# Generate heatmap with the custom color scheme
heatmap_plot <- pheatmap(
(ct_sbav_pft),
clustering_distance_rows = "euclidean",
clustering_distance_cols = "euclidean",
clustering_method = "complete",
angle_col = 90,
na_col = "white",
color = custom_colors,
breaks = breaks,
cutree_rows = 5,
cutree_cols = 4,
cluster_rows = FALSE,
cluster_cols = FALSE,
show_rownames = TRUE,
show_colnames = TRUE,
display_numbers = FALSE,
number_format = "%.2f",
cellheight = 18,
cellwidth = 18,
fontsize = 18,
fontsize_row = 20,
fontsize_col = 20
)
ggsave(heatmap_plot,
height = 18,
width = 24,
units = "in",
limitsize = FALSE,
file = paste0("Plots/SBAV Profits Ctab", ".png"))
rm(heatmap_plot);
# Define the values for each variable
sprop <- c(0, 0.25, 0.50, 0.75, 1.00)
array <- c("Fixed", "Tracking") # Solar Array
height <- c(4.6, 6.4, 8.2) # Panel height
yldvar <- c(1) # Yield Variability
al_regs <- c("Northern", "Central", "Black Belt", "Southern")
price <- c(9) # Crop Price
elcprc <- c(0.04) # Electricity Price
# Define the required columns
required_columns <- c("sprop", "array", "height",
"al_regs", "yldvar", "price", "elcprc")
# Check if the columns exist in tav_profit
missing_columns <- setdiff(required_columns,
names(sbav_profit))
if (length(missing_columns) > 0) {
stop("Missing columns in tav_profit: ",
paste(missing_columns,
collapse = ", "))
}
# Generate column names using reversed order of expand.grid
col_names <- apply(expand.grid(height, sprop), 1,
function(x) paste0(x[2], x[1]))
# Generate row names using reversed order of expand.grid
row_names <- apply(expand.grid(elcprc,
price,
yldvar,
al_regs,
array), 1,
function(x) paste0(x, collapse = ""))
# Create an empty matrix to store the results
result_matrix <- matrix(NA,
nrow = length(row_names),
ncol = length(col_names))
colnames(result_matrix) <- col_names
rownames(result_matrix) <- row_names
# Create a data frame with
# all combinations of parameters in reversed order
param_combinations <- expand.grid(elcprc = elcprc,
price = price,
yldvar = yldvar,
al_regs = al_regs,
height = height,
array = array,
sprop = sprop)
# Merge with tav_profit to get tav_profit values for each combination
merged_data <- merge(param_combinations,
sbav_profit,
by = required_columns,
all.x = TRUE)
# Reshape merged_data to fill result_matrix with
# reversed column and row names
merged_data$col_name <- apply(
merged_data[, c("sprop", "height")], 1,
function(x) paste0(x[1], x[2]))
merged_data$row_name <- apply(
merged_data[, c("al_regs", "yldvar", "price",
"elcprc", "array")], 1,
function(x) paste0(
x[4],
x[3],
x[2],
x[1],
x[5]))
# Fill the matrix with tav_profit values
for (i in seq_len(nrow(result_matrix))) {
row_condition <- rownames(result_matrix)[i]
row_data <- merged_data[
merged_data$row_name == row_condition, ]
if (nrow(row_data) > 0) {
result_matrix[i,
match(row_data$col_name,
colnames(result_matrix))] <- round(
row_data$sbav_profit, 0)
}
}
sbav_prof_man <- as.data.frame(result_matrix) # Table in Excel.
write_xlsx(x = sbav_prof_man %>%
dplyr::mutate(Row_Names = rownames(sbav_prof_man)) %>%
dplyr::select(Row_Names, everything()),
file = "Results/Profit SBAV Manuscript.xlsx",
as_table = TRUE)
# Display the result matrix
rm(result_matrix); rm(sprop); rm(array); rm(height);
rm(elcprc); rm(price); rm(yldvar); rm(al_regs)
# Define the values for each variable
sprop <- c(0, 0.05, 0.10, 0.15, 0.20, 0.25, 0.30, 0.35, 0.40, 0.45, 0.50,
0.55, 0.60, 0.65, 0.70, 0.75, 0.80, 0.85, 0.90, 0.95, 1.00)
array <- c("Fixed", "Tracking")
height <- c(4.6, 6.4, 8.2)
yldvar <- c(0, 0.10, 0.20, 0.30, 0.40, 0.50, 0.60, 0.70, 0.80, 0.90, 1.00,
1.10, 1.20, 1.30, 1.40, 1.50, 1.60, 1.70, 1.80, 1.90, 2.00)
al_regs <- c("Northern", "Central", "Black Belt", "Southern")
price <- c(3, 4, 5, 6, 7, 8, 9)
elcprc <- c(0.03, 0.04, 0.05)
# Define the required columns
required_columns <- c("sprop", "array", "height",
"al_regs", "yldvar", "price", "elcprc")
# Check if the columns exist in sbav_profit
missing_columns <- setdiff(required_columns,
names(sbav_profit))
if (length(missing_columns) > 0) {
stop("Missing columns in sbav_profit: ",
paste(missing_columns, collapse = ", "))
}
# Generate column names using reversed order of expand.grid
col_names <- apply(expand.grid(height, array, sprop), 1,
function(x) paste0(x[3], x[2], x[1]))
# Generate row names using reversed order of expand.grid
row_names <- apply(expand.grid(elcprc,
price,
yldvar,
al_regs), 1,
function(x) paste0(x, collapse = ""))
# Create an empty matrix to store the results
result_matrix <- matrix(NA, nrow = length(row_names),
ncol = length(col_names))
colnames(result_matrix) <- col_names
rownames(result_matrix) <- row_names
# Create a data frame with
# all combinations of parameters in reversed order
param_combinations <- expand.grid(elcprc = elcprc,
price = price,
yldvar = yldvar,
al_regs = al_regs,
height = height,
array = array,
sprop = sprop)
# Merge with tav_profit to get sbav_profit values for each combination
merged_data <- merge(param_combinations,
sbav_profit,
by = required_columns,
all.x = TRUE)
# Reshape merged_data to fill result_matrix with
# reversed column and row names
merged_data$col_name <- apply(
merged_data[, c("sprop", "array", "height")], 1,
function(x) paste0(x[1],
x[2],
x[3]))
merged_data$row_name <- apply(
merged_data[, c("al_regs", "yldvar", "price", "elcprc")], 1,
function(x) paste0(x[4],
x[3],
x[2],
x[1]))
# Fill the matrix with sbav_profit values
for (i in seq_len(nrow(result_matrix))) {
row_condition <- rownames(result_matrix)[i]
row_data <- merged_data[
merged_data$row_name == row_condition, ]
if (nrow(row_data) > 0) {
result_matrix[i,
match(row_data$col_name,
colnames(result_matrix))] <- round(
row_data$sbavp_wocp, 2)
}
}
ct_sbavp_wocp <- as.data.frame(result_matrix) #Table in Excel.
rm(result_matrix)
colorcount = length(unique(as.vector(as.matrix(ct_sbavp_wocp[-1]))))
colorcount
heatmap_plot <- pheatmap(t(ct_sbavp_wocp),
#clustering_distance_rows = "correlation",
clustering_distance_rows = "euclidean",
clustering_distance_cols = "euclidean",
clustering_method = "complete",
color = colorRampPalette(c("red",
"yellow",
"green"))(colorcount),
#cutree_rows = 5,
#cutree_cols = 4,
cluster_rows = FALSE,
cluster_cols = FALSE,
show_rownames = FALSE,
show_colnames = FALSE,
display_numbers = FALSE,
number_format = "%.2f",
#cellheight = 3,
#cellwidth = 3
)
sprop <- c(0.05, 0.25, 0.50, 0.75, 0.80, 0.85, 0.90, 1)
array <- c("Fixed", "Tracking") # Solar Array
height <- c(4.6, 6.4, 8.2) # Panel height
al_regs <- c("Northern", "Central", "Black Belt", "Southern")
price <- c(3, 6, 9)
elcprc <- c(0.02, 0.03, 0.04) # Electricity Price
yldvar <- c(0, 0.10, 0.20, 0.30, 0.40,
0.50, 0.60, 0.70, 0.80, 0.90, 1.00,
1.10, 1.20, 1.30, 1.40, 1.50, 1.60,
1.70, 1.80, 1.90, 2.00)
# Define the required columns
required_columns <- c("sprop", "array", "height",
"al_regs", "price", "elcprc")
# Check if the columns exist in sbav_profit
missing_columns <- setdiff(required_columns,
names(sbav_be_yld))
if (length(missing_columns) > 0) {
stop("Missing columns in sbav_be_yld: ",
paste(missing_columns, collapse = ", "))
}
# Generate column names using reversed order of expand.grid
col_names <- apply(expand.grid(height, array, sprop), 1,
function(x) paste0(x[3], x[2], x[1]))
# Generate row names using reversed order of expand.grid
row_names <- apply(expand.grid(elcprc,
price,
al_regs), 1,
function(x) paste0(x, collapse = ""))
# Create an empty matrix to store the results
result_matrix <- matrix(NA, nrow = length(row_names),
ncol = length(col_names))
colnames(result_matrix) <- col_names
rownames(result_matrix) <- row_names
# Create a data frame with
# all combinations of parameters in reversed order
param_combinations <- expand.grid(elcprc = elcprc,
price = price,
al_regs = al_regs,
height = height,
array = array,
sprop = sprop)
# Merge with tavp_be_yld to get tavp_be_yld values for each combination
merged_data <- merge(param_combinations,
sbav_be_yld,
by = required_columns,
all.x = TRUE)
# Reshape merged_data to fill result_matrix with
# reversed column and row names
merged_data$col_name <- apply(
merged_data[, c("sprop", "array", "height")], 1,
function(x) paste0(x[1], x[2], x[3]))
merged_data$row_name <- apply(
merged_data[, c("al_regs", "price", "elcprc")], 1,
function(x) paste0(x[3],
x[2],
x[1]))
# Fill the matrix with sbav_profit values
for (i in seq_len(nrow(result_matrix))) {
row_condition <- rownames(result_matrix)[i]
row_data <- merged_data[
merged_data$row_name == row_condition, ]
if (nrow(row_data) > 0) {
result_matrix[i,
match(row_data$col_name,
colnames(result_matrix))] <- round(
row_data$yield, 0)
}
}
ct_sbav_be_yld <- as.data.frame(result_matrix) # Table in Excel.
uniquevalue <- unique(as.vector(as.matrix(ct_sbav_be_yld[-1])))
uniquevalue
colorcount <- length(unique(as.vector(as.matrix(ct_sbav_be_yld[-1]))))
colorcount
heatmap_plot <- pheatmap((ct_sbav_be_yld),
#clustering_distance_rows = "correlation",
clustering_distance_rows = "euclidean",
clustering_distance_cols = "euclidean",
clustering_method = "complete",
angle_col = 90,
na_col = "white",
color = colorRampPalette(c("green",
"yellow",
"red"))(colorcount),
cellheight = 13,
cellwidth = 14,
fontsize = 12,
fontsize_row = 12,
fontsize_col = 12,
number_color = "white",
fontsize_number = 5,
cluster_rows = FALSE,
cluster_cols = FALSE,
show_rownames = TRUE,
show_colnames = TRUE,
display_numbers = TRUE,
number_format = "%.0f",
legend_breaks = uniquevalue
)
library(shiny); runApp('AV Shiny.R')
runApp('AV Shiny.R')
