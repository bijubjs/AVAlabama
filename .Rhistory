mapping = aes(x = al_regs,
y = energy,
#fill = energy,
color = factor(panels),
group = factor(panels))) +
geom_line()+
geom_point() +
facet_grid(datalot~array) +
scale_x_discrete(limits = lox,
labels = c("North", "Center",
"B Belt", "South")) +
guides(color = guide_legend(ncol = 2,
reverse = TRUE))
rm(lox); rm(array_levs); rm(datalot_levs)
lox <- c("Northern", "Central", "Black Belt", "Southern")
ggplot(data = energy_output,
mapping = aes(x = al_regs,
y = energy,
#fill = energy,
color = factor(dc_kw),
group = factor(dc_kw))) +
geom_line()+
geom_point() +
facet_grid(datalot~array) +
scale_x_discrete(limits = lox,
labels = c("North", "Center",
"B Belt", "South")) +
guides(color = guide_legend(ncol = 2,
reverse = TRUE))
rm(lox)
# Convert to data frames if they are not already
matrix1 <- energy_output  %>%
group_by(sprop, al_regs, array, dc_kw, panels) %>%
dplyr::filter(datalot == 2) %>%
# Compute mean of datalot 1 and datalot 2:
summarise(
energy = mean(energy),
.groups = 'drop'
) # dimension of matrix is 168*6
matrix2 <- elec_price # dimension of matrix is 11*1
# Initialize the result data frame
# energy_revenue <- data.frame(matrix(nrow = 1848, ncol = 9))
energy_revenue <- data.frame(
matrix(nrow = nrow(matrix2)*nrow(matrix1),
ncol = ncol(matrix2)+ncol(matrix1)+1))
# Variable to keep track of the row index in the result matrix
row_index <- 1
# Loop through each value of the second matrix
for (i in 1:nrow(matrix2)) {
# Loop through each value of the second matrix
for (j in 1:nrow(matrix1)) {
# First matrix, second matrix, combined two matrices.
new_row <- c(matrix1[j, ],
matrix2[i, ],
matrix1$energy[j] * matrix2$epr_kwh[i])
# Assign the new row to the result matrix
energy_revenue[row_index, ] <- new_row
# Increment the row index
row_index <- row_index + 1
}
# Name the columns
colnames(energy_revenue) <- c(colnames(matrix1), "elcprc", "elcrev")
# Check for any NAs in the result
if(any(is.na(energy_revenue))) {
na_indices <- which(is.na(energy_revenue), arr.ind = TRUE)
print(paste("NAs found at rows:", unique(na_indices[, 1])))
} else {
print("No NAs found in the result data frame.")
}
str(energy_revenue)
rm(matrix1, matrix2, new_row, i, j, row_index)
lox <- c("Northern", "Central", "Black Belt", "Southern")
array_levs = c("Single Axis Rotation", "Fixed Open Rack")
datalot_levs = c("Location 1", "Location 2")
for (i in unique(energy_revenue$elcprc)) {
a = ggplot(data = (energy_revenue %>%
dplyr::filter(elcprc == i)),
mapping = aes(x =al_regs,
y = elcrev,
#fill = energy,
color = factor(panels),
group = factor(panels)))+
geom_line()+
geom_point()+
facet_grid(.~array) +
scale_x_discrete(limits = lox,
labels = c("North", "Center", "B Belt", "South")) +
guides(color = guide_legend(ncol = 2, reverse = TRUE))
cat("Electricity Price = ", i)
print(a)
}
rm(array_levs, datalot_levs, i, lox, a)
lox <- c("Northern", "Central", "Black Belt", "Southern")
array_levs = c("Single Axis Rotation", "Fixed Open Rack")
datalot_levs = c("Location 1", "Location 2")
for (i in unique(energy_revenue$elcprc)) {
a = ggplot(data = (energy_revenue %>%
dplyr::filter(elcprc == i)),
mapping = aes(x =al_regs,
y = elcrev,
#fill = energy,
color = factor(sprop),
group = factor(sprop)))+
geom_line()+
geom_point()+
facet_grid(.~array) +
scale_x_discrete(limits = lox,
labels = c("North", "Center", "B Belt", "South")) +
guides(color = guide_legend(ncol = 2, reverse = TRUE))
cat("Electricity Price = ", i)
print(a)
}
rm(lox, array_levs, datalot_levs, i, a)
i = 0.07 # Discount/interest Rate
n = 25 # Life Span of solar panels (Years)
reapprop = 50/100  # Percentage of CAPEX covered by REAP program.
expanded_data <- energy_revenue %>%
slice(rep(1:n(),
each = 3))
capex_height <- rep(unique(capex$height),
length.out = nrow(energy_revenue))
energy_cost = cbind(expanded_data, capex_height) %>%
rename(height = capex_height)
energy_cost <- left_join(energy_cost,
capex,
by = c("array", "height")) %>%
mutate(
# 7.75*3.5 sq.ft. panel energy output = 545 W.
# Operational cost (OPEX) = $15/kW-yr; 1 kW = 1,000W.
# Opex = 545*15/1000*panels,
# Land lease cost Per acre.
landlease = 1000,
# Total Capex
ttlcost = capex*545*panels,
# Cost of Insurance = $5/$1000/Yr Total capex
inscst = ttlcost*5/1000, #Cost
# Renewable energy credit 6.60 $/MWh
recredit = 6.60/1000*energy, #Return
# REAP Program = 50% of Capex - Simple interest rmbrst delay
reap = reapprop*ttlcost - (reapprop*ttlcost)*i*0.5/100, #Return
# Annualized cost - reap:
annlzcost = (ttlcost - reap + inscst)*(i*(1+i)^n)/((1+i)^n-1),
# Annualized Cost of total cost:
annoftotcost = ttlcost*(i*(1+i)^n)/((1+i)^n-1),
# Monthalized using monthly discount rate:
monthlycost = ttlcost*
((i/12)*(1+(i/n))^(n*12))/((1+(i/12))^(n*12)-1),
# Operational cost = 3% of annualized total capex
opex = 3*annoftotcost/100, #Cost
# Tax credit = 30% of annualized capex
taxcr = 30*annoftotcost/100, #Return
# Annualized using annual discount rate:
anncost = annlzcost + opex
)
solar_profit <- energy_cost %>%
mutate(
# Annualized Profit
eannprof = elcrev + recredit + taxcr - anncost,
eannprofworeap = elcrev + recredit + taxcr - annoftotcost,
eannprofwoincentives = elcrev - annoftotcost
)
write_xlsx(file = "Results/Solar Profit R50.xlsx",
x = solar_profit,
overwrite = TRUE,
as_table = TRUE)
str(solar_profit)
rm(capex_height, i, n, reapprop,
result_matrix, expanded_data, energy_cost)
pf_solar_r50 <- solar_profit %>%
filter(sprop == 1,
elcprc == 0.04) %>%
select(al_regs, array, height, eannprof, eannprofworeap)
cat("Maximum profit from solar at 100% PVD at 50% REAP = ",
max(pf_solar_r50$eannprof),
fill = TRUE)
pf_solar_r50[which.max(pf_solar_r50$eannprof),]
cat("Minimum profit from solar at 100% PVD at 50% REAP = ",
min(pf_solar_r50$eannprof),
fill = TRUE)
pf_solar_r50[which.min(pf_solar_r50$eannprof),]
rm(pf_solar_r25)
lox <- c("Northern", "Central", "Black Belt", "Southern")
array_levs = c("Single Axis Rotation", "Fixed Open Rack")
datalot_levs = c("Location 1", "Location 2")
for (i in unique(solar_profit$elcprc)) {
b = ggplot(
data = (solar_profit %>%
dplyr::filter(elcprc == i)),
mapping = aes(
x = al_regs,
y = eannprof, #Annual Profit
#fill = energy,
color = factor(panels),
group = factor(panels)
)
) +
geom_line() +
geom_point() +
facet_grid(height ~ array) +
scale_x_discrete(limits = lox,
labels = c("North", "Center",
"B Belt", "South")) +
guides(color = guide_legend(ncol = 2,
reverse = TRUE))
cat("Electricity Price = ", i)
print(b)
}
rm(lox, array_levs, datalot_levs, b, i)
tomato_profit = tomato %>%
select(yldvar, yield,
rolac17, rolac18, rolac19, rolac20,
rolac21, rolac22, rolac23)
dim(tomato_profit)
tomato_profit
# Assign column names for clarity
colnames(tomato_profit) <- c("yldvar", "yield",
"rolac17", "rolac18", "rolac19",
"rolac20", "rolac21", "rolac22",
"rolac23")
# Reshape the data frame from wide to long format
tomato_long <- melt(tomato_profit,
id.vars = c("yldvar", "yield"),
measure.vars = c("rolac17", "rolac18", "rolac19",
"rolac20", "rolac21", "rolac22",
"rolac23"),
variable.name = "price",
value.name = "profit")
# Convert the 'Price' column to numeric by extracting the number
tomato_long$price <- as.numeric(gsub("rolac", "", tomato_long$price))
str(tomato_long)
ggplot(data = tomato_long,
mapping = aes(x = price,
y = profit,
color = factor(yldvar),
group = factor(yield))) +
geom_line() +
geom_point() +
geom_hline(yintercept = 0,
linetype = "dashed",
color = "black") +
guides(color = guide_legend(ncol = 2,
reverse = TRUE))
ggplot(data = tomato_long,
mapping = aes(x = yield,
y = profit,
#fill = yield,
color = factor(price),
group = factor(price))) +
geom_line() +
geom_point() +
geom_hline(yintercept = 0,
linetype = "dashed",
color = "black") +
# Vertical dashed line is 100% yield
geom_vline(xintercept = tomato_long$yield[11],
linetype = "dashed",
color = "black") +
guides(color = guide_legend(reverse = TRUE))
strawberry_profit = strawberry %>%
select(yldvar, yield,
rolac3, rolac4, rolac5, rolac6,
rolac7, rolac8, rolac9)
str(strawberry_profit)
# Assign column names for clarity
colnames(strawberry_profit) <- c("yldvar", "yield",
"rolac3", "rolac4", "rolac5",
"rolac6", "rolac7", "rolac8",
"rolac9")
# Reshape the data frame from wide to long format
stberry_long <- melt(strawberry_profit,
id.vars = c("yldvar", "yield"),
measure.vars = c("rolac3", "rolac4", "rolac5",
"rolac6", "rolac7", "rolac8",
"rolac9"),
variable.name = "price",
value.name = "profit")
# Convert the 'Price' column to numeric by extracting the number
stberry_long$price <- as.numeric(gsub("rolac", "", stberry_long$price))
str(stberry_long)
ggplot(data = stberry_long,
mapping = aes(x = price,
y = profit,
color = factor(yldvar),
group = factor(yield))) +
geom_line() +
geom_point() +
geom_hline(yintercept = 0,
linetype = "dashed",
color = "black") +
guides(color = guide_legend(ncol = 2,
reverse = TRUE))
ggplot(data = stberry_long,
mapping = aes(x = yield,
y = profit,
color = factor(price),
group = factor(price))) +
geom_line() +
geom_point() +
geom_hline(yintercept = 0,
linetype = "dashed",
color = "black") +
#Vertical dashed line is 100% yield
geom_vline(xintercept = stberry_long$yield[11],
linetype = "dashed",
color = "black") +
guides(color = guide_legend(reverse = TRUE))
squash_profit = squash %>%
dplyr::select(yldvar, yield,
rolac11, rolac12, rolac13, rolac14,
rolac15, rolac16, rolac17)
# Reshape the data frame from wide to long format
squash_long <- reshape2::melt(squash_profit,
id.vars = c("yldvar", "yield"),
measure.vars = c("rolac11", "rolac12", "rolac13",
"rolac14","rolac15", "rolac16",
"rolac17"),
variable.name = "price",
value.name = "profit")
# Convert the 'Price' column to numeric by extracting the number
squash_long$price <- as.numeric(gsub("rolac", "", squash_long$price))
# Calculate all combinations of rows from both matrices in a vectorized way
solar_expanded <- solar_profit[rep(1:nrow(solar_profit),
each = nrow(tomato_long)), ]
tomato_expanded <- tomato_long[rep(1:nrow(tomato_long),
times = nrow(solar_profit)), ]
# Calculate the new column for tav_profit directly
tav_profit_values <- solar_expanded$eannprof + tomato_expanded$profit
# Combine the matrices and the calculated tav_profit column
tav_profit <- cbind(solar_expanded,
tomato_expanded,
tav_profit = tav_profit_values)
# Convert to a data frame and ensure the correct format
tav_profit <- as.data.frame(tav_profit)
tav_profit <- data.frame(lapply(tav_profit, unlist))
str(tav_profit)
rm(solar_expanded, tomato_expanded, tav_profit_values)
write_feather(tav_profit,
sink = "Data/tav_profit R50.feather",
version = 2,
chunk_size = 65536L,
compression = c("default"),
#compression = c("default", "lz4", "lz4_frame", "uncompressed", "zstd"),
compression_level = NULL
)
tictoc::tic("Using Dplyr:")
write_xlsx(x = tav_profit %>%
dplyr::sample_n(100),
file = "Results/TAV Profit Sample R50.xlsx",
as_table = TRUE)
tictoc::toc()
write_xlsx(x = tav_profit %>%
filter(sprop %in% c(0, 0.25, 0.50, 0.75, 1),
yldvar == 1,
price == 20,
elcprc == 0.04)%>%
dplyr::select(sprop, panels, height, array,
al_regs, yldvar, yield, price,
elcprc, tav_profit) %>%
mutate(al_regs1 = case_when(
al_regs == "Northern" ~ 1,
al_regs == "Central" ~ 2,
al_regs == "Black Belt" ~ 3,
al_regs == "Southern" ~ 4,
TRUE ~ NA_real_)),
file = "Results/Profit TAV WriteUp R50.xlsx",
as_table = TRUE)
# Generate all combinations of rows from both matrices in a vectorized way
solar_expanded <- solar_profit[rep(1:nrow(solar_profit),
each = nrow(stberry_long)), ]
stberry_expanded <- stberry_long[rep(1:nrow(stberry_long),
times = nrow(solar_profit)), ]
# Calculate the new column for sbav_profit directly
sbav_profit_values <- solar_expanded$eannprof + stberry_expanded$profit
# Combine the matrices and the calculated sbav_profit column
sbav_profit <- cbind(solar_expanded,
stberry_expanded,
sbav_profit = sbav_profit_values)
# Convert to a data frame and ensure the correct format
sbav_profit <- as.data.frame(sbav_profit)
sbav_profit <- data.frame(lapply(sbav_profit, unlist))
rm(solar_expanded, stberry_expanded, sbav_profit_values)
sbav_profit %>%
dplyr::filter(height == 8.2,
array == "Tracking",
elcprc == 0.04,
sprop == 0.70,
yldvar == 1,
price == 3) %>%
dplyr::select(height, array, elcprc, al_regs,
yldvar, price, sprop, sbav_profit)
#write_csv(sbav_profit, "tav_profit.csv")
write_feather(sbav_profit,
sink = "Data/sbav_profit R50.feather",
version = 2,
chunk_size = 65536L,
compression = c("default"),
#compression = c("default", "lz4", "lz4_frame", "uncompressed", "zstd"),
compression_level = NULL
)
tictoc::tic("Using Base R Matrix:")
write_xlsx(x = sbav_profit[sample(nrow(sbav_profit), 100),],
file = "Results/SBAV Profit Sample R50.xlsx",
as_table = TRUE)
tictoc::toc()
write_xlsx(x = sbav_profit %>%
filter(sprop %in% c(0, 0.25, 0.50, 0.75, 1),
yldvar == 1,
price == 6,
elcprc == 0.04)%>%
dplyr::select(sprop, panels, height, array, al_regs,
#price, elcprc, yldvar, yield,
sbav_profit) %>%
mutate(al_regs1 = case_when(
al_regs == "Northern" ~ 1,
al_regs == "Central" ~ 2,
al_regs == "Black Belt" ~ 3,
al_regs == "Southern" ~ 4,
TRUE ~ NA_real_)),
file = "Results/Profit SBAV WriteUp R50.xlsx",
as_table = TRUE)
solar_expanded <- solar_profit[rep(1:nrow(solar_profit),
each = nrow(squash_long)), ]
squash_expanded <- squash_long[rep(1:nrow(squash_long),
times = nrow(solar_profit)), ]
# Calculate the new column for tav_profit directly
sqav_profit_values <- solar_expanded$eannprof + squash_expanded$profit
# Combine the matrices and the calculated tav_profit column
sqav_profit <- cbind(solar_expanded,
squash_expanded,
sqav_profit = sqav_profit_values)
# Convert to a data frame and ensure the correct format
sqav_profit <- as.data.frame(sqav_profit)
sqav_profit <- data.frame(lapply(sqav_profit, unlist))
# Create a new variable
sqav_profit <- sqav_profit %>%
group_by(price) %>%  # Control for unique prices
mutate(
sqavp_ge_sq = if_else(yldvar == 1 & sqav_profit >= profit, 1, 0)
) %>%
ungroup()
# SQAV Profit Greater or Equal to Squash
sqavp_ge_squash = sqav_profit %>% filter(sqavp_ge_sq == 1)
write_feather(sqav_profit,
sink = "Data/sqav_profit R50.feather",
version = 2,
chunk_size = 65536L,
compression = c("default"),
compression_level = NULL
)
write_xlsx(x = sqav_profit[sample(nrow(sqav_profit), 100),],
file = "Results/SQAV Profit Sample R50.xlsx",
as_table = TRUE)
write_xlsx(x = sqav_profit %>%
filter(sprop %in% c(0, 0.25, 0.50, 0.75, 1),
yldvar == 1,
price == 14,
elcprc == 0.04)%>%
dplyr::select(sprop, panels, height, array,
al_regs, yldvar, yield, price,
elcprc, sqav_profit) %>%
mutate(al_regs1 = case_when(
al_regs == "Northern" ~ 1,
al_regs == "Central" ~ 2,
al_regs == "Black Belt" ~ 3,
al_regs == "Southern" ~ 4,
TRUE ~ NA_real_)),
file = "Results/Profit SQAV WriteUp R50.xlsx",
as_table = TRUE)
write_xlsx(
x = sqavp_ge_squash %>%
dplyr::filter(sqavp_ge_sq == 1) %>%
dplyr::select(
sprop, panels, height, array, al_regs,
yldvar, yield, price, elcprc, sqav_profit
) %>%
mutate(al_regs1 = case_when(
al_regs == "Northern" ~ 1,
al_regs == "Central" ~ 2,
al_regs == "Black Belt" ~ 3,
al_regs == "Southern" ~ 4,
TRUE ~ NA_real_
)),
file = "Results/Profit SQAV GE Squash R50.xlsx",
as_table = TRUE
)
rm(solar_expanded, squash_expanded, squash_long, sqav_profit_values)
pf_solar <- solar_profit %>%
filter(sprop == 1,
elcprc == 0.04) %>%
select(al_regs, array, height, eannprof, eannprofworeap)
cat("Maximum profit from solar at 100% PVD at 50% REAP = ",
max(pf_solar$eannprof),
fill = TRUE)
pf_solar[which.max(pf_solar$eannprof),]
cat("Minimum profit from solar at 100% PVD at 50% REAP = ",
min(pf_solar$eannprof),
fill = TRUE)
pf_solar[which.min(pf_solar$eannprof),]
rm(pf_solar)
pf_solar <- solar_profit %>%
filter(sprop == 1,
elcprc == 0.04) %>%
select(al_regs, array, height, eannprof, eannprofworeap)
cat("Maximum profit from solar at 100% PVD at 25% REAP = ",
max(pf_solar$eannprof),
fill = TRUE)
pf_solar[which.max(pf_solar$eannprof),]
cat("Minimum profit from solar at 100% PVD at 25% REAP = ",
min(pf_solar$eannprof),
fill = TRUE)
pf_solar[which.min(pf_solar$eannprof),]
rm(pf_solar)
