array <- c("Fixed", "Tracking")
height <- c(4.6, 6.4, 8.2)
yldvar <- c(0.10, 0.30, 0.50, 0.70, 1.00, 1.20, 1.50, 1.80, 2.00)
al_regs <- c("Northern", "Central", "Black Belt", "Southern")
price <- c(11, 14, 17)
elcprc <- c(0.01, 0.03, 0.06)
# Define the required columns
required_columns <- c("sprop", "array", "height",
"al_regs", "yldvar", "price", "elcprc")
# Check if the columns exist in tav_profit
missing_columns <- setdiff(required_columns,
names(sqav_profit))
if (length(missing_columns) > 0) {
stop("Missing columns in sqav_profit: ",
paste(missing_columns, collapse = ", "))
}
# Generate column names using reversed order of expand.grid
col_names <- apply(expand.grid(height, array, sprop), 1,
function(x) paste0(x[3], "%_", x[2], "_", x[1]))
# Generate row names using reversed order of expand.grid
row_names <- apply(expand.grid(elcprc,
price,
yldvar,
al_regs), 1,
function(x) paste0(x, collapse = "_"))
# Create an empty matrix to store the results
result_matrix <- matrix(NA, nrow = length(row_names),
ncol = length(col_names))
colnames(result_matrix) <- col_names
rownames(result_matrix) <- row_names
# Create a data frame with
# all combinations of parameters in reversed order
param_combinations <- expand.grid(elcprc = elcprc,
price = price,
yldvar = yldvar,
al_regs = al_regs,
height = height,
array = array,
sprop = sprop)
# Merge with tav_profit to get av_profit values for each combination
merged_data <- merge(param_combinations,
sqav_profit,
by = required_columns,
all.x = TRUE)
# Reshape merged_data to fill result_matrix with
# reversed column and row names
merged_data$col_name <- apply(
merged_data[, c("sprop", "array", "height")], 1,
function(x) paste0(x[1], "%_", x[2], "_", x[3]))
merged_data$row_name <- apply(
merged_data[, c("al_regs", "yldvar", "price", "elcprc")], 1,
function(x) paste0(x[4], "_",
x[3], "_",
x[2], "_", x[1]))
# Fill the matrix with av_profit values
for (i in seq_len(nrow(result_matrix))) {
row_condition <- rownames(result_matrix)[i]
row_data <- merged_data[
merged_data$row_name == row_condition, ]
if (nrow(row_data) > 0) {
result_matrix[i,
match(row_data$col_name,
colnames(result_matrix))] <- round(
row_data$sqav_profit, 2)
}
write_csv(as.data.frame(result_matrix),
file = "sqav_chtbl.csv")
# Display the result matrix
dim(as.data.frame(result_matrix))
head(result_matrix)
tail(result_matrix)
# Assuming 'cols' and 'scaled_val' are defined appropriately in your context
# Convert matrix to data frame suitable for ggplot
matrix_df <- as.data.frame(result_matrix)
matrix_df$row <- 1:nrow(matrix_df)  # Add row numbers as a column
# Reshape data for ggplot
df <- reshape2::melt(matrix_df, id.vars = "row")
ggplot(df , aes(x = variable,
y = row)) +
geom_raster(aes(fill = value),
interpolate=TRUE) +
scale_fill_gradient2(low="navy",
mid="white",
high="red",
midpoint=0,
limits=range(df$value)) +
theme_classic()
View(result_matrix)
?write_csv
write_xlsx()
?write_xlsx()
write_csv(as.data.frame(result_matrix),
row_names = TRUE,
col_names = index(result_matrix),
file = "sqav_chtbl.csv")
write_csv(as.data.frame(result_matrix),
row_names = index(result_matrix),
col_names = TRUE,
file = "sqav_chtbl.csv")
write_csv(as.data.frame(result_matrix),
row_names = result_matrix[index],
col_names = TRUE,
file = "sqav_chtbl.csv")
write.csv(as.data.frame(result_matrix),
row.names = result_matrix[index],
col.names = TRUE,
file = "sqav_chtbl.csv")
write.csv(as.data.frame(result_matrix),
row.names = TRUE,
col.names = TRUE,
file = "sqav_chtbl.csv")
# Display the result matrix
dim(as.data.frame(result_matrix))
write.csv(as.data.frame(result_matrix),
row.names = TRUE,
file = "sqav_chtbl.csv")
# Display the result matrix
dim(as.data.frame(result_matrix))
# #| echo: TRUE
rm(list = ls()) # Clean the environment.
options(
warn=0, # Warnings. options(warn=-1) / options(warn=0)
scipen=999 # No scientific notations.
)
path_mac = "/Users/bmishra/Library/CloudStorage/OneDrive-AuburnUniversity/Collaboration/Ngbede M/Choice-paper"
path_office = "Users\\bzm0094\\OneDrive - Auburn University\\Collaboration\\Ngbede M\\Choice-paper"
ifelse(Sys.info()[6] == "bmishra",
setwd(path_mac),
setwd(path_office))
library(tidyverse, warn.conflicts = FALSE, quietly = TRUE)
library(psych, warn.conflicts = FALSE, quietly = TRUE)
library(likert,  warn.conflicts = FALSE, quietly = TRUE) # Likert Items
library(mice,  warn.conflicts = FALSE, quietly = TRUE)
library(openxlsx2, warn.conflicts = FALSE, quietly = TRUE)
library(ggpubr, warn.conflicts = FALSE, quietly = TRUE) # Scatter plot
library(gmodels,  warn.conflicts = FALSE, quietly = TRUE) # Crosstab
library(reshape2, warn.conflicts = FALSE, quietly = TRUE) # Reshape data
library(pacman,  warn.conflicts = FALSE, quietly = TRUE) # Package Management
library(progress, warn.conflicts = FALSE, quietly = TRUE) #progress bar
library(arrow, warn.conflicts = FALSE, quietly = TRUE) #progress bar
pacman::p_loaded()
####### Progress Bar #####
pb = progress_bar$new(
format = "Processing data at :rate. Processed :bytes in :elapsed.",
clear = TRUE,
total = NA,
width = 80)
f = function() {
for (i in 1:100) {
pb$tick(sample(1:100 * 1000, 1))
Sys.sleep(2/100)
}
pb$tick(1e7)
#invisible()
}
####### Plotting Data: #####
# Map Theme:
plottheme <- ggplot() +
theme_void() +
# Mapping theme:
theme(axis.title = element_blank(),
axis.ticks = element_blank(),
axis.text = element_blank(),
panel.border = element_blank(),
plot.margin = margin(t = 0,
r = 0,
b = 0,
l = 0,
unit = "cm"),
plot.title = element_text(hjust = 0.5),
plot.background = element_rect(fill = "white",
color = "black",
linewidth = 0),
panel.background = element_rect(fill = "white",
color = "black",
linewidth = 0),
panel.grid.major.x = element_line(color = "lightgrey",
linetype = 2,
linewidth = 0),
panel.grid.minor.x = element_line(color = "lightgrey",
linetype = 2,
linewidth = 0),
panel.grid.major.y = element_line(color = "grey",
linetype = 2,
linewidth = 0),
panel.grid.minor.y = element_line(color = "grey",
linetype = 2,
linewidth = 0),
axis.line.x.top = element_line(color = "white",
linetype = 2,
linewidth = 0),
axis.line.y.right = element_line(color = "white",
linetype = 2,
linewidth = 0),
axis.line.x.bottom = element_line(color = "black",
linetype = 1,
linewidth = 0),
axis.line.y.left = element_line(color = "black",
linetype = 1,
linewidth = 0),
# Text formatting:
text = element_text(family = "serif", # font
size = 12, # font size
colour = "black"# font color
),
legend.position = c(0.95, -0.05),
legend.key = element_rect(color = "black",
fill = NA,
linewidth = 0.05,
linetype = 1),
legend.justification = "right",
legend.direction = "horizontal")
tav_profit <- as.data.frame(read_feather(file = "tav_profit.feather"))
dim(tav_profit)
#str(tav_profit)
head(tav_profit); head(tav_profit)
sbav_profit <- as.data.frame(read_feather(file = "sbav_profit.feather"))
dim(sbav_profit)
#str(sbav_profit)
head(sbav_profit); tail(sbav_profit)
sqav_profit <- as.data.frame(read_feather(file = "sqav_profit.feather"))
dim(sqav_profit)
#str(sqav_profit)
head(sqav_profit); tail(sqav_profit)
# Define the values for each variable
sprop <- c(0, 0.25, 0.50, 0.75, 1.00)
array <- c("Fixed", "Tracking")
height <- c(4.6, 6.4, 8.2)
yldvar <- c(0.10, 0.30, 0.50, 0.70, 1.00, 1.20, 1.50, 1.80, 2.00)
al_regs <- c("Northern", "Central", "Black Belt", "Southern")
price <- c(17, 20, 23)
elcprc <- c(0.01, 0.03, 0.06)
# Define the required columns
required_columns <- c("sprop", "array", "height",
"al_regs", "yldvar", "price", "elcprc")
# Check if the columns exist in tav_profit
missing_columns <- setdiff(required_columns,
names(tav_profit))
if (length(missing_columns) > 0) {
stop("Missing columns in tav_profit: ",
paste(missing_columns, collapse = ", "))
}
# Generate column names using reversed order of expand.grid
col_names <- apply(expand.grid(height, array, sprop), 1,
function(x) paste0(x[3], "%_", x[2], "_", x[1]))
# Generate row names using reversed order of expand.grid
row_names <- apply(expand.grid(elcprc,
price,
yldvar,
al_regs), 1,
function(x) paste0(x, collapse = "_"))
# Create an empty matrix to store the results
result_matrix <- matrix(NA, nrow = length(row_names),
ncol = length(col_names))
colnames(result_matrix) <- col_names
rownames(result_matrix) <- row_names
# Create a data frame with
# all combinations of parameters in reversed order
param_combinations <- expand.grid(elcprc = elcprc,
price = price,
yldvar = yldvar,
al_regs = al_regs,
height = height,
array = array,
sprop = sprop)
# Merge with tav_profit to get av_profit values for each combination
merged_data <- merge(param_combinations,
tav_profit,
by = required_columns,
all.x = TRUE)
# Reshape merged_data to fill result_matrix with
# reversed column and row names
merged_data$col_name <- apply(
merged_data[, c("sprop", "array", "height")], 1,
function(x) paste0(x[1], "%_", x[2], "_", x[3]))
merged_data$row_name <- apply(
merged_data[, c("al_regs", "yldvar", "price", "elcprc")], 1,
function(x) paste0(x[4], "_",
x[3], "_",
x[2], "_", x[1]))
# Fill the matrix with av_profit values
for (i in seq_len(nrow(result_matrix))) {
row_condition <- rownames(result_matrix)[i]
row_data <- merged_data[
merged_data$row_name == row_condition, ]
if (nrow(row_data) > 0) {
result_matrix[i,
match(row_data$col_name,
colnames(result_matrix))] <- round(
row_data$tav_profit, 2)
}
write.csv(as.data.frame(result_matrix),
row.names = TRUE,
col.names = TRUE,
file = "tav_chtbl.csv")
# Display the result matrix
dim(as.data.frame(result_matrix))
head(result_matrix)
tail(result_matrix)
# Assuming 'cols' and 'scaled_val' are defined appropriately in your context
# Convert matrix to data frame suitable for ggplot
matrix_df <- as.data.frame(result_matrix)
matrix_df$row <- 1:nrow(matrix_df)  # Add row numbers as a column
# Reshape data for ggplot
df <- reshape2::melt(matrix_df, id.vars = "row")
ggplot(df , aes(x = variable,
y = row)) +
geom_raster(aes(fill = value),
interpolate=TRUE) +
scale_fill_gradient2(low="navy",
mid="white",
high="red",
midpoint=0,
limits=range(df$value)) +
theme_classic()
# Define the values for each variable
sprop <- c(0, 0.25, 0.50, 0.75, 1.00)
array <- c("Fixed", "Tracking")
height <- c(4.6, 6.4, 8.2)
yldvar <- c(0.10, 0.30, 0.50, 0.70, 1.00, 1.20, 1.50, 1.80, 2.00)
al_regs <- c("Northern", "Central", "Black Belt", "Southern")
price <- c(3, 6, 9)
elcprc <- c(0.01, 0.03, 0.06)
# Define the required columns
required_columns <- c("sprop", "array", "height",
"al_regs", "yldvar", "price", "elcprc")
# Check if the columns exist in tav_profit
missing_columns <- setdiff(required_columns,
names(sbav_profit))
if (length(missing_columns) > 0) {
stop("Missing columns in sbav_profit: ",
paste(missing_columns, collapse = ", "))
}
# Generate column names using reversed order of expand.grid
col_names <- apply(expand.grid(height, array, sprop), 1,
function(x) paste0(x[3], "%_", x[2], "_", x[1]))
# Generate row names using reversed order of expand.grid
row_names <- apply(expand.grid(elcprc,
price,
yldvar,
al_regs), 1,
function(x) paste0(x, collapse = "_"))
# Create an empty matrix to store the results
result_matrix <- matrix(NA, nrow = length(row_names),
ncol = length(col_names))
colnames(result_matrix) <- col_names
rownames(result_matrix) <- row_names
# Create a data frame with
# all combinations of parameters in reversed order
param_combinations <- expand.grid(elcprc = elcprc,
price = price,
yldvar = yldvar,
al_regs = al_regs,
height = height,
array = array,
sprop = sprop)
# Merge with tav_profit to get av_profit values for each combination
merged_data <- merge(param_combinations,
sbav_profit,
by = required_columns,
all.x = TRUE)
# Reshape merged_data to fill result_matrix with
# reversed column and row names
merged_data$col_name <- apply(
merged_data[, c("sprop", "array", "height")], 1,
function(x) paste0(x[1], "%_", x[2], "_", x[3]))
merged_data$row_name <- apply(
merged_data[, c("al_regs", "yldvar", "price", "elcprc")], 1,
function(x) paste0(x[4], "_",
x[3], "_",
x[2], "_", x[1]))
# Fill the matrix with av_profit values
for (i in seq_len(nrow(result_matrix))) {
row_condition <- rownames(result_matrix)[i]
row_data <- merged_data[
merged_data$row_name == row_condition, ]
if (nrow(row_data) > 0) {
result_matrix[i,
match(row_data$col_name,
colnames(result_matrix))] <- round(
row_data$sbav_profit, 2)
}
write.csv(as.data.frame(result_matrix),
row.names = TRUE,
col.names = TRUE,
file = "sbav_chtbl.csv")
# Display the result matrix
dim(as.data.frame(result_matrix))
head(result_matrix)
tail(result_matrix)
# Assuming 'cols' and 'scaled_val' are defined appropriately in your context
# Convert matrix to data frame suitable for ggplot
matrix_df <- as.data.frame(result_matrix)
matrix_df$row <- 1:nrow(matrix_df)  # Add row numbers as a column
# Reshape data for ggplot
df <- reshape2::melt(matrix_df, id.vars = "row")
ggplot(df , aes(x = variable,
y = row)) +
geom_raster(aes(fill = value),
interpolate=TRUE) +
scale_fill_gradient2(low="navy",
mid="white",
high="red",
midpoint=0,
limits=range(df$value)) +
theme_classic()
# Define the values for each variable
sprop <- c(0, 0.25, 0.50, 0.75, 1.00)
array <- c("Fixed", "Tracking")
height <- c(4.6, 6.4, 8.2)
yldvar <- c(0.10, 0.30, 0.50, 0.70, 1.00, 1.20, 1.50, 1.80, 2.00)
al_regs <- c("Northern", "Central", "Black Belt", "Southern")
price <- c(11, 14, 17)
elcprc <- c(0.01, 0.03, 0.06)
# Define the required columns
required_columns <- c("sprop", "array", "height",
"al_regs", "yldvar", "price", "elcprc")
# Check if the columns exist in tav_profit
missing_columns <- setdiff(required_columns,
names(sqav_profit))
if (length(missing_columns) > 0) {
stop("Missing columns in sqav_profit: ",
paste(missing_columns, collapse = ", "))
}
# Generate column names using reversed order of expand.grid
col_names <- apply(expand.grid(height, array, sprop), 1,
function(x) paste0(x[3], "%_", x[2], "_", x[1]))
# Generate row names using reversed order of expand.grid
row_names <- apply(expand.grid(elcprc,
price,
yldvar,
al_regs), 1,
function(x) paste0(x, collapse = "_"))
# Create an empty matrix to store the results
result_matrix <- matrix(NA, nrow = length(row_names),
ncol = length(col_names))
colnames(result_matrix) <- col_names
rownames(result_matrix) <- row_names
# Create a data frame with
# all combinations of parameters in reversed order
param_combinations <- expand.grid(elcprc = elcprc,
price = price,
yldvar = yldvar,
al_regs = al_regs,
height = height,
array = array,
sprop = sprop)
# Merge with tav_profit to get av_profit values for each combination
merged_data <- merge(param_combinations,
sqav_profit,
by = required_columns,
all.x = TRUE)
# Reshape merged_data to fill result_matrix with
# reversed column and row names
merged_data$col_name <- apply(
merged_data[, c("sprop", "array", "height")], 1,
function(x) paste0(x[1], "%_", x[2], "_", x[3]))
merged_data$row_name <- apply(
merged_data[, c("al_regs", "yldvar", "price", "elcprc")], 1,
function(x) paste0(x[4], "_",
x[3], "_",
x[2], "_", x[1]))
# Fill the matrix with av_profit values
for (i in seq_len(nrow(result_matrix))) {
row_condition <- rownames(result_matrix)[i]
row_data <- merged_data[
merged_data$row_name == row_condition, ]
if (nrow(row_data) > 0) {
result_matrix[i,
match(row_data$col_name,
colnames(result_matrix))] <- round(
row_data$sqav_profit, 2)
}
write.csv(as.data.frame(result_matrix),
row.names = TRUE,
file = "sqav_chtbl.csv")
# Display the result matrix
dim(as.data.frame(result_matrix))
head(result_matrix)
tail(result_matrix)
# Assuming 'cols' and 'scaled_val' are defined appropriately in your context
# Convert matrix to data frame suitable for ggplot
matrix_df <- as.data.frame(result_matrix)
matrix_df$row <- 1:nrow(matrix_df)  # Add row numbers as a column
# Reshape data for ggplot
df <- reshape2::melt(matrix_df, id.vars = "row")
ggplot(df , aes(x = variable,
y = row)) +
geom_raster(aes(fill = value),
interpolate=TRUE) +
scale_fill_gradient2(low="navy",
mid="white",
high="red",
midpoint=0,
limits=range(df$value)) +
theme_classic()
# Assuming 'cols' and 'scaled_val' are defined appropriately in your context
# Convert matrix to data frame suitable for ggplot
matrix_df <- as.data.frame(result_matrix)
matrix_df$row <- 1:nrow(matrix_df)  # Add row numbers as a column
# Reshape data for ggplot
df <- reshape2::melt(matrix_df, id.vars = "row")
ggplot(df , aes(x = variable,
y = row)) +
geom_raster(aes(fill = value),
interpolate=TRUE) +
scale_fill_gradient2(low="navy",
mid="white",
high="red",
midpoint=0,
limits=range(df$value)) +
theme_classic()
