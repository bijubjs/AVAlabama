<<<<<<< HEAD
row.names = TRUE,
file = "Results/ct_sqav_be_yld.csv")
dim(ct_sqav_be_yld)
rm(result_matrix)
colorcount = length(unique(as.vector(as.matrix(ct_sqav_be_yld[-1]))))
colorcount
heatmap_plot <- pheatmap(t(ct_sqav_be_yld),
#clustering_distance_rows = "correlation",
clustering_distance_rows = "euclidean",
clustering_distance_cols = "euclidean",
clustering_method = "complete",
color = colorRampPalette(c("red",
"yellow",
"green"))(colorcount),
#cutree_rows = 5,
#cutree_cols = 4,
cluster_rows = FALSE,
cluster_cols = FALSE,
show_rownames = FALSE,
show_colnames = FALSE,
display_numbers = FALSE,
number_format = "%.2f",
#cellheight = 3,
#cellwidth = 3
)
ggsave(heatmap_plot,
height = 8,
width = 12,
units = "in",
file = paste0("Plots/gp_sqav_be_yld", ".png"))
rm(heatmap_plot)
rm(colorcount)
combinations <- expand.grid(
yldvar = c(0.1, 0.3, 0.5, 0.7, 1, 1.20, 1.5, 1.80, 2), # Yield variation
price = c(11, 14, 17), # Squash price
elcprc = c(0.03, 0.04, 0.05) #Electricity price
)
# Iterate over the combinations and create the plots
for (combo in seq_len(nrow(combinations))) {
filtered_data <- sqav_profit %>%
filter(
yldvar == combinations$yldvar[combo],
price == combinations$price[combo],
elcprc == combinations$elcprc[combo]
)
# If by panel, put panels below in color and group.
sqav_sp_plot <- ggplot(data = filtered_data,
mapping = aes(x = al_regs,
y = sqav_profit,
color = factor(panels),
group = factor(panels))) +
geom_line() +
geom_point() +
facet_grid(height ~ array,
labeller = as_labeller(
c(
"4.6" = "4.6 ft. Height",
"6.4" = "6.4 ft. Height",
"8.2" = "8.2 ft. Height",
Tracking = "Single Axis Rotation",
Fixed = "Fixed Open Rack"
))) +
guides(color = guide_legend(ncol = 1,
reverse = TRUE)) +
scale_x_discrete(limits = c("Northern", "Central",
"Black Belt", "Southern"),
labels = c("North", "Center",
"B Belt", "South")) +
guides(color = guide_legend(ncol = 2,
reverse = TRUE)) +
labs(x = "Regions of Alabama",
y = "Profit ($) from Squash Agrivoltaic System",
color = "Number of Solar \n Panels per Acre",
title = (list(combinations[combo,]))
) +
theme(strip.background = element_blank())
# Add horizontal line at y = 0 if y has both positive and negative values
if (min(filtered_data$sqav_profit) < 0 &
max(filtered_data$sqav_profit) > 0) {
sqav_sp_plot <- sqav_sp_plot +
geom_hline(yintercept = 0,
linewidth = 0.30,
linetype = "dashed",
color = "black")
}
print(combinations[combo,])
print(sqav_sp_plot)
ggsave(file = paste0("Plots/sqav_sp_", combo, ".png"))
#break
}
combinations <- expand.grid(
sprop = c(0, 0.25, 0.50, 0.75, 1.00), # Solar proportion
price = c(11, 14, 17), # Squash price
elcprc = c(0.03, 0.04, 0.05) #Electricity price
)
# Iterate over the combinations and create the plots
for (combo in seq_len(nrow(combinations))) {
filtered_data <- sqav_profit %>%
filter(
sprop == combinations$sprop[combo],
price == combinations$price[combo],
elcprc == combinations$elcprc[combo]
)
# If by yield, put yield below in color and group.
sqav_yv_plot <- ggplot(data = filtered_data,
mapping = aes(x = al_regs,
y = sqav_profit,
color = factor(yield),
group = factor(yield))) +
geom_line() +
geom_point() +
facet_grid(height ~ array,
labeller = as_labeller(
c(
"4.6" = "4.6 ft. Height",
"6.4" = "6.4 ft. Height",
"8.2" = "8.2 ft. Height",
Tracking = "Single Axis Rotation",
Fixed = "Fixed Open Rack"
))) +
guides(color = guide_legend(ncol = 1,
reverse = TRUE)) +
scale_x_discrete(limits = c("Northern", "Central",
"Black Belt", "Southern"),
labels = c("North", "Center",
"B Belt", "South")) +
guides(color = guide_legend(ncol = 2,
reverse = TRUE)) +
labs(x = "Regions of Alabama",
y = "Profit ($) from Squash Agrivoltaic System",
color = "Squash Yield \n (25 Lb Buckets)",
title = (list(combinations[combo,]))
) +
theme(strip.background = element_blank())
# Add horizontal line at y = 0 if y has both positive and negative values
if (min(filtered_data$sqav_profit) < 0 &
max(filtered_data$sqav_profit) > 0) {
sqav_yv_plot <- sqav_yv_plot +
geom_hline(yintercept = 0,
linewidth = 0.30,
linetype = "dashed",
color = "black")
}
print(combinations[combo,])
print(sqav_yv_plot)
ggsave(file = paste0("Plots/sqav_yv_", combo, ".png"))
#break
}
library(pheatmap)
library(grid)
# Calculate the number of colors needed
colorcount <- length(unique(as.vector(as.matrix(ct_tavp_be_yld[-1]))))
# Generate the heatmap
heatmap_plot <- pheatmap(t(ct_tavp_be_yld),
clustering_distance_rows = "euclidean",
clustering_distance_cols = "euclidean",
clustering_method = "complete",
color = colorRampPalette(c("red", "yellow", "green"))(colorcount),
cluster_rows = FALSE,
cluster_cols = FALSE,
show_rownames = FALSE,
show_colnames = FALSE,
display_numbers = FALSE,
number_format = "%.2f"
)
# Customizing the heatmap with white background and gray dotted grid lines
grid.newpage()  # Create a new page
pushViewport(viewport(layout = grid.layout(1, 1)))  # Set up the layout
grid.rect(gp = gpar(fill = "white", col = NA))  # Draw a white background
# Draw the heatmap
print(heatmap_plot, newpage = FALSE)
# Add gray dotted grid lines in a more efficient way
nrows <- nrow(ct_tavp_be_yld)
ncols <- ncol(ct_tavp_be_yld)
x_grid <- seq(0, 1, length.out = ncols + 1)
y_grid <- seq(0, 1, length.out = nrows + 1)
# Draw vertical lines
for (x in x_grid) {
grid.lines(x = unit(c(x, x), "npc"),
y = unit(c(0, 1), "npc"),
gp = gpar(col = "gray", lty = "dotted"))
}
# Draw horizontal lines
for (y in y_grid) {
grid.lines(x = unit(c(0, 1), "npc"),
y = unit(c(y, y), "npc"),
gp = gpar(col = "gray", lty = "dotted"))
}
library(pheatmap)
library(grid)
# Calculate the number of colors needed
colorcount <- length(unique(as.vector(as.matrix(ct_tavp_be_yld[-1]))))
# Add gray dotted grid lines in a more efficient way
nrows <- nrow(ct_tavp_be_yld)
ncols <- ncol(ct_tavp_be_yld)
x_grid <- seq(0, 1, length.out = ncols + 1)
y_grid <- seq(0, 1, length.out = nrows + 1)
# Draw vertical lines
for (x in x_grid) {
grid.lines(x = unit(c(x, x), "npc"),
y = unit(c(0, 1), "npc"),
gp = gpar(col = "gray", lty = "dotted"))
}
# Draw horizontal lines
for (y in y_grid) {
grid.lines(x = unit(c(0, 1), "npc"),
y = unit(c(y, y), "npc"),
gp = gpar(col = "gray", lty = "dotted"))
}
# Generate the heatmap
heatmap_plot <- pheatmap(t(ct_tavp_be_yld),
clustering_distance_rows = "euclidean",
clustering_distance_cols = "euclidean",
clustering_method = "complete",
color = colorRampPalette(c("red", "yellow", "green"))(colorcount),
cluster_rows = FALSE,
cluster_cols = FALSE,
show_rownames = FALSE,
show_colnames = FALSE,
display_numbers = FALSE,
number_format = "%.2f"
)
# Customizing the heatmap with white background and gray dotted grid lines
grid.newpage()  # Create a new page
pushViewport(viewport(layout = grid.layout(1, 1)))  # Set up the layout
grid.rect(gp = gpar(fill = "white", col = NA))  # Draw a white background
# Draw the heatmap
print(heatmap_plot, newpage = FALSE)
# Load necessary libraries
library(dplyr)
library(tidyr)
library(reshape2)
# Define the values for each variable
sprop <- c(0, 0.10, 0.20, 0.30, 0.40, 0.50, 0.60, 0.70, 0.80, 0.90, 1.00)
array <- c("Fixed", "Tracking") # Solar Array
height <- c(4.6, 6.4, 8.2) # Panel height
yldvar <- c(0.10, 0.30, 0.50, 0.70, 1.00, 1.20, 1.50, 1.80, 2.00)
al_regs <- c("Northern", "Central", "Black Belt", "Southern") # Regions of AL
price <- c(3, 4, 5, 6, 7, 8, 9)
elcprc <- c(0.02, 0.03, 0.04) # Electricity Price
# Define the required columns
required_columns <- c("sprop", "array", "height", "al_regs", "yldvar", "price", "elcprc")
# Check if the columns exist in sbav_profit
missing_columns <- setdiff(required_columns, names(sbav_be_yld))
# Convert the data frame to a data.table for faster operations
setDT(sqav_profit)
sqav_profit <- as.data.frame(
read_feather(file = "Data/sqav_profit.feather")
)
library(tidyverse, warn.conflicts = FALSE, quietly = TRUE)
library(psych, warn.conflicts = FALSE, quietly = TRUE)
library(likert,  warn.conflicts = FALSE, quietly = TRUE) # Likert Items
library(mice,  warn.conflicts = FALSE, quietly = TRUE)
library(openxlsx2, warn.conflicts = FALSE, quietly = TRUE)
library(ggpubr, warn.conflicts = FALSE, quietly = TRUE) # Scatter plot
library(gmodels,  warn.conflicts = FALSE, quietly = TRUE) # Crosstab
library(reshape2, warn.conflicts = FALSE, quietly = TRUE) # Reshape data
library(pacman,  warn.conflicts = FALSE, quietly = TRUE)
library(progress, warn.conflicts = FALSE, quietly = TRUE) # Progress bar
library(arrow, warn.conflicts = FALSE, quietly = TRUE) # Feather
library(plot3D, warn.conflicts = FALSE, quietly = TRUE)
library(plotly, warn.conflicts = FALSE, quietly = TRUE) # 3D plotting
library(lattice, warn.conflicts = FALSE, quietly = TRUE)
library(purrr, warn.conflicts = FALSE, quietly = TRUE)
library(furrr, warn.conflicts = FALSE, quietly = TRUE)
library(pheatmap, warn.conflicts = FALSE, quietly = TRUE)
library(grid, warn.conflicts = FALSE, quietly = TRUE)
library(data.table, warn.conflicts = FALSE, quietly = TRUE)
library(parallel, warn.conflicts = FALSE, quietly = TRUE)
sqav_profit <- as.data.frame(
read_feather(file = "Data/sqav_profit.feather")
)
#head(sqav_profit); tail(sqav_profit)
dim(sqav_profit)
# Convert the data frame to a data.table for faster operations
setDT(sqav_profit)
# Function to process each subset
process_subset <- function(subset) {
subset <- subset[order(-sqavp_wocp)]
# Find the row where yield changes from positive to negative
change_row <- which(diff(sign(subset$sqavp_wocp)) == -2)[1]
# Check if change_row is not NA
if (!is.na(change_row)) {
result_row <- subset[change_row, ]
return(result_row)
} else {
return(NULL)
}
# Split data by unique combinations of the filtering criteria
split_data <- split(sqav_profit,
by = c("al_regs", "array", "sprop",
"elcprc", "price", "height"))
# Apply the process_subset function in parallel
results <- mclapply(split_data,
process_subset,
mc.cores = detectCores())
# Combine all results into a single data.table
sqav_be_yld <- rbindlist(results,
use.names = TRUE,
fill = TRUE) %>%
select(al_regs, array, sprop,panels, elcprc, price,
height, profit, yldvar, yield, sqav_profit, sqavp_wocp)
# Load necessary libraries
library(dplyr)
library(tidyr)
library(reshape2)
# Define the values for each variable
sprop <- c(0, 0.10, 0.20, 0.30, 0.40, 0.50, 0.60, 0.70, 0.80, 0.90, 1.00)
array <- c("Fixed", "Tracking") # Solar Array
height <- c(4.6, 6.4, 8.2) # Panel height
yldvar <- c(0.10, 0.30, 0.50, 0.70, 1.00, 1.20, 1.50, 1.80, 2.00)
al_regs <- c("Northern", "Central", "Black Belt", "Southern") # Regions of AL
price <- c(3, 4, 5, 6, 7, 8, 9)
elcprc <- c(0.02, 0.03, 0.04) # Electricity Price
# Define the required columns
required_columns <- c("sprop", "array", "height", "al_regs", "yldvar", "price", "elcprc")
# Check if the columns exist in sbav_profit
missing_columns <- setdiff(required_columns, names(sbav_be_yld))
sbav_profit <- as.data.frame(
read_feather(file = "Data/sbav_profit.feather")
)
#str(sbav_profit)
#head(sbav_profit); tail(sbav_profit)
dim(sbav_profit)
# Calculate the profit:
# Step 1: Filter the dataframe to get the unique profit values for each price when yldvar is 1
unique_profits <- unique(sbav_profit[sbav_profit$yldvar == 1,
c("price", "profit")])
# Step 2: Create a lookup table for unique profits by price
profit_lookup <- setNames(unique_profits$profit,
unique_profits$price)
# Step 3: Create the new variable sbavp_wocp by subtracting the unique profit from sqav_profit
sbav_profit$sbavp_wocp <- mapply(function(sbav_profit, price) {
profit_to_subtract <- ifelse(price %in%
names(profit_lookup),
profit_lookup[as.character(price)], 0)
return(sbav_profit - profit_to_subtract)
}, sbav_profit$sbav_profit, sbav_profit$price)
rm(unique_profits); rm(profit_lookup)
# Load necessary libraries
library(dplyr)
library(tidyr)
library(reshape2)
# Define the values for each variable
sprop <- c(0, 0.10, 0.20, 0.30, 0.40, 0.50, 0.60, 0.70, 0.80, 0.90, 1.00)
array <- c("Fixed", "Tracking") # Solar Array
height <- c(4.6, 6.4, 8.2) # Panel height
yldvar <- c(0.10, 0.30, 0.50, 0.70, 1.00, 1.20, 1.50, 1.80, 2.00)
al_regs <- c("Northern", "Central", "Black Belt", "Southern") # Regions of AL
price <- c(3, 4, 5, 6, 7, 8, 9)
elcprc <- c(0.02, 0.03, 0.04) # Electricity Price
# Define the required columns
required_columns <- c("sprop", "array", "height", "al_regs", "yldvar", "price", "elcprc")
# Check if the columns exist in sbav_profit
missing_columns <- setdiff(required_columns, names(sbav_be_yld))
# Convert the data frame to a data.table for faster operations
setDT(sbav_profit)
# Function to process each subset
process_subset <- function(subset) {
subset <- subset[order(-sbavp_wocp)]
# Find the row where yield changes from positive to negative
change_row <- which(diff(sign(subset$sbavp_wocp)) == -2)[1]
# Check if change_row is not NA
if (!is.na(change_row)) {
result_row <- subset[change_row, ]
return(result_row)
} else {
return(NULL)
}
# Split data by unique combinations of the filtering criteria
split_data <- split(sbav_profit,
by = c("al_regs", "array", "sprop",
"elcprc", "price", "height"))
# Apply the process_subset function in parallel
results <- mclapply(split_data,
process_subset,
mc.cores = detectCores())
# Combine all results into a single data.table
sbav_be_yld <- rbindlist(results,
use.names = TRUE,
fill = TRUE) %>%
select(al_regs, array, sprop,panels, elcprc, price,
height, profit, yldvar, yield, sbav_profit, sbavp_wocp)
rm(results); rm(split_data); rm(process_subset)
# Load necessary libraries
library(dplyr)
library(tidyr)
library(reshape2)
# Define the values for each variable
sprop <- c(0, 0.10, 0.20, 0.30, 0.40, 0.50, 0.60, 0.70, 0.80, 0.90, 1.00)
array <- c("Fixed", "Tracking") # Solar Array
height <- c(4.6, 6.4, 8.2) # Panel height
yldvar <- c(0.10, 0.30, 0.50, 0.70, 1.00, 1.20, 1.50, 1.80, 2.00)
al_regs <- c("Northern", "Central", "Black Belt", "Southern") # Regions of AL
price <- c(3, 4, 5, 6, 7, 8, 9)
elcprc <- c(0.02, 0.03, 0.04) # Electricity Price
# Define the required columns
required_columns <- c("sprop", "array", "height", "al_regs", "yldvar", "price", "elcprc")
# Check if the columns exist in sbav_profit
missing_columns <- setdiff(required_columns, names(sbav_be_yld))
if (length(missing_columns) > 0) {
stop("Missing columns in sbav_be_yld: ", paste(missing_columns, collapse = ", "))
}
# Generate column and row names using reversed order of expand.grid
col_names <- apply(expand.grid(height, array, sprop), 1, function(x) paste0(x[3], x[2], x[1]))
row_names <- apply(expand.grid(elcprc, price, yldvar, al_regs), 1, function(x) paste0(x, collapse = ""))
=======
height, profit, yldvar, yield, sqav_profit, sqavp_wocp)
rm(results); rm(split_data); rm(process_subset)
write.csv(as.data.frame(sqav_be_yld),
row.names = TRUE,
#col.names = TRUE,
file = "Results/sqav_brkevn_yield.csv")
dim(sqav_be_yld)
# Define the values for each variable
sprop <- c(0, 0.05, 0.10, 0.15, 0.20, 0.25, 0.30, 0.35, 0.40, 0.45, 0.50,
0.55, 0.60, 0.65, 0.70, 0.75, 0.80, 0.85, 0.90, 0.95, 1.00) # Land Proportion
array <- c("Fixed", "Tracking") # Solar Array
height <- c(4.6, 6.4, 8.2) # Panel height
yldvar <- c(0.10, 0.20, 0.30, 0.40, 0.50, 0.60, 0.70, 0.80, 0.90, 1.00,
1.10, 1.20, 1.30, 1.40, 1.50, 1.60, 1.70, 1.80, 1.90, 2.00)
al_regs <- c("Northern", "Central",
"Black Belt", "Southern") # Regions of AL
price <- c(17, 18, 19, 20, 21, 22, 23) # Crop Price
elcprc <- c(0.02, 0.03, 0.04) # Electricity Price
# Define the required columns
required_columns <- c("sprop", "array", "height", "al_regs",
"yldvar", "price", "elcprc")
# Check if the columns exist in tav_profit
missing_columns <- setdiff(required_columns,
names(tav_profit))
if (length(missing_columns) > 0) {
stop("Missing columns in tav_profit: ",
paste(missing_columns, collapse = ", "))
}
# Generate column names using expand.grid without array
col_names <- apply(expand.grid(height, sprop),
1, function(x) paste0(x[2], "%_", x[1]))
# Generate row names using expand.grid with array included
row_names <- apply(expand.grid(elcprc, price,
yldvar, al_regs, array), 1,
function(x) paste0(x[4], "_",
x[3], "_",
x[2], "_",
x[1], "_",
x[5]))
# Create an empty matrix to store the results
result_matrix <- matrix(NA,
nrow = length(row_names),
ncol = length(col_names))
colnames(result_matrix) <- col_names
rownames(result_matrix) <- row_names
# Create a data frame with all combinations of parameters
param_combinations <- expand.grid(elcprc = elcprc,
price = price,
yldvar = yldvar,
al_regs = al_regs,
array = array,
height = height,
sprop = sprop)
# Merge with tav_profit to get av_profit values for each combination
merged_data <- merge(param_combinations,
tav_profit,
by = c("sprop", "array", "height",
"al_regs", "yldvar",
"price", "elcprc"),
all.x = TRUE)
# Reshape merged_data to fill result_matrix with adjusted column and row names
merged_data$col_name <- apply(merged_data[, c("sprop", "height")], 1,
function(x) paste0(x[1], "%_", x[2]))
merged_data$row_name <- apply(merged_data[, c("al_regs", "yldvar",
"price", "elcprc",
"array")], 1,
function(x) paste0(x[1], "_",
x[2], "_",
x[3], "_",
x[4], "_",
x[5]))
# Fill the matrix with av_profit values
for (i in seq_len(nrow(result_matrix))) {
row_condition <- rownames(result_matrix)[i]
row_data <- merged_data[merged_data$row_name == row_condition, ]
if (nrow(row_data) > 0) {
result_matrix[i,
match(row_data$col_name,
colnames(result_matrix))] <- round (
row_data$tav_profit, 2)
}
# Display the result matrix
ct_tav_pft64815 <- as.data.frame(result_matrix) # Table in Excel.
rm(result_matrix); rm(sprop); rm(array); rm(height);
rm(elcprc); rm(price); rm(yldvar); rm(al_regs)
# Define the values for each variable
sprop <- c(0, 0.05, 0.10, 0.15, 0.20, 0.25, 0.30, 0.35, 0.40, 0.45, 0.50,
0.55, 0.60, 0.65, 0.70, 0.75, 0.80, 0.85, 0.90, 0.95, 1.00) # Land Proportion
array <- c("Fixed", "Tracking") # Solar Array
height <- c(4.6, 6.4, 8.2) # Panel height
yldvar <- c(0.10, 0.20, 0.30, 0.40, 0.50, 0.60, 0.70, 0.80, 0.90, 1.00,
1.10, 1.20, 1.30, 1.40, 1.50, 1.60, 1.70, 1.80, 1.90, 2.00)
al_regs <- c("Northern", "Central", "Black Belt", "Southern") # Regions of AL
price <- c(17, 18, 19, 20, 21, 22, 23) # Crop Price
elcprc <- c(0.02, 0.03, 0.04) # Electricity Price
# Define the required columns
required_columns <- c("sprop", "array", "height",
"al_regs", "yldvar", "price", "elcprc")
# Check if the columns exist in tav_profit
missing_columns <- setdiff(required_columns,
names(tav_profit))
if (length(missing_columns) > 0) {
stop("Missing columns in tav_profit: ",
paste(missing_columns,
collapse = ", "))
}
# Generate column names using reversed order of expand.grid
col_names <- apply(expand.grid(height, array, sprop), 1,
function(x) paste0(x[3], x[2], x[1]))
# Generate row names using reversed order of expand.grid
row_names <- apply(expand.grid(elcprc,
price,
yldvar,
al_regs), 1,
function(x) paste0(x, collapse = ""))
# Create an empty matrix to store the results
result_matrix <- matrix(NA,
nrow = length(row_names),
ncol = length(col_names))
colnames(result_matrix) <- col_names
rownames(result_matrix) <- row_names
# Create a data frame with
# all combinations of parameters in reversed order
param_combinations <- expand.grid(elcprc = elcprc,
price = price,
yldvar = yldvar,
al_regs = al_regs,
height = height,
array = array,
sprop = sprop)
# Merge with tav_profit to get tav_profit values for each combination
merged_data <- merge(param_combinations,
tav_profit,
by = required_columns,
all.x = TRUE)
# Reshape merged_data to fill result_matrix with
# reversed column and row names
merged_data$col_name <- apply(
merged_data[, c("sprop", "array", "height")], 1,
function(x) paste0(x[1], x[2], x[3]))
merged_data$row_name <- apply(
merged_data[, c("al_regs", "yldvar", "price", "elcprc")], 1,
function(x) paste0(x[4],
x[3],
x[2],
x[1]))
# Fill the matrix with tav_profit values
for (i in seq_len(nrow(result_matrix))) {
row_condition <- rownames(result_matrix)[i]
row_data <- merged_data[
merged_data$row_name == row_condition, ]
if (nrow(row_data) > 0) {
result_matrix[i,
match(row_data$col_name,
colnames(result_matrix))] <- round(
row_data$tav_profit, 2)
}
ct_tav_pft <- as.data.frame(result_matrix) # Table in Excel.
#Shape crosstab.
# Display the result matrix
rm(result_matrix); rm(sprop); rm(array); rm(height);
rm(elcprc); rm(price); rm(yldvar); rm(al_regs)
write.csv(as.data.frame(ct_tav_pft),
row.names = TRUE,
file = "Results/ct_tav_profit.csv")
dim(ct_tav_pft)
colorcount = length(unique(as.vector(as.matrix(ct_tav_pft[-1]))))
colorcount
heatmap_plot <- pheatmap(t(ct_tav_pft),
#clustering_distance_rows = "correlation",
clustering_distance_rows = "euclidean",
clustering_distance_cols = "euclidean",
clustering_method = "complete",
color = colorRampPalette(c("red",
"yellow",
"green"))(colorcount),
cutree_rows = 5,
cutree_cols = 4,
cluster_rows = FALSE,
cluster_cols = FALSE,
show_rownames = FALSE,
show_colnames = FALSE,
display_numbers = FALSE,
number_format = "%.2f",
cellheight = 3,
cellwidth = 3)
ggsave(heatmap_plot,
height = 8,
width = 16,
units = "in",
file = paste0("Plots/gp_tav_pft", ".png"))
rm(colorcount); rm(heatmap_plot)
# Define the values for each variable
sprop <- c(0, 0.05, 0.10, 0.15, 0.20, 0.25, 0.30, 0.35, 0.40, 0.45, 0.50,
0.55, 0.60, 0.65, 0.70, 0.75, 0.80, 0.85, 0.90, 0.95, 1.00) # Land Proportion
array <- c("Fixed", "Tracking") # Solar Array
height <- c(4.6, 6.4, 8.2) # Panel height
yldvar <- c(0.10, 0.20, 0.30, 0.40, 0.50, 0.60, 0.70, 0.80, 0.90, 1.00,
1.10, 1.20, 1.30, 1.40, 1.50, 1.60, 1.70, 1.80, 1.90, 2.00)
al_regs <- c("Northern", "Central", "Black Belt", "Southern") # Regions of AL
price <- c(17, 18, 19, 20, 21, 22, 23) # Crop Price
elcprc <- c(0.02, 0.03, 0.04) # Electricity Price
# Define the required columns
required_columns <- c("sprop", "array", "height",
"al_regs", "yldvar", "price", "elcprc")
# Check if the columns exist in tav_profit
missing_columns <- setdiff(required_columns,
names(tav_profit))
if (length(missing_columns) > 0) {
stop("Missing columns in tavp_wocp: ",
paste(missing_columns, collapse = ", "))
}
# Generate column names using reversed order of expand.grid
col_names <- apply(expand.grid(height, array, sprop), 1,
function(x) paste0(x[3], x[2], x[1]))
# Generate row names using reversed order of expand.grid
row_names <- apply(expand.grid(elcprc,
price,
yldvar,
al_regs), 1,
function(x) paste0(x, collapse = ""))
>>>>>>> 4fb1d2f5116ddb5b0c5733cd1f41967386431d66
# Create an empty matrix to store the results
result_matrix <- matrix(NA, nrow = length(row_names), ncol = length(col_names))
colnames(result_matrix) <- col_names
rownames(result_matrix) <- row_names
<<<<<<< HEAD
# Create a data frame with all combinations of parameters in reversed order
param_combinations <- expand.grid(elcprc = elcprc, price = price, yldvar = yldvar, al_regs = al_regs, height = height, array = array, sprop = sprop)
# Merge with sbav_be_yld to get values for each combination
merged_data <- merge(param_combinations, sbav_be_yld, by = required_columns, all.x = TRUE)
# Create column and row identifiers for merged_data
merged_data <- merged_data %>%
mutate(col_name = paste0(sprop, array, height),
row_name = paste0(al_regs, price, yldvar, elcprc))
# Fill the result_matrix with sbav_be_yld values
=======
# Create a data frame with
# all combinations of parameters in reversed order
param_combinations <- expand.grid(elcprc = elcprc,
price = price,
yldvar = yldvar,
al_regs = al_regs,
height = height,
array = array,
sprop = sprop)
# Merge with tav_profit to get tav_profit values for each combination
merged_data <- merge(param_combinations,
tav_profit,
by = required_columns,
all.x = TRUE)
# Reshape merged_data to fill result_matrix with
# reversed column and row names
merged_data$col_name <- apply(
merged_data[, c("sprop", "array", "height")], 1,
function(x) paste0(x[1], x[2], x[3]))
merged_data$row_name <- apply(
merged_data[, c("al_regs", "yldvar", "price", "elcprc")], 1,
function(x) paste0(x[4],
x[3],
x[2],
x[1]))
# Fill the matrix with tav_profit values
>>>>>>> 4fb1d2f5116ddb5b0c5733cd1f41967386431d66
for (i in seq_len(nrow(result_matrix))) {
row_condition <- rownames(result_matrix)[i]
row_data <- merged_data[merged_data$row_name == row_condition, ]
if (nrow(row_data) > 0) {
<<<<<<< HEAD
result_matrix[i, match(row_data$col_name, colnames(result_matrix))] <- round(row_data$yield, 2)
}
# Add four columns at the beginning
result_matrix <- cbind(matrix(NA, nrow = nrow(result_matrix), ncol = 4), result_matrix)
colnames(result_matrix)[1:4] <- c("al_regs", "yldvar", "price", "elcprc")
# Extract the variable values from row names and fill the new columns
row_split <- strsplit(rownames(result_matrix), "(?<=\\d)(?=\\D)", perl = TRUE)
result_matrix[, "al_regs"] <- sapply(row_split, function(x) x[4])
result_matrix[, "yldvar"] <- as.numeric(sapply(row_split, function(x) x[3]))
result_matrix[, "price"] <- as.numeric(sapply(row_split, function(x) x[2]))
result_matrix[, "elcprc"] <- as.numeric(sapply(row_split, function(x) x[1]))
# Add three rows at the top
result_matrix <- rbind(matrix(NA, nrow = 3, ncol = ncol(result_matrix)), result_matrix)
rownames(result_matrix)[1:3] <- c("sprop", "array", "height")
# Extract the variable values from column names and fill the new rows
col_split <- strsplit(colnames(result_matrix)[-c(1:4)], "(?<=\\d)(?=\\D)", perl = TRUE)
result_matrix["sprop", -c(1:4)] <- sapply(col_split, function(x) x[3])
result_matrix["array", -c(1:4)] <- sapply(col_split, function(x) x[2])
result_matrix["height", -c(1:4)] <- as.numeric(sapply(col_split, function(x) x[1]))
# Convert the matrix to a data frame
ct_sbav_be_yld1 <- as.data.frame(result_matrix)
# # Save the result to a CSV file
# write.csv(ct_sbav_be_yld, row.names = TRUE, file = "Results/ct_sbav_be_yld.csv")
# Check the dimensions of the final data frame
dim(ct_sbav_be_yld1)
View(ct_sbav_be_yld1)
# Load necessary libraries
library(dplyr)
library(tidyr)
library(reshape2)
# Define the values for each variable
sprop <- c(0, 0.10, 0.20, 0.30, 0.40, 0.50, 0.60, 0.70, 0.80, 0.90, 1.00)
array <- c("Fixed", "Tracking") # Solar Array
height <- c(4.6, 6.4, 8.2) # Panel height
yldvar <- c(0.10, 0.30, 0.50, 0.70, 1.00, 1.20, 1.50, 1.80, 2.00)
al_regs <- c("Northern", "Central", "Black Belt", "Southern") # Regions of AL
price <- c(3, 4, 5, 6, 7, 8, 9)
elcprc <- c(0.02, 0.03, 0.04) # Electricity Price
# Define the required columns
required_columns <- c("sprop", "array", "height", "al_regs", "yldvar", "price", "elcprc")
# Check if the columns exist in sbav_profit
missing_columns <- setdiff(required_columns, names(sbav_be_yld))
if (length(missing_columns) > 0) {
stop("Missing columns in sbav_be_yld: ", paste(missing_columns, collapse = ", "))
=======
result_matrix[i,
match(row_data$col_name,
colnames(result_matrix))] <- round(
row_data$tavp_wocp, 2)
}
ct_tavp_wocp <- as.data.frame(result_matrix) # Table in Excel.
rm(result_matrix)
dim(ct_tavp_wocp)
write.csv(as.data.frame(ct_tavp_wocp),
row.names = TRUE,
file = "Results/ct_tavp_wocp.csv")
colorcount = length(unique(as.vector(as.matrix(ct_tavp_wocp[-1]))))
colorcount
heatmap_plot <- pheatmap(t(ct_tavp_wocp),
#clustering_distance_rows = "correlation",
clustering_distance_rows = "euclidean",
clustering_distance_cols = "euclidean",
clustering_method = "complete",
color = colorRampPalette(c("red",
"yellow",
"green"))(colorcount),
cutree_rows = 5,
cutree_cols = 4,
cluster_rows = FALSE,
cluster_cols = FALSE,
show_rownames = FALSE,
show_colnames = FALSE,
display_numbers = FALSE,
number_format = "%.2f",
cellheight = 3,
cellwidth = 3)
ggsave(heatmap_plot,
height = 8,
width = 16,
units = "in",
file = paste0("Plots/gp_tavp_wocp", ".png"))
rm(heatmap_plot); rm(colorcount)
# Define the values for each variable
sprop <- c(0, 0.05, 0.10, 0.15, 0.20, 0.25, 0.30, 0.35, 0.40, 0.45, 0.50,
0.55, 0.60, 0.65, 0.70, 0.75, 0.80, 0.85, 0.90, 0.95, 1.00) # Land Proportion
array <- c("Fixed", "Tracking") # Solar Array
height <- c(4.6, 6.4, 8.2) # Panel height
yldvar <- c(0.10, 0.20, 0.30, 0.40, 0.50, 0.60, 0.70, 0.80, 0.90, 1.00,
1.10, 1.20, 1.30, 1.40, 1.50, 1.60, 1.70, 1.80, 1.90, 2.00)
al_regs <- c("Northern", "Central", "Black Belt", "Southern") # Regions of AL
price <- c(17, 18, 19, 20, 21, 22, 23) # Crop Price
elcprc <- c(0.02, 0.03, 0.04) # Electricity Price
# Define the required columns
required_columns <- c("sprop", "array", "height",
"al_regs", "yldvar", "price", "elcprc")
# Check if the columns exist in tav_profit
missing_columns <- setdiff(required_columns,
names(tav_be_yld))
if (length(missing_columns) > 0) {
stop("Missing columns in tavp_be_yld: ",
paste(missing_columns, collapse = ", "))
}
# Generate column names using reversed order of expand.grid
col_names <- apply(expand.grid(height, array, sprop), 1,
function(x) paste0(x[3], x[2], x[1]))
# Generate row names using reversed order of expand.grid
row_names <- apply(expand.grid(elcprc,
price,
yldvar,
al_regs), 1,
function(x) paste0(x, collapse = ""))
# Create an empty matrix to store the results
result_matrix <- matrix(NA, nrow = length(row_names),
ncol = length(col_names))
colnames(result_matrix) <- col_names
rownames(result_matrix) <- row_names
# Create a data frame with
# all combinations of parameters in reversed order
param_combinations <- expand.grid(elcprc = elcprc,
price = price,
yldvar = yldvar,
al_regs = al_regs,
height = height,
array = array,
sprop = sprop)
# Merge with tav_be_yld to get tav_be_yld values for each combination
merged_data <- merge(param_combinations,
tav_be_yld,
by = required_columns,
all.x = TRUE)
# Reshape merged_data to fill result_matrix with
# reversed column and row names
merged_data$col_name <- apply(
merged_data[, c("sprop", "array", "height")], 1,
function(x) paste0(x[1], x[2], x[3]))
merged_data$row_name <- apply(
merged_data[, c("al_regs", "yldvar", "price", "elcprc")], 1,
function(x) paste0(x[4],
x[3],
x[2],
x[1]))
# Fill the matrix with tav_profit values
for (i in seq_len(nrow(result_matrix))) {
row_condition <- rownames(result_matrix)[i]
row_data <- merged_data[
merged_data$row_name == row_condition, ]
if (nrow(row_data) > 0) {
result_matrix[i,
match(row_data$col_name,
colnames(result_matrix))] <- round(
row_data$yield, 2)
}
ct_tavp_be_yld <- as.data.frame(result_matrix) # Table in Excel.
write.csv(as.data.frame(ct_tavp_be_yld),
row.names = TRUE,
file = "Results/ct_tavp_be_yld.csv")
dim(ct_tavp_be_yld)
rm(result_matrix)
colorcount = length(unique(as.vector(as.matrix(ct_tavp_be_yld[-1]))))
colorcount
heatmap_plot <- pheatmap(t(ct_tavp_be_yld),
#clustering_distance_rows = "correlation",
clustering_distance_rows = "euclidean",
clustering_distance_cols = "euclidean",
clustering_method = "complete",
color = colorRampPalette(c("red",
"yellow",
"green"))(colorcount),
cutree_rows = 5,
cutree_cols = 4,
cluster_rows = FALSE,
cluster_cols = FALSE,
show_rownames = FALSE,
show_colnames = FALSE,
display_numbers = FALSE,
number_format = "%.2f",
cellheight = 3,
cellwidth = 3)
ggsave(heatmap_plot,
height = 8,
width = 16,
units = "in",
file = paste0("Plots/gp_tavp_be_yld", ".png"))
rm(heatmap_plot); rm(colorcount)
combinations <- expand.grid(
yldvar = c(0.1, 0.3, 0.5, 0.7, 1, 1.20, 1.5, 1.80, 2), # Yield variation
price = c(17, 20, 23), # Tomato price
elcprc = c(0.03, 0.04, 0.05) #Electricity price
)
# Iterate over the combinations and create the plots
for (combo in seq_len(nrow(combinations))) {
filtered_data <- tav_profit %>%
filter(
yldvar == combinations$yldvar[combo],
price == combinations$price[combo],
elcprc == combinations$elcprc[combo]
)
# If by panel, put panels below in color and group.
tav_sp_plot <- ggplot(data = filtered_data,
mapping = aes(x = al_regs,
y = tav_profit,
color = factor(panels),
group = factor(panels))) +
geom_line() +
geom_point() +
facet_grid(height ~ array,
labeller = as_labeller(
c(
"4.6" = "4.6 ft. Height",
"6.4" = "6.4 ft. Height",
"8.2" = "8.2 ft. Height",
Tracking = "Single Axis Rotation",
Fixed = "Fixed Open Rack"
))) +
guides(color = guide_legend(ncol = 1,
reverse = TRUE)) +
scale_x_discrete(limits = c("Northern", "Central",
"Black Belt", "Southern"),
labels = c("North", "Center",
"B Belt", "South")) +
guides(color = guide_legend(ncol = 2,
reverse = TRUE)) +
labs(x = "Regions of Alabama",
y = "Profit ($) from Tomato Agrivoltaic System",
color = "Number of Solar \n Panels per Acre",
title = (list(combinations[combo,]))
) +
theme(strip.background = element_blank())
# Add horizontal line at y = 0 if y has both positive and negative values
if (min(filtered_data$tav_profit) < 0 &
max(filtered_data$tav_profit) > 0) {
tav_sp_plot <- tav_sp_plot +
geom_hline(yintercept = 0,
linewidth = 0.30,
linetype = "dashed",
color = "black")
}
print(combinations[combo,])
print(tav_sp_plot)
ggsave(file = paste0("Plots/tav_sp_", combo, ".png"))
#break
}
combinations <- expand.grid(
sprop = c(0, 0.25, 0.50, 0.75, 1.00), # Solar proportion
price = c(17, 20, 23), # Tomato price
elcprc = c(0.03, 0.04, 0.05) #Electricity price
)
# Iterate over the combinations and create the plots
for (combo in seq_len(nrow(combinations))) {
filtered_data <- tav_profit %>%
filter(
sprop == combinations$sprop[combo],
price == combinations$price[combo],
elcprc == combinations$elcprc[combo]
)
# If by yield, put yield below in color and group.
tav_yv_plot <- ggplot(data = filtered_data,
mapping = aes(x = al_regs,
y = tav_profit,
color = factor(yield),
group = factor(yield))) +
geom_line() +
geom_point() +
facet_grid(height ~ array,
labeller = as_labeller(
c(
"4.6" = "4.6 ft. Height",
"6.4" = "6.4 ft. Height",
"8.2" = "8.2 ft. Height",
Tracking = "Single Axis Rotation",
Fixed = "Fixed Open Rack"
))) +
guides(color = guide_legend(ncol = 1,
reverse = TRUE)) +
scale_x_discrete(limits = c("Northern", "Central",
"Black Belt", "Southern"),
labels = c("North", "Center",
"B Belt", "South")) +
guides(color = guide_legend(ncol = 2,
reverse = TRUE)) +
labs(x = "Regions of Alabama",
y = "Profit ($) from Tomato Agrivoltaic System",
color = "Tomato Yield \n (25 Lb Buckets)",
title = (list(combinations[combo,]))
) +
theme(strip.background = element_blank())
# Add horizontal line at y = 0 if y has both positive and negative values
if (min(filtered_data$tav_profit) < 0 &
max(filtered_data$tav_profit) > 0) {
tav_yv_plot <- tav_yv_plot +
geom_hline(yintercept = 0,
linewidth = 0.30,
linetype = "dashed",
color = "black")
}
print(combinations[combo,])
print(tav_yv_plot)
ggsave(file = paste0("Plots/tav_yv_", combo, ".png"))
#break
>>>>>>> 4fb1d2f5116ddb5b0c5733cd1f41967386431d66
}
# Generate column and row names using reversed order of expand.grid
col_names <- apply(expand.grid(height, array, sprop), 1, function(x) paste0(x[3], x[2], x[1]))
row_names <- apply(expand.grid(elcprc, price, yldvar, al_regs), 1, function(x) paste0(x, collapse = ""))
# Create an empty matrix to store the results
result_matrix <- matrix(NA, nrow = length(row_names), ncol = length(col_names))
colnames(result_matrix) <- col_names
rownames(result_matrix) <- row_names
# Create a data frame with all combinations of parameters in reversed order
param_combinations <- expand.grid(elcprc = elcprc, price = price, yldvar = yldvar, al_regs = al_regs, height = height, array = array, sprop = sprop)
# Merge with sbav_be_yld to get values for each combination
merged_data <- merge(param_combinations, sbav_be_yld, by = required_columns, all.x = TRUE)
# Create column and row identifiers for merged_data
merged_data <- merged_data %>%
mutate(col_name = paste0(array, height),
row_name = paste0(al_regs, sprintf("%02d", price), sprintf("%.2f", yldvar), sprintf("%.2f", elcprc)))
# Fill the result_matrix with sbav_be_yld values
for (i in seq_len(nrow(result_matrix))) {
row_condition <- rownames(result_matrix)[i]
row_data <- merged_data[merged_data$row_name == row_condition, ]
if (nrow(row_data) > 0) {
result_matrix[i, match(row_data$col_name, colnames(result_matrix))] <- round(row_data$yield, 2)
}
# Add four columns at the beginning
result_matrix <- cbind(matrix(NA, nrow = nrow(result_matrix), ncol = 4), result_matrix)
colnames(result_matrix)[1:4] <- c("al_regs", "yldvar", "price", "elcprc")
# Extract the variable values from row names and fill the new columns
row_split <- strsplit(rownames(result_matrix), "(?<=\\d)(?=\\D)", perl = TRUE)
result_matrix[, "al_regs"] <- sapply(row_split, function(x) x[4])
result_matrix[, "yldvar"] <- as.numeric(sapply(row_split, function(x) x[3]))
result_matrix[, "price"] <- as.numeric(sapply(row_split, function(x) x[2]))
result_matrix[, "elcprc"] <- as.numeric(sapply(row_split, function(x) x[1]))
# Add three rows at the top
result_matrix <- rbind(matrix(NA, nrow = 3, ncol = ncol(result_matrix)), result_matrix)
rownames(result_matrix)[1:3] <- c("sprop", "array", "height")
# Extract the variable values from column names and fill the new rows
col_split <- strsplit(colnames(result_matrix)[-c(1:4)], "(?<=\\d)(?=\\D)", perl = TRUE)
result_matrix["sprop", -c(1:4)] <- sapply(col_split, function(x) "Fixed")
result_matrix["array", -c(1:4)] <- sapply(col_split, function(x) x[2])
result_matrix["height", -c(1:4)] <- as.numeric(sapply(col_split, function(x) x[1]))
# Convert the matrix to a data frame
ct_sbav_be_yld1 <- as.data.frame(result_matrix)
# Check the dimensions of the final data frame
dim(ct_sbav_be_yld1)
View(ct_sbav_be_yld1)
