# Map Theme:
plottheme <- ggplot() +
theme_void() +
# Mapping theme:
theme(axis.title = element_blank(),
axis.ticks = element_blank(),
axis.text = element_blank(),
panel.border = element_blank(),
plot.margin = margin(t = 0,
r = 0,
b = 0,
l = 0,
unit = "cm"),
plot.title = element_text(hjust = 0.5),
plot.background = element_rect(fill = "white",
color = "black",
linewidth = 0),
panel.background = element_rect(fill = "white",
color = "black",
linewidth = 0),
panel.grid.major.x = element_line(color = "lightgrey",
linetype = 2,
linewidth = 0),
panel.grid.minor.x = element_line(color = "lightgrey",
linetype = 2,
linewidth = 0),
panel.grid.major.y = element_line(color = "grey",
linetype = 2,
linewidth = 0),
panel.grid.minor.y = element_line(color = "grey",
linetype = 2,
linewidth = 0),
axis.line.x.top = element_line(color = "white",
linetype = 2,
linewidth = 0),
axis.line.y.right = element_line(color = "white",
linetype = 2,
linewidth = 0),
axis.line.x.bottom = element_line(color = "black",
linetype = 1,
linewidth = 0),
axis.line.y.left = element_line(color = "black",
linetype = 1,
linewidth = 0),
# Text formatting:
text = element_text(family = "serif", # font
size = 12, # font size
colour = "black"# font color
),
legend.position = c(0.95, -0.05),
legend.key = element_rect(color = "black",
fill = NA,
linewidth = 0.05,
linetype = 1),
legend.justification = "right",
legend.direction = "horizontal")
tav_profit <- as.data.frame(
read_feather(file = "Data/tav_profit.feather")
)
#str(tav_profit)
#head(tav_profit); head(tav_profit)
dim(tav_profit)
# Calculate the profit:
# Step 1: Filter the dataframe to get the unique profit values for each price when yldvar is 1
unique_profits <- unique(tav_profit[tav_profit$yldvar == 1,
c("price", "profit")])
# Step 2: Create a lookup table for unique profits by price
profit_lookup <- setNames(unique_profits$profit,
unique_profits$price)
# Step 3: Create the new variable tavp_wocp by subtracting the unique profit from tav_profit
tav_profit$tavp_wocp <- mapply(function(tav_profit, price) {
profit_to_subtract <- ifelse(price %in%
names(profit_lookup),
profit_lookup[as.character(price)], 0)
return(tav_profit - profit_to_subtract)
}, tav_profit$tav_profit, tav_profit$price)
unique_profits
tav_profit[1:21,]
rm(unique_profits); rm(profit_lookup)
tav_profit$tavp_wosp <- tav_profit$tav_profit - tav_profit$eannprof
# Convert the data frame to a data.table for faster operations
setDT(tav_profit)
# Function to process each subset
process_subset <- function(subset) {
subset <- subset[order(-tavp_wocp)]
# Find the row where yield changes from positive to negative
change_row <- which(diff(sign(subset$tavp_wocp)) == -2)[1]
# Check if change_row is not NA
if (!is.na(change_row)) {
result_row <- subset[change_row, ]
return(result_row)
} else {
return(NULL)
}
# Split data by unique combinations of the filtering criteria
split_data <- split(tav_profit,
by = c("al_regs", "array", "sprop",
"elcprc", "price", "height"))
# Apply the process_subset function in parallel
results <- mclapply(split_data,
process_subset,
mc.cores = detectCores())
# Combine all results into a single data.table
tav_be_yld <- rbindlist(results,
use.names = TRUE,
fill = TRUE) %>%
select(al_regs, array, sprop,panels, elcprc, price,
height, profit, yldvar, yield, tav_profit, tavp_wocp)
rm(results); rm(split_data); rm(process_subset)
write.csv(as.data.frame(tav_be_yld),
row.names = TRUE,
#col.names = TRUE,
file = "Results/tav_brkevn_yield.csv")
dim(tav_be_yld)
# Convert the data frame to a data.table for faster operations
setDT(tav_profit)
# Function to process each subset
process_subset <- function(subset) {
subset <- subset[order(-tavp_wosp)]
# Find the row where yield changes from positive to negative
change_row <- which(diff(sign(subset$tavp_wosp)) == -2)[1]
# Check if change_row is not NA
if (!is.na(change_row)) {
result_row <- subset[change_row, ]
return(result_row)
} else {
return(NULL)
}
# Split data by unique combinations of the filtering criteria
split_data <- split(tav_profit,
by = c("al_regs", "array", "sprop",
"elcprc", "price", "height"))
# Apply the process_subset function in parallel
results <- mclapply(split_data,
process_subset,
mc.cores = detectCores())
# Combine all results into a single data.table
tav_be_pden <- rbindlist(results,
use.names = TRUE,
fill = TRUE) %>%
select(al_regs, array, sprop,panels, elcprc, price,
height, profit, yldvar, yield, tav_profit, tavp_wosp)
rm(results); rm(split_data); rm(process_subset)
sbav_profit <- as.data.frame(
read_feather(file = "Data/sbav_profit.feather")
)
#str(sbav_profit)
#head(sbav_profit); tail(sbav_profit)
dim(sbav_profit)
# Calculate the profit:
# Step 1: Filter the dataframe to get the unique profit values for each price when yldvar is 1
unique_profits <- unique(sbav_profit[sbav_profit$yldvar == 1,
c("price", "profit")])
# Step 2: Create a lookup table for unique profits by price
profit_lookup <- setNames(unique_profits$profit,
unique_profits$price)
# Step 3: Create the new variable sbavp_wocp by subtracting the unique profit from sqav_profit
sbav_profit$sbavp_wocp <- mapply(function(sbav_profit, price) {
profit_to_subtract <- ifelse(price %in%
names(profit_lookup),
profit_lookup[as.character(price)], 0)
return(sbav_profit - profit_to_subtract)
}, sbav_profit$sbav_profit, sbav_profit$price)
rm(unique_profits); rm(profit_lookup)
sbav_profit$sbavp_wosp <- sbav_profit$sbav_profit - sbav_profit$eannprof
# Convert the data frame to a data.table for faster operations
setDT(sbav_profit)
# Function to process each subset
process_subset <- function(subset) {
subset <- subset[order(-sbavp_wocp)]
# Find the row where yield changes from positive to negative
change_row <- which(diff(sign(subset$sbavp_wocp)) == -2)[1]
# Check if change_row is not NA
if (!is.na(change_row)) {
result_row <- subset[change_row, ]
return(result_row)
} else {
return(NULL)
}
# Split data by unique combinations of the filtering criteria
split_data <- split(sbav_profit,
by = c("al_regs", "array", "sprop",
"elcprc", "price", "height"))
# Apply the process_subset function in parallel
results <- mclapply(split_data,
process_subset,
mc.cores = detectCores())
# Combine all results into a single data.table
sbav_be_yld <- rbindlist(results,
use.names = TRUE,
fill = TRUE) %>%
select(al_regs, array, sprop,panels, elcprc, price,
height, profit, yldvar, yield, sbav_profit, sbavp_wocp)
rm(results); rm(split_data); rm(process_subset)
write.csv(as.data.frame(sbav_be_yld),
row.names = TRUE,
#col.names = TRUE,
file = "Results/sbav_brkevn_yield.csv")
dim(sbav_be_yld)
# Convert the data frame to a data.table for faster operations
setDT(sbav_profit)
# Function to process each subset
process_subset <- function(subset) {
subset <- subset[order(-sbavp_wosp)]
# Find the row where yield changes from positive to negative
change_row <- which(diff(sign(subset$sbavp_wosp)) == -2)[1]
# Check if change_row is not NA
if (!is.na(change_row)) {
result_row <- subset[change_row, ]
return(result_row)
} else {
return(NULL)
}
# Split data by unique combinations of the filtering criteria
split_data <- split(sbav_profit,
by = c("al_regs", "array", "sprop",
"elcprc", "price", "height"))
# Apply the process_subset function in parallel
results <- mclapply(split_data,
process_subset,
mc.cores = detectCores())
# Combine all results into a single data.table
sbav_be_pden <- rbindlist(results,
use.names = TRUE,
fill = TRUE) %>%
select(al_regs, array, sprop,panels, elcprc, price,
height, profit, yldvar, yield, sbav_profit, sbavp_wosp)
rm(results); rm(split_data); rm(process_subset)
sqav_profit <- as.data.frame(
read_feather(file = "Data/sqav_profit.feather")
)
#head(sqav_profit); tail(sqav_profit)
dim(sqav_profit)
# Calculate the profit:
# Step 1: Filter the dataframe to get the unique profit values for each price when yldvar is 1
unique_profits <- unique(sqav_profit[sqav_profit$yldvar == 1,
c("price", "profit")])
# Step 2: Create a lookup table for unique profits by price
profit_lookup <- setNames(unique_profits$profit,
unique_profits$price)
# Step 3: Create the new variable sbavp_wocp by subtracting the unique profit from sqav_profit
sqav_profit$sqavp_wocp <- mapply(function(sqav_profit, price) {
profit_to_subtract <- ifelse(price %in%
names(profit_lookup),
profit_lookup[as.character(price)], 0)
return(sqav_profit - profit_to_subtract)
}, sqav_profit$sqav_profit, sqav_profit$price)
unique_profits
rm(unique_profits); rm(profit_lookup)
sqav_profit$sqavp_wosp <- sqav_profit$sqav_profit - sqav_profit$eannprof
# Convert the data frame to a data.table for faster operations
setDT(sqav_profit)
# Function to process each subset
process_subset <- function(subset) {
subset <- subset[order(-sqavp_wocp)]
# Find the row where yield changes from positive to negative
change_row <- which(diff(sign(subset$sqavp_wocp)) == -2)[1]
# Check if change_row is not NA
if (!is.na(change_row)) {
result_row <- subset[change_row, ]
return(result_row)
} else {
return(NULL)
}
# Split data by unique combinations of the filtering criteria
split_data <- split(sqav_profit,
by = c("al_regs", "array", "sprop",
"elcprc", "price", "height"))
# Apply the process_subset function in parallel
results <- mclapply(split_data,
process_subset,
mc.cores = detectCores())
# Combine all results into a single data.table
sqav_be_yld <- rbindlist(results,
use.names = TRUE,
fill = TRUE) %>%
select(al_regs, array, sprop,panels, elcprc, price,
height, profit, yldvar, yield, sqav_profit, sqavp_wocp)
rm(results); rm(split_data); rm(process_subset)
write.csv(as.data.frame(sqav_be_yld),
row.names = TRUE,
#col.names = TRUE,
file = "Results/sqav_brkevn_yield.csv")
dim(sqav_be_yld)
# Convert the data frame to a data.table for faster operations
setDT(sqav_profit)
# Function to process each subset
process_subset <- function(subset) {
subset <- subset[order(-sqavp_wosp)]
# Find the row where yield changes from positive to negative
change_row <- which(diff(sign(subset$sqavp_wosp)) == -2)[1]
# Check if change_row is not NA
if (!is.na(change_row)) {
result_row <- subset[change_row, ]
return(result_row)
} else {
return(NULL)
}
# Split data by unique combinations of the filtering criteria
split_data <- split(sqav_profit,
by = c("al_regs", "array", "sprop",
"elcprc", "price", "height"))
# Apply the process_subset function in parallel
results <- mclapply(split_data,
process_subset,
mc.cores = detectCores())
# Combine all results into a single data.table
sqav_be_pden <- rbindlist(results,
use.names = TRUE,
fill = TRUE) %>%
select(al_regs, array, sprop,panels, elcprc, price,
height, profit, yldvar, yield, sqav_profit, sqavp_wosp)
rm(results); rm(split_data); rm(process_subset)
write.csv(as.data.frame(sqav_be_pden),
row.names = TRUE,
#col.names = TRUE,
file = "Results/sqav_brkevn_pden.csv")
dim(sqav_be_pden)
# Define the values for each variable
sprop <- sprop <- c(0.05, 0.10, 0.30, 0.50, 0.60, 0.70, 0.80, 0.85)
array <- c("Fixed", "Tracking") # Solar Array
height <- c(4.6, 6.4, 8.2) # Panel height
yldvar <- c(0, 0.10, 0.20, 0.30, 0.40, 0.50, 0.60, 0.70, 0.80, 0.90, 1.00,
1.10, 1.20, 1.30, 1.40, 1.50, 1.60, 1.70, 1.80, 1.90, 2.00)
al_regs <- c("Northern", "Central", "Black Belt", "Southern") # Regions AL
price <- c(17, 20, 23) # Crop Price
elcprc <- c(0.02, 0.03, 0.04) # Electricity Price
# Define the required columns
required_columns <- c("sprop", "array", "height",
"al_regs", "yldvar", "price", "elcprc")
# Check if the columns exist in tav_profit
missing_columns <- setdiff(required_columns,
names(tav_profit))
if (length(missing_columns) > 0) {
stop("Missing columns in tav_profit: ",
paste(missing_columns,
collapse = ", "))
}
# Generate column names using reversed order of expand.grid
col_names <- apply(expand.grid(height, array, sprop), 1,
function(x) paste0(x[3], x[2], x[1]))
# Generate row names using reversed order of expand.grid
row_names <- apply(expand.grid(elcprc,
price,
yldvar,
al_regs), 1,
function(x) paste0(x, collapse = ""))
# Create an empty matrix to store the results
result_matrix <- matrix(NA,
nrow = length(row_names),
ncol = length(col_names))
colnames(result_matrix) <- col_names
rownames(result_matrix) <- row_names
# Create a data frame with
# all combinations of parameters in reversed order
param_combinations <- expand.grid(elcprc = elcprc,
price = price,
yldvar = yldvar,
al_regs = al_regs,
height = height,
array = array,
sprop = sprop)
# Merge with tav_profit to get tav_profit values for each combination
merged_data <- merge(param_combinations,
tav_profit,
by = required_columns,
all.x = TRUE)
# Reshape merged_data to fill result_matrix with
# reversed column and row names
merged_data$col_name <- apply(
merged_data[, c("sprop", "array", "height")], 1,
function(x) paste0(x[1], x[2], x[3]))
merged_data$row_name <- apply(
merged_data[, c("al_regs", "yldvar", "price", "elcprc")], 1,
function(x) paste0(x[4],
x[3],
x[2],
x[1]))
# Fill the matrix with tav_profit values
for (i in seq_len(nrow(result_matrix))) {
row_condition <- rownames(result_matrix)[i]
row_data <- merged_data[
merged_data$row_name == row_condition, ]
if (nrow(row_data) > 0) {
result_matrix[i,
match(row_data$col_name,
colnames(result_matrix))] <- round(
row_data$tav_profit, 0)
}
ct_tav_pft <- as.data.frame(result_matrix) # Table in Excel.
#Shape crosstab.
# Display the result matrix
rm(result_matrix); rm(sprop); rm(array); rm(height);
rm(elcprc); rm(price); rm(yldvar); rm(al_regs)
write.csv(as.data.frame(ct_tav_pft),
row.names = TRUE,
file = "Results/ct_tav_profit.csv")
dim(ct_tav_pft)
colorcount = length(unique(as.vector(as.matrix(ct_tav_pft[-1]))))
colorcount
heatmap_plot <- pheatmap(t(ct_tav_pft),
#clustering_distance_rows = "correlation",
clustering_distance_rows = "euclidean",
clustering_distance_cols = "euclidean",
clustering_method = "complete",
angle_col = 90,
na_col = "white",
color = colorRampPalette(c("green",
"yellow",
"red"))(colorcount),
cellheight = 13,
cellwidth = 14,
fontsize = 12,
fontsize_row = 12,
fontsize_col = 12,
number_color = "white",
fontsize_number = 5,
cluster_rows = FALSE,
cluster_cols = FALSE,
show_rownames = TRUE,
show_colnames = TRUE,
display_numbers = TRUE,
number_format = "%.0f",
legend_breaks = uniquevalue
)
ggsave(heatmap_plot,
height = 8,
width = 12,
units = "in",
#height = 40,
#width = 80,
#units = "in",
limitsize = FALSE,
file = paste0("Plots/gp_tav_pft", ".png"))
uniquevalue = unique(as.vector(as.matrix(ct_tav_pft[-1])))
uniquevalue
colorcount = length(unique(as.vector(as.matrix(ct_tav_pft[-1]))))
colorcount
heatmap_plot <- pheatmap(t(ct_tav_pft),
#clustering_distance_rows = "correlation",
clustering_distance_rows = "euclidean",
clustering_distance_cols = "euclidean",
clustering_method = "complete",
angle_col = 90,
na_col = "white",
color = colorRampPalette(c("green",
"yellow",
"red"))(colorcount),
cellheight = 13,
cellwidth = 14,
fontsize = 12,
fontsize_row = 12,
fontsize_col = 12,
number_color = "white",
fontsize_number = 5,
cluster_rows = FALSE,
cluster_cols = FALSE,
show_rownames = TRUE,
show_colnames = TRUE,
display_numbers = TRUE,
number_format = "%.0f",
legend_breaks = uniquevalue
)
ggsave(heatmap_plot,
height = 8,
width = 12,
units = "in",
#height = 40,
#width = 80,
#units = "in",
limitsize = FALSE,
file = paste0("Plots/gp_tav_pft", ".png"))
#rm(colorcount); rm(heatmap_plot)
#uniquevalue = unique(as.vector(as.matrix(ct_tav_pft[-1])))
#uniquevalue
colorcount = length(unique(as.vector(as.matrix(ct_tav_pft[-1]))))
colorcount
heatmap_plot <- pheatmap(t(ct_tav_pft),
#clustering_distance_rows = "correlation",
clustering_distance_rows = "euclidean",
clustering_distance_cols = "euclidean",
clustering_method = "complete",
angle_col = 90,
na_col = "white",
color = colorRampPalette(c("green",
"yellow",
"red"))(colorcount),
cellheight = 13,
cellwidth = 14,
fontsize = 12,
fontsize_row = 12,
fontsize_col = 12,
number_color = "white",
fontsize_number = 5,
cluster_rows = FALSE,
cluster_cols = FALSE,
show_rownames = TRUE,
show_colnames = TRUE,
display_numbers = TRUE,
number_format = "%.0f"
#legend_breaks = uniquevalue
)
ggsave(heatmap_plot,
height = 8,
width = 12,
units = "in",
#height = 40,
#width = 80,
#units = "in",
limitsize = FALSE,
file = paste0("Plots/gp_tav_pft", ".png"))
#rm(colorcount); rm(heatmap_plot)
