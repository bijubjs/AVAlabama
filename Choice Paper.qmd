---
title: "Choice Paper"
author: "Bijesh Mishra, Ph.D."
toc: true
number-sections: true
colorlinks: true
format:
    pdf: default
    html:
      link-external-icon: true
      link-external-newwindow: true
    ipynb: default
editor: visual
editor_options:
  chunk_output_type: console
---

Techno-economic analysis of agrivoltaic systems in Alabama. A paper for [Choice Magazine](https://www.aaea.org/publications/choices-magazine){.uri} by AAEA.

# Setting Up

## Housekeeping

```{r, warning=FALSE, error=TRUE}
# #| echo: TRUE
rm(list = ls()) # Clean the environment.
options(
  warn=0, # Warnings. options(warn=-1) / options(warn=0)
  scipen=999 # No scientific notations.
  )
```

## Working directory

Codes and output are suppressed. Errors and warnings are visible. No warning and no error means code is working as it should.

```{r, echo=FALSE, results='hide', include = FALSE, error=TRUE, warning=TRUE}
path_mac = "/Users/bmishra/Library/CloudStorage/OneDrive-AuburnUniversity/Collaboration/Ngbede M/Choice-paper"
path_office = "Users\\bzm0094\\OneDrive - Auburn University\\Collaboration\\Ngbede M\\Choice-paper"
ifelse(Sys.info()[6] == "bmishra", 
       setwd(path_mac), 
       setwd(path_office))
```

## Load libraries

```{r, results='hide', error=TRUE, warning=FALSE}
library(tidyverse, warn.conflicts = FALSE, quietly = TRUE)
library(psych, warn.conflicts = FALSE, quietly = TRUE)
library(likert,  warn.conflicts = FALSE, quietly = TRUE) # Likert Items
library(mice,  warn.conflicts = FALSE, quietly = TRUE)
library(openxlsx2, warn.conflicts = FALSE, quietly = TRUE)
library(ggpubr, warn.conflicts = FALSE, quietly = TRUE) # Scatter plot
library(gmodels,  warn.conflicts = FALSE, quietly = TRUE) # Crosstab
library(reshape2, warn.conflicts = FALSE, quietly = TRUE) # Reshape data
library(pacman,  warn.conflicts = FALSE, quietly = TRUE) # Package Management
library(progress, warn.conflicts = FALSE, quietly = TRUE) #progress bar
library(arrow, warn.conflicts = FALSE, quietly = TRUE) #progress bar
```

```{r}
pacman::p_loaded()
```

## Progress Bar

Tracking data processing progress.

```{r}
####### Progress Bar #####
pb = progress_bar$new(
  format = "Processing data at :rate. Processed :bytes in :elapsed.",
  clear = TRUE,
  total = NA, 
  width = 80)
f = function() {
  for (i in 1:100) {
    pb$tick(sample(1:100 * 1000, 1))
    Sys.sleep(2/100)
  }
  pb$tick(1e7)
  #invisible()
}
```

## Theme for plots

Setting theme for plots:

```{r, warning=FALSE, error=TRUE, collapse=TRUE}
####### Plotting Data: #####
# Map Theme:
plottheme <- ggplot() +
  theme_void() +
  # Mapping theme:
  theme(axis.title = element_blank(),
        axis.ticks = element_blank(),
        axis.text = element_blank(),
        panel.border = element_blank(),
        plot.margin = margin(t = 0, 
                             r = 0, 
                             b = 0, 
                             l = 0, 
                             unit = "cm"),
        plot.title = element_text(hjust = 0.5),
        plot.background = element_rect(fill = "white", 
                                       color = "black",
                                       linewidth = 0),
        panel.background = element_rect(fill = "white", 
                                        color = "black",
                                        linewidth = 0),
        panel.grid.major.x = element_line(color = "lightgrey",
                                          linetype = 2,
                                          linewidth = 0),
        panel.grid.minor.x = element_line(color = "lightgrey",
                                          linetype = 2,
                                          linewidth = 0),
        panel.grid.major.y = element_line(color = "grey",
                                          linetype = 2,
                                          linewidth = 0),
        panel.grid.minor.y = element_line(color = "grey",
                                          linetype = 2,
                                          linewidth = 0),
        axis.line.x.top = element_line(color = "white",
                                       linetype = 2,
                                       linewidth = 0),
        axis.line.y.right = element_line(color = "white",
                                         linetype = 2,
                                         linewidth = 0),
        axis.line.x.bottom = element_line(color = "black",
                                          linetype = 1,
                                          linewidth = 0),
        axis.line.y.left = element_line(color = "black",
                                        linetype = 1,
                                        linewidth = 0),
        # Text formatting:
        text = element_text(family = "serif", # font
                            size = 12, # font size
                            colour = "black"# font color
        ),
        legend.position = c(0.95, -0.05),
        legend.key = element_rect(color = "black", 
                                  fill = NA, 
                                  linewidth = 0.05, 
                                  linetype = 1),
        legend.justification = "right",
        legend.direction = "horizontal")
```

# Import data

Import necessary data.

## Tomato

-   Yield = Total tomato production (total bucket of 25 lb) from 1 acres of land which varies from 10% to 200% of total production (100%). The range was simulated by multiplying 100% yield by yldvar.

-   yldvar = Yield variation parameter ranges from 10% to 200%.

-   Rev17 to Rev23 = Revenue for price ranges of \$17 to \$23 per bucket of tomato.

-   Total cost = Total cost of production for the given yield.

-   rolac17 to rolac23= Return to operator, labor and capital for price range of \$17 to \$23.

-   operator Cost = Operator labor cost at \$15/hour for given yield. For 100% yield, total hours = 90.

-   rlc17 to 23 = Return to land and capital after subtracting operator cost from total revenue.

```{r}
tomato <- read_xlsx("Parameters.xlsx",
                    sheet = "Tomato",
                    start_row = 2,
                    start_col = 9,
                    skip_empty_rows = TRUE,
                    skip_empty_cols = TRUE,
                    col_names = TRUE) %>% 
  rename(yield = Yield,
         yldvar = `Yield Variation (%)`)
dim(tomato)
head(tomato)
tail(tomato)
```

## Strawberry

-   Everything same as tomato.

-   Numbers 3 to 9 in names are price ranges for strawberry.

```{r}
strawberry <- read_xlsx("Parameters.xlsx",
                        sheet = "Strawberry",
                        start_row = 2,
                        start_col = 7,
                        skip_empty_rows = TRUE,
                        skip_empty_cols = TRUE,
                        col_names = TRUE) %>% 
  rename(yield = Yield,
         yldvar = `Yield Variation (%)`)
dim(strawberry)
head(strawberry)
tail(strawberry)
```

## Squash

-   Everything same as tomato and strawberry.

-   Numbers 11 to 17 in names are price ranges for squash.

```{r}
squash <- read_xlsx("Parameters.xlsx",
                    sheet = "Squash",
                    start_row = 2,
                    start_col = 8,
                    skip_empty_rows = TRUE,
                    skip_empty_cols = TRUE,
                    col_names = TRUE) %>% 
  rename(yield = Yield,
         yldvar = `Yield Variation (%)`)
dim(squash)
head(squash)
tail(squash)
```

## Electricity price

Electricity price ranges from 1 cents to 6 cents in 0.5 cent increment. Previously, I used AL retail electricity price as described below. It's no longer in use but I description below here for the record.

Electricity price (\$/kWh) was retail electricity price range for Alabama based on retail electricity price in April 2023 and April 2024 taken from [DOE Database](https://www.eia.gov/electricity/monthly/epm_table_grapher.php?t=epmt_5_6_a). Retail electricity price range in Alabama was from 6.44 to 15.85 cents/kWh in April 2023 and April 2024 which represents industry, commercial, and residential prices.

```{r}
elec_price <- read_xlsx("Parameters.xlsx",
                              sheet = "Electricity Price") %>%
  rename(epr_kwh = `Electricity Price ($/kWh)`)
dim(elec_price)
elec_price
```

## PV system cost

-   Data taken from "[Capital Costs for Dual-Use Photovoltaic Installations: 2020 Benchmark](https://www.nrel.gov/docs/fy21osti/77811.pdf){.uri}" Table 1 and Figure 3.
-   This data was used to estimate CAPEX.
-   avtyps = agrivoltaic types.
-   item = itemized component of system.
-   cost = cost of each item.
-   height = ground to panel clearance height (ft.)
-   tcost = Total cost is the sum of all itemized cost for AV system. See figure 3 and table 1 in above document for more detail.

```{r}
pvsc <- wb_read(file = "Parameters.xlsx",
                sheet = "PV system Cost (NREL)",
                rows = c(1:109),
                cols = c(1:5),
                col_names = TRUE) %>%
  rename(avtyps = `AV Types`,
         item = Item,
         cost = `Cost ($/W)`,
         height = `Panel Height (ft.)`,
         tcost = `Total Cost ($/W)`)
dim(pvsc)
head(pvsc)
tail(pvsc)
```

## Capex (NREL)

Variable Descriptions:

-   Capex: Capital investment cost (\$/W) to develop solar energy system. Capex includes cost of physical structure, developer's overhead and EPC/Developer's net profit.

-   capex estimated as f(height, tracker) using OLS for 6.4 ft Tracking system.

-   Height = ground to panel clearance in ft.

-   array: Solar array. Tracker = Single axis sun tracking panels; Fixed = Non-tracking panels.

```{r}
capex <- read.table(file = "CAPEX.txt",
                    header = TRUE,
                  sep = "\t") %>% 
  rename(capex = cost,
         height = pheight,
         array = tracker)
dim(capex)
capex
```

### Plotting capex

```{r}
plottheme %>% ggplot(data = capex,
                     mapping = (aes(
                       x = height,
                       y = capex,
                       color = array,
                       group = array))) +
  geom_point() +
  geom_line() +
  # geom_text(aes(label = "Tracker"),
  #           nudge_x = 0.05,
  #           nudge_y = 0.05,
  #           size = 6) +
  labs(
    title = "CAPEX Cost by Solar Panel Height",
    x = "Panel Height (ft.)",
    y = "CAPEX Cost ($/W)",
    color = "Array"
    ) +
  scale_x_continuous(limits = c(4.5, 8.5)) +
  scale_y_continuous(limits = c(1.5, 2.5)) +
  guides(color = guide_legend(reverse = TRUE))
```

## Panel Configuration

-   Panel configuration and DV system output (W).

```{r, results='markup'}
panconf <- wb_read(file = "Parameters.xlsx",
                sheet = "Panel Spacing",
                start_row = 2,
                start_col = 1,
                skip_empty_rows = TRUE,
                skip_empty_cols = TRUE,
                col_names = TRUE)
  # rename(avtyps = `AV Types`,
  #        item = Item,
  #        cost = `Cost ($/W)`,
  #        height = `Panel Height (ft.)`,
  #        tcost = `Total Cost ($/W)`)
dim(panconf)
head(panconf)
tail(panconf)
```

## Energy output

Energy output was simulated using NREL [PV Watts Calculator](https://pvwatts.nrel.gov/pvwatts.php){.uri}.

-   sprop = land proportion covered by solar in 1 acres. Value ranges from 0 to 1.

-   Panels = Total number of panels in 1 acres of land.

-   datalot: 1 = first simulation done for four regions of AL; 2 = second simulation done for four regions of AL. Two simulations have two unique zipcodes for each simulated region.

-   al_regs = regions of Alabama

-   zips = zipcodes selected from each region of AL for simulation.

-   array = Fixed (open rack); 1AxisRot = 1 Axis Tracking. See above NREL tool for more detail.

-   dc_kw = DC system size, calculated for each solar panel heights considering solar panels efficiency and area covered by solar panels.

-   energy = total energy output ( kWh/Year) considering system parameters. Total hours considered by the model is 8,760 (See [PV Watts Calculator](https://pvwatts.nrel.gov/pvwatts.php){.uri} Results \> help (below the result) \> results \> download monthly or hourly results).

```{r, echo=TRUE, results='show', warning=TRUE, error=TRUE}
energy_output <- read_xlsx("Parameters.xlsx", 
                           sheet = "Energy Output",
                           start_row = 1,
                           start_col = 1,
                           skip_empty_rows = TRUE,
                           skip_empty_cols = TRUE,
                           col_names = TRUE) %>%
  rename(sprop = `Solar Proportion`,
         panels = `Total Panels`,
         datalot = DataLot,
         al_regs = `Region of AL`,
         zips = ZIPCODE,
         array = `Array Type`,
         dc_kw = `DC System Size (kW)`,
         energy = `Energy (kWh/Year)`) %>%
  mutate(dc_kw = round(dc_kw, 2),
         array = case_when(
           array == "1AxisRot" ~ "Tracking",
           array == "FixedOpen" ~ "Fixed",
           TRUE ~ array))

dim(energy_output)
head(energy_output)
tail(energy_output)
```

### Energy output by solar panels counts

Plotting Energy output by number of solar panels in one acres of AV system from fixed and single axis rotation system for two zipcodes (1, 2) within each of the four regions of AL.

```{r}
lox <- c("Northern", "Central", "Black Belt", "Southern")
array_levs = c("Single Axis Rotation", "Fixed Open Rack")
datalot_levs = c("Location 1", "Location 2")
ggplot(data = energy_output,
         mapping = aes(x = al_regs,
                       y = energy,
                       #fill = energy,
                       color = factor(panels),
                       group = factor(panels))) +
  geom_line()+
  geom_point() +
  facet_grid(datalot~array) +
  scale_x_discrete(limits = lox) +
  guides(color = guide_legend(reverse = TRUE))
```

### Energy output by DC System Size

Plotting Energy output by DC System Size from fixed and single axis rotation system for two zipcodes (1, 2) within each of the four regions of AL.

```{r}
ggplot(data = energy_output,
         mapping = aes(x = al_regs,
                       y = energy,
                       #fill = energy,
                       color = factor(dc_kw),
                       group = factor(dc_kw))) +
  geom_line()+
  geom_point() +
  facet_grid(datalot~array) +
  scale_x_discrete(limits = lox) +
  guides(color = guide_legend(reverse = TRUE))
```

# Revenue from energy

## Simulation 1

-   elcprc = electricity price. See Electricity price data for more detail.

-   elcrev = Revenue from electricity for given electricity prices. See "energy output" and "electricity price" dataset for more details.

-   I took average of "energy" from datalot 1 and datalot 2 to minimize computation time.

```{r, echo=TRUE, error=TRUE}
# Convert to data frames if they are not already
matrix1 <- energy_output  %>%
  group_by(sprop, al_regs, array, dc_kw, panels) %>%
  #filter(datalot == 2) %>%
  # Compute mean of datalot 1 and datalot 2:
  summarise(
    energy = mean(energy),
    .groups = 'drop'
    ) # dimension of matrix is 168*6
matrix2 <- elec_price # dimension of matrix is 11*1

# Initialize the result data frame
# energy_revenue <- data.frame(matrix(nrow = 1848, ncol = 9))
energy_revenue <- data.frame(
  matrix(nrow = nrow(matrix2)*nrow(matrix1),
         ncol = ncol(matrix2)+ncol(matrix1)+1))

# Variable to keep track of the row index in the result matrix
row_index <- 1

# Loop through each value of the second matrix
for (i in 1:nrow(matrix2)) {
  # Loop through each value of the second matrix
  for (j in 1:nrow(matrix1)) {
    # First matrix, second matrix, combined two matrices.
    new_row <- c(matrix1[j, ], 
                 matrix2[i, ], 
                 matrix1$energy[j] * matrix2$epr_kwh[i])
    # Assign the new row to the result matrix
    energy_revenue[row_index, ] <- new_row
    # Increment the row index
    row_index <- row_index + 1
  }
}
# Name the columns
colnames(energy_revenue) <- c(colnames(matrix1), "elcprc", "elcrev")

# Display the result
dim(energy_revenue)
head(energy_revenue); tail(energy_revenue)

# Check for any NAs in the result
if(any(is.na(energy_revenue))) {
  na_indices <- which(is.na(energy_revenue), arr.ind = TRUE)
  print(paste("NAs found at rows:", unique(na_indices[, 1])))
} else {
  print("No NAs found in the result data frame.")
}
```

## Simulation 2

This simulation has same result as above (Cross checking above code and output). Results are suppressed but errors and warnings are not. No error and no warnings means code is working as it should.

```{r, echo=TRUE, results='hide', include = TRUE, error=TRUE, warning=TRUE}
## | results='hide'
# Sample data
set.seed(123)
matrix1 <- energy_output # dimension of matrix is 176*7
matrix2 <- elec_price # dimension of matrix is 11*1

# Initializing the result matrix
result_matrix <- data.frame(matrix(ncol = nrow(matrix2),
                                   nrow = 0))
colnames(result_matrix) <- c(colnames(matrix1),  "elcrev", "elcprc")

# Loop to multiply first and second matrices
for (i in 1:nrow(matrix2)) {
  temp_matrix <- matrix1
  temp_matrix$E_Prc <- matrix2[i, ]
  temp_matrix$E_Rev <- matrix1$energy[j] * matrix2$epr_kwh[i]
  result_matrix <- rbind(result_matrix, temp_matrix)
}

# Display the resulting matrix
dim(result_matrix)
head(result_matrix)
tail(result_matrix)
```

## Plotting revenue from energy production

### Breakdown by number of solar panels

I am using data from simulation 1 for this visualization. This code plots one chart per electricity cost. There are 11 electricity cost resulting into 11 charts.

```{r}
lox <- c("Northern", "Central", "Black Belt", "Southern")
array_levs = c("Single Axis Rotation", "Fixed Open Rack")
datalot_levs = c("Location 1", "Location 2")
for (i in unique(energy_revenue$elcprc)) {
 a = ggplot(data = (energy_revenue %>%
  filter(elcprc == i)),
         mapping = aes(x =al_regs,
                       y = elcrev,
                       #fill = energy,
                       color = factor(panels),
                       group = factor(panels)))+
  geom_line()+
  geom_point()+
  facet_grid(.~array) +
  scale_x_discrete(limits = lox) +
   guides(color = guide_legend(reverse = TRUE))
 cat("Electricity Price = ", i)
 print(a)
}
```

### Breakdown by proportion of land under solar panels

-   Two proportions may have same number of solar panels (Eg. 0.80 and 0.85, 0.20 and 0.25). So, total lines in the chart may not match with total number of legend levels. Some proportions are overlapping in the chart. See panel configuration for more detail.

```{r}
lox <- c("Northern", "Central", "Black Belt", "Southern")
array_levs = c("Single Axis Rotation", "Fixed Open Rack")
datalot_levs = c("Location 1", "Location 2")
for (i in unique(energy_revenue$elcprc)) {
 a = ggplot(data = (energy_revenue %>%
  filter(elcprc == i)),
         mapping = aes(x =al_regs,
                       y = elcrev,
                       #fill = energy,
                       color = factor(sprop),
                       group = factor(sprop)))+
  geom_line()+
  geom_point()+
  facet_grid(.~array) +
  scale_x_discrete(limits = lox) +
   guides(color = guide_legend(reverse = TRUE))
 cat("Electricity Price = ", i)
 print(a)
}
```

# Solar system cost

-   Cost of solar energy system in agrivoltaic setting.

-   I used DC system size (dc_kw) and capex (\$/W) to get total cost for each height and panel tracking system.

-   1 kw dc system size costs x\$ CAPEX for given height and tracking system.

-   y kw dc system size costs \$x\*y for given height and tracking system.

-   Use simulation 1 data and capex data to get solar system cost.

-   There should be 1936\*3 = 5808 rows in this dataset.

-   height = height of solar panels; see capex dataset for details.

-   capex = capex from capex table; see capex dataset for details.

-   ttlcost = Total cost for given DC system size.

-   anncost = Annual payment to repay loan ($P_{ann}$) = $\frac{P_o(i(1 + i)^t)}{(1+i)^t - 1)}$ , where $P_o$ = CAPEX loan burrowed to repay in $t$ years; $t = 25$, and $i$ = annual interest rate at $5\%$.

-   moncost = Monthly payment to repay loan ($P_{mon}$) = $\frac{P_o((i/12)(1 + (i/12))^{t*12})}{(1+(i/12))^{t*12} - 1)}$, where $P_o$ = CAPEX loan burrowed to repay in $t$ years; $t = 25$, and $i$ = annual interest rate at $5\%$.

```{r, warning=FALSE, results='hide', error=FALSE, echo=FALSE}
cat("energy_revenue dimension = ", dim(energy_revenue)) # 1936*9
names(energy_revenue)
cat("capex = ", dim(capex)) # 6*3
names(capex)
```

```{r, echo=TRUE, results='show', error=TRUE, warning=TRUE}
expanded_data <- energy_revenue %>%
  slice(rep(1:n(),
            each = 3))
capex_height <- rep(unique(capex$height),
                    length.out = nrow(energy_revenue))
energy_cost = cbind(expanded_data, capex_height) %>% 
  rename(height = capex_height)

energy_cost <- left_join(energy_cost, 
                         capex, 
                         by = c("array", "height")) %>% 
  mutate(ttlcost = capex*dc_kw,
         anncost = ttlcost*(0.05*(1 + 0.05)^25)/((1 + 0.05)^25 - 1),
         moncost = ttlcost*((0.05/12)*(1 + (0.05/12))^(25*12))/((1 + (0.05/12))^(25*12) - 1))

dim(energy_cost)
head(energy_cost)
tail(energy_cost)
```

# Profit from solar

Profit from solar energy system in agrivoltaic setting

-   eprofit = profit from electricity after subtracting total cost (ttlcost) from total revenue (elcrev).
-   eannprof = annual profit from solar after subtracting annual loan repayment distributed over 25 years.
-   emonprof = monthly profit from solar after subtracting monthly loan repayment distributed over 25 years.

```{r}
solar_profit <- energy_cost %>%
  mutate(eprofit = elcrev - ttlcost,
         eannprof = elcrev - anncost,
         emonprof = (elcrev/12) - moncost)
dim(solar_profit)
head(solar_profit)
tail(solar_profit)
```

## Plot profit from solar

```{r}
lox <- c("Northern", "Central", "Black Belt", "Southern")
array_levs = c("Single Axis Rotation", "Fixed Open Rack")
datalot_levs = c("Location 1", "Location 2")
  for (i in unique(solar_profit$elcprc)) {
    b = ggplot(
      data = (solar_profit %>%
                filter(elcprc == i)),
      mapping = aes(
        x = al_regs,
        y = eprofit,
        #fill = energy,
        color = factor(panels),
        group = factor(panels)
      )
    ) +
      geom_line() +
      geom_point() +
      facet_grid(height ~ array) +
      scale_x_discrete(limits = lox) +
      guides(color = guide_legend(reverse = TRUE))
    cat("Electricity Price = ", i)
    print(b)
  }
```

# Profit from crops

## Tomato

Filter return to operator, land and capital profit from Tomato:

```{r}
tomato_profit = tomato %>% 
  select(yldvar, yield, 
         rolac17, rolac18, rolac19, rolac20, 
         rolac21, rolac22, rolac23)
dim(tomato_profit)
tomato_profit
```

Convert data to long format:

```{r}
# Assign column names for clarity
colnames(tomato_profit) <- c("yldvar", "yield",
                  "rolac17", "rolac18", "rolac19",
                  "rolac20", "rolac21", "rolac22",
                  "rolac23")

# Reshape the data frame from wide to long format
tomato_long <- melt(tomato_profit,
                id.vars = c("yldvar", "yield"),
                measure.vars = c("rolac17", "rolac18", "rolac19",
                                 "rolac20", "rolac21", "rolac22",
                                 "rolac23"),
                variable.name = "price",
                value.name = "profit")

# Convert the 'Price' column to numeric by extracting the number
tomato_long$price <- as.numeric(gsub("rolac", "", tomato_long$price))

# View the resulting data frame
dim(tomato_long)
head(tomato_long)
tail(tomato_long)
```

### Profit from tomato

```{r}
ggplot(data = tomato_long,
       mapping = aes(x = price,
                     y = profit,
                     color = factor(yldvar),
                     group = factor(yield))) +
  geom_line() +
  geom_point() +
  geom_hline(yintercept = 0,
             linetype = "dashed",
             color = "black") +
  guides(color = guide_legend(reverse = TRUE))
```

```{r}
ggplot(data = tomato_long,
       mapping = aes(x = yield,
                     y = profit,
                     #fill = yield,
                     color = factor(price),
                     group = factor(price))) +
  geom_line() +
  geom_point() +
  geom_hline(yintercept = 0,
             linetype = "dashed",
             color = "black") +
  # Vertical dashed line is 100% yield
  geom_vline(xintercept = tomato_long$yield[11],
             linetype = "dashed",
             color = "black") +
guides(color = guide_legend(reverse = TRUE))
```

## Strawberry

Filter return to operator, land and capital profit from strawberry

```{r}
strawberry_profit = strawberry %>% 
  select(yldvar, yield, 
         rolac3, rolac4, rolac5, rolac6, rolac7, rolac8, rolac9)
dim(strawberry_profit)
strawberry_profit
```

Convert data to long format:

```{r}
# Assign column names for clarity
colnames(strawberry_profit) <- c("yldvar", "yield",
                  "rolac3", "rolac4", "rolac5",
                  "rolac6", "rolac7", "rolac8",
                  "rolac9")
# Reshape the data frame from wide to long format
stberry_long <- melt(strawberry_profit,
                id.vars = c("yldvar", "yield"),
                measure.vars = c("rolac3", "rolac4", "rolac5",
                                 "rolac6", "rolac7", "rolac8",
                                 "rolac9"),
                variable.name = "price",
                value.name = "profit")

# Convert the 'Price' column to numeric by extracting the number
stberry_long$price <- as.numeric(gsub("rolac", "", stberry_long$price))

# View the resulting data frame
dim(stberry_long)
head(stberry_long)
tail(stberry_long)
```

### Plot Strawberry Profit

```{r}
ggplot(data = stberry_long,
       mapping = aes(x = price,
                     y = profit,
                     color = factor(yldvar),
                     group = factor(yield))) +
  geom_line() +
  geom_point() +
  geom_hline(yintercept = 0,
             linetype = "dashed",
             color = "black") +
  guides(color = guide_legend(reverse = TRUE))
```

```{r}
ggplot(data = stberry_long,
       mapping = aes(x = yield,
                     y = profit,
                     color = factor(price),
                     group = factor(price))) +
  geom_line() +
  geom_point() +
  geom_hline(yintercept = 0,
             linetype = "dashed",
             color = "black") +
  #Vertical dashed line is 100% yield
  geom_vline(xintercept = stberry_long$yield[11],
             linetype = "dashed",
             color = "black") +
  guides(color = guide_legend(reverse = TRUE))
```

## Squash

Filter return to operator, land and capital profit from squash

```{r}
squash_profit = squash %>% 
  select(yldvar, yield, 
         rolac11, rolac12, rolac13, rolac14, 
         rolac15, rolac16, rolac17)
squash_profit
```

Convert data to long format:

```{r}
# Assign column names for clarity
colnames(squash_profit) <- c("yldvar", "yield",
                  "rolac11", "rolac12", "rolac13",
                  "rolac14", "rolac15", "rolac16",
                  "rolac17")

# Reshape the data frame from wide to long format
squash_long <- melt(squash_profit,
                id.vars = c("yldvar", "yield"),
                measure.vars = c("rolac11", "rolac12", "rolac13",
                                 "rolac14", "rolac15", "rolac16",
                                 "rolac17"),
                variable.name = "price",
                value.name = "profit")

# Convert the 'Price' column to numeric by extracting the number
squash_long$price <- as.numeric(gsub("rolac", "", squash_long$price))

# View the resulting data frame
dim(squash_long)
head(squash_long)
tail(squash_long)
```

### Profit from squash:

```{r}
ggplot(data = squash_long,
       mapping = aes(x = price,
                     y = profit,
                     color = factor(yldvar),
                     group = factor(yield))) +
  geom_line() +
  geom_point() +
  geom_hline(yintercept = 0,
             linetype = "dashed",
             color = "black") +
  guides(color = guide_legend(reverse = TRUE))
```

```{r}
ggplot(data = squash_long,
       mapping = aes(x = yield,
                     y = profit,
                     color = factor(price),
                     group = factor(price))) +
  geom_line() +
  geom_point() +
  geom_hline(yintercept = 0,
             linetype = "dashed",
             color = "black") +
  # Vertical dashed line is 100% yield
    geom_vline(xintercept = squash_long$yield[11],
             linetype = "dashed",
             color = "black") +
  guides(color = guide_legend(reverse = TRUE))
```

# Profit from agrivoltaics

Total profit from solar and crops for all combinations of AVs simulated.

## Profit from tomato agrivoltaic system

-   Joint profit from tomato (tomato_long) and solar energy production (solar_profit) from 1 acre of land.
-   The last variable (tav_profit) is the final profit from tomato agrivoltaic system which is the result of our interest.

```{r, echo=TRUE, results='show', cache=TRUE, error=TRUE, warning=TRUE}
# Generate all combinations of row indices from both matrices
index_combinations <- expand.grid(1:nrow(solar_profit),
                                  1:nrow(tomato_long))

# Define a function to process each combination of indices
process_combination <- function(indices) {
  i <- indices[1]
  j <- indices[2]
  new_row <- c(solar_profit[i, ],
               tomato_long[j, ], 
               #solar_profit[i, 14] = eannprof
               solar_profit$eannprof[i] + tomato_long$profit[j]) 
  return(new_row)
}

# Apply the function to each combination of indices and combine the results into a matrix
tav_profit <- do.call(rbind,
                          lapply(
                            seq_len(nrow(index_combinations)),
                            function(k) {
                              indices <- as.integer(
                                index_combinations[k, ])
                              process_combination(indices)
                              }))

# Optionally, you can convert the result back to a data frame if needed
tav_profit <- as.data.frame(tav_profit) %>%
    rename(tav_profit = V21)
tav_profit <- data.frame(lapply(tav_profit, unlist))
str(tav_profit)
head(tav_profit)
tail(tav_profit)
```

### Saving results locally

```{r}
#write_csv(tav_profit, "tav_profit.csv")
write_feather(tav_profit,
  sink = "tav_profit.feather",
  version = 2,
  chunk_size = 65536L,
  compression = c("default"),
  #compression = c("default", "lz4", "lz4_frame", "uncompressed", "zstd"),
  compression_level = NULL
)
```

## Profit from strawberry agrivoltaic system

-   Joint profit from strawberry (stberry_long) and solar energy production (solar_profit) from 1 acre of land.
-   The last variable (sbav_profit) is the final profit from strawberry agrivoltaic system which is the result of our interest.

```{r, echo=TRUE, results='show', cache=TRUE, error=TRUE, warning=TRUE}
# Generate all combinations of row indices from both matrices
index_combinations <- expand.grid(1:nrow(solar_profit),
                                  1:nrow(stberry_long))

# Define a function to process each combination of indices
process_combination <- function(indices) {
  i <- indices[1]
  j <- indices[2]
  new_row <- c(solar_profit[i, ],
               stberry_long[j, ], 
               #solar_profit[i, 14] = eannprof
               solar_profit$eannprof[i] + stberry_long$profit[j])
  return(new_row)
}

# Apply the function to each combination of indices and combine the results into a matrix
sbav_profit <- do.call(rbind, 
                          lapply(
                            seq_len(nrow(index_combinations)),
                            function(k) {
                              indices <- as.integer(
                                index_combinations[k, ])
                              process_combination(indices)
                              }))

# Optionally, you can convert the result back to a data frame if needed
sbav_profit <- as.data.frame(sbav_profit) %>%
  rename(sbav_profit = V21)
sbav_profit <- data.frame(lapply(sbav_profit, unlist))
str(sbav_profit)
head(sbav_profit)
tail(sbav_profit)
```

### Saving results locally

```{r}
#write_csv(sbav_profit, "tav_profit.csv")
write_feather(sbav_profit,
  sink = "sbav_profit.feather",
  version = 2,
  chunk_size = 65536L,
  compression = c("default"),
  #compression = c("default", "lz4", "lz4_frame", "uncompressed", "zstd"),
  compression_level = NULL
)
```

## Profit from squash agrivoltaic system

-   Joint profit from squash (squash_long) and solar energy production (solar_profit) from 1 acre of land.
-   The last variable (sqav_profit) is the final profit from squash agrivoltaic system which is the result of our interest.

```{r, echo=TRUE, results='show', cache=TRUE, error=TRUE, warning=TRUE}
# Generate all combinations of row indices from both matrices
index_combinations <- expand.grid(1:nrow(solar_profit),
                                  1:nrow(squash_long))

# Define a function to process each combination of indices
process_combination <- function(indices) {
  i <- indices[1]
  j <- indices[2]
  new_row <- c(solar_profit[i, ],
               squash_long[j, ],
               #solar_profit[i, 14] = eannprof
               solar_profit$eannprof[i] + squash_long$profit[j])
  return(new_row)
}

# Apply the function to each combination of indices and combine the results into a matrix
sqav_profit <- do.call(rbind, 
                          lapply(
                            seq_len(nrow(index_combinations)),
                            function(k) {
                              indices <- as.integer(
                                index_combinations[k, ])
                              process_combination(indices)
                              }))

# Optionally, you can convert the result back to a data frame if needed
sqav_profit <- as.data.frame(sqav_profit) %>%
  rename(sqav_profit = V21)
sqav_profit <- data.frame(lapply(sqav_profit, unlist))
str(sqav_profit)
head(sqav_profit)
tail(sqav_profit)
```

### Saving results locally

```{r}
#write_csv(sqav_profit, "tav_profit.csv")
write_feather(sqav_profit,
  sink = "sqav_profit.feather",
  version = 2,
  chunk_size = 65536L,
  compression = c("default"),
  #compression = c("default", "lz4", "lz4_frame", "uncompressed", "zstd"),
  compression_level = NULL
)
```
